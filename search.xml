<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CPP面试题目01</title>
      <link href="/posts/b275f201.html"/>
      <url>/posts/b275f201.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、C和CPP的区别"><a href="#1、C和CPP的区别" class="headerlink" title="1、C和CPP的区别"></a>1、C和CPP的区别</h2><p>1、C是面向过程的语言，是一个结构化的语言，而CPP是面向对象的语言，主要特征是封装、继承、多态。</p><p>2、C和C++动态管理内存的方法不一样，C是使用malloc/free，而CPP是new/delete、。</p><p>3、CPP中有引用，C不存在引用的概念。</p><h2 id="2、CPP中指针和引用的区别"><a href="#2、CPP中指针和引用的区别" class="headerlink" title="2、CPP中指针和引用的区别"></a>2、CPP中指针和引用的区别</h2><p>1、指针是一个新的变量，存储另一个变量的地址，我们可以通过访问这个地址来修改这个变量。引用只是一个别名，还是变量本身，对引用的任何操作就是对变量本身的操作，以达到修改变量的目的。</p><p>2、引用只有一级，而指针有多级。</p><p>3、指针传参时，还是值传递，指针本身的值不可修改，需要通过解引用才能对指向对象进行操作。引用传参时，传进来的就是变量本身，因此变量可以被修改。</p><h2 id="3、结构体struct和union-联合-的区别"><a href="#3、结构体struct和union-联合-的区别" class="headerlink" title="3、结构体struct和union(联合)的区别"></a>3、结构体struct和union(联合)的区别</h2><p>1、结构体：将不同类型的数据组合成一个整体，是自定义类型。共同体：不同类型的几个变量共同占用一段内存</p><p>2、结构体中的每个成员都有自己独立的地址，它们是同时存在的。共同体中的所有成员占用同一段内存，它们不能同时存在。</p><h2 id="4、-define和const的区别"><a href="#4、-define和const的区别" class="headerlink" title="4、#define和const的区别"></a>4、#define和const的区别</h2><p>1、#define定义的常量没有类型，所以给出的是一个立即数；const定义的常量有类型名字，存放在静态区域。</p><p>2、处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。</p><p>3、#define定义的常量是不可以用指针去指向的，const定义的常量可以用指针去指向该常量的地址。</p><p>4、#define可以定义简单的函数，const不可以定义函数。</p><h2 id="5、new、delete、malloc、free之间的关系"><a href="#5、new、delete、malloc、free之间的关系" class="headerlink" title="5、new、delete、malloc、free之间的关系"></a>5、new、delete、malloc、free之间的关系</h2><p>1、malloc对开辟的空间大小严格指定，而new只需要对象名。</p><p>2、new为对象分配空间时，调用类对象的构造函数，delete调用类对象的析构函数。</p><p>3、malloc/free是库函数，new/delete是CPP的运算符。</p><p>对于非内部数据类型而言，光用malloc/free无法满足动态类对象的要求。new/delete是运算符，编译器保证调用构造和析构函数对类对象进行初始化/析构。但是库函数malloc/free，不会执行构造/析构。</p><h2 id="6、delete和delete-的区别"><a href="#6、delete和delete-的区别" class="headerlink" title="6、delete和delete[]的区别"></a>6、delete和delete[]的区别</h2><p>1、delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数。</p><p>2、用new分配的内存用delete释放，用new[]分配的内存用delete[]释放。</p><h2 id="7、const的作用"><a href="#7、const的作用" class="headerlink" title="7、const的作用"></a>7、const的作用</h2><p>1、const修饰类的成员变量，表示常量不可能被修改。</p><p>2、const修饰类的成员函数，表示函数不会修改类中的数据成员，不会调用其他非const的成员函数。</p><p>3、const函数只能调用const函数，非const函数可以调用const函数。</p><h2 id="8、堆和栈的区别"><a href="#8、堆和栈的区别" class="headerlink" title="8、堆和栈的区别"></a>8、堆和栈的区别</h2><p>1、栈 stack 存放函数的参数值、局部变量，由编译器自动分配释放。堆heap，是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收。</p><p>2、因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片。</p><h2 id="9、关键字static的作用"><a href="#9、关键字static的作用" class="headerlink" title="9、关键字static的作用"></a>9、关键字static的作用</h2><p>1、函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值。</p><p>2、模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内。</p><p>3、类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝。</p><p>4、类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量。</p><p><strong>注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象。</strong></p><h2 id="10、什么是内存泄漏？面对内存泄漏和指针越界的方法？"><a href="#10、什么是内存泄漏？面对内存泄漏和指针越界的方法？" class="headerlink" title="10、什么是内存泄漏？面对内存泄漏和指针越界的方法？"></a>10、什么是内存泄漏？面对内存泄漏和指针越界的方法？</h2><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p><p>方法：malloc/free要配套，对指针赋值的时候应该注意被赋值的指针是否需要释放；使用的时候记得指针的长度，防止越界。</p>]]></content>
      
      
      <categories>
          
          <category> CPP面试题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP实现Vector容器</title>
      <link href="/posts/f6e04cde.html"/>
      <url>/posts/f6e04cde.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、实现一个高性能且跨平台的Vector"><a href="#1、实现一个高性能且跨平台的Vector" class="headerlink" title="1、实现一个高性能且跨平台的Vector"></a>1、实现一个高性能且跨平台的Vector</h2><p>知识点：</p><ul><li>CPP泛型编程(模板)</li><li>面向对象</li><li>运算符重载</li><li>CPP11的时间库</li><li>std标准库中实现内存移动的api</li></ul><p>Github：<a href="https://github.com/jjking20010901/Vector/tree/master">cpp实现vector</a></p><h2 id="2、API的封装"><a href="#2、API的封装" class="headerlink" title="2、API的封装"></a>2、API的封装</h2><p><strong>push_back(const T &amp;value)</strong>的解读：在向量的末尾，在其当前最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新元素。这有效地将容器大小增加了一个，这会导致自动重新分配分配的存储空间，前提是（并且仅当）新的向量大小超过当前向量容量。</p><p>push_back的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:尾插法插入数据</span></span><br><span class="line"><span class="comment"> * @param:泛型的数据</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&lt;m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[m_size]=value;</span><br><span class="line">        m_size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_capacity == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_capacity=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//容量不为0，则二倍扩容</span></span><br><span class="line">        m_capacity *=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开辟新的容量的容器</span></span><br><span class="line">    T *data= <span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="comment">//将原来容器中的数据移动到新的容器中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将原来容器的位置的内存释放</span></span><br><span class="line">    <span class="keyword">if</span>(m_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">    m_data[m_size]=value;</span><br><span class="line">    m_size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop_back()的解读：删除最后一个元素，移除向量中的最后一个元素，有效地将容器大小减少一个。</p><p>pop_back()的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:尾部弹出数据</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size()和capacity()方法的解读：获取容器中的元素数目；获取容器的容量。</p><p>size()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器当前大小</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器当前大小</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>capacity()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器容量</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器容量</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">capacity</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reserve(int n)方法解读：如果n大于当前向量容量，则该函数会导致容器重新分配其存储，将其容量增加到n（或更大）。在所有其他情况下，函数调用不会导致重新分配，向量容量也不会受到影响。</p><p>reserve(int n)方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:重新分配容器容量</span></span><br><span class="line"><span class="comment"> * @param:输入的容量</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">reserve</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_capacity&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩容，条件是当容量小于传入的容量大小</span></span><br><span class="line">    <span class="keyword">while</span>(m_capacity&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_capacity ==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态内存申请容量</span></span><br><span class="line">    T *data=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_data!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resize(int size)方法的解读：调整容器大小，使其包含size个元素，如果size小于当前容器大小，则内容将减少到其前size个元素，并删除（并销毁）超出的元素，如果size大于当前容器大小，则通过在末尾插入尽可能多的元素来扩展内容，以达到size的大小。如果指定了val，则将新元素初始化为val的副本，否则将对其进行值初始化。</p><p>resize(int size)方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:重新分配容器大小</span></span><br><span class="line"><span class="comment"> * @param:输入的大小</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">resize</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//容器内部大小大于或等于输入的大小</span></span><br><span class="line">    <span class="keyword">if</span>(m_size&gt;=size)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size=size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容器内部大小小于输入大小并且输入大小小于容器容量</span></span><br><span class="line">    <span class="keyword">if</span>(m_size &lt; size &amp;&amp; size&lt; m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m_size;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[i]=<span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_size=size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入大小大于容器容量</span></span><br><span class="line">    <span class="keyword">while</span>(m_capacity&lt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_capacity==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态申请扩容</span></span><br><span class="line">    T *data=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m_size;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_data!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">    m_size=size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>at(int index)方法的解读：返回容器中index索引位置的值。</p><p>at(int index)方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器索引下标的值</span></span><br><span class="line"><span class="comment"> * @param:容器索引下标</span></span><br><span class="line"><span class="comment"> * @return:返回容器索引下标的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不符合要求的数组下标，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;= m_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vec[] out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[]运算符的重载的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:重载中括号并获取索引下标值</span></span><br><span class="line"><span class="comment"> * @param:索引下标</span></span><br><span class="line"><span class="comment"> * @return:容器索引下标的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="keyword">operator</span> [] (<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>empty()方法和clear()方法的解读：判断容器是否为空；清空容器的元素。</p><p>empty()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:判断容器是否为空</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:若容器有数据返回true,否则返回false</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Vector&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:清空容器的数据</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_size=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>front()方法和back()方法的解读：获取容器第一个元素的值；获取最后一个元素的值。</p><p>front()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器的第一个元素的值</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器第一个元素的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vec is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>back()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器最后一个元素的值</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器最后一个元素的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vec is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_data[m_size<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap()方法的解读：交换两个容器的元素、大小以及容量。</p><p>swap()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:交换两个容器的数据、大小以及容量</span></span><br><span class="line"><span class="comment"> * @param:另一个容器对象</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">swap</span>(Vector&lt;T&gt; &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存储另外一个数组的临时数据</span></span><br><span class="line">    T *data=other.m_data;</span><br><span class="line">    <span class="type">int</span> size=other.m_size;</span><br><span class="line">    <span class="type">int</span> capacity=other.m_capacity;</span><br><span class="line"></span><br><span class="line">    other.m_data=m_data;</span><br><span class="line">    other.m_size=m_size;</span><br><span class="line">    other.m_capacity=m_capacity;</span><br><span class="line"></span><br><span class="line">    m_data=data;</span><br><span class="line">    m_size=size;</span><br><span class="line">    m_capacity=capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些api这里就不再做过多的解释，直接去gtihub看我的代码就行。</p><h2 id="3、Iterator的封装"><a href="#3、Iterator的封装" class="headerlink" title="3、Iterator的封装"></a>3、Iterator的封装</h2><p>在Vector中封装一个Iterator的类，用来代表迭代器。这里主要是通过运算符重载来实现迭代器的api。</p><p>两个迭代器相等的判断以及不等的判断的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Iterator &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pointer==other.m_pointer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> Iterator &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pointer !=other.m_pointer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器的拷贝赋值重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator &amp; <span class="keyword">operator</span> = (<span class="type">const</span> Iterator &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer=other.m_pointer;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器前置加1以及后置加1的封装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置加1</span></span><br><span class="line">Iterator <span class="keyword">operator</span> ++ ()</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置加1</span></span><br><span class="line">Iterator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Iterator it=*<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器加法和减法运算重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器加法运算重载</span></span><br><span class="line">Iterator <span class="keyword">operator</span> + (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    Iterator it=*<span class="keyword">this</span>;</span><br><span class="line">    it.m_pointer+=value;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器减法运算重载</span></span><br><span class="line">Iterator &amp; <span class="keyword">operator</span> - (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    Iterator it=*<span class="keyword">this</span>;</span><br><span class="line">    it.m_pointer-=value;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器+=和-=的重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器+=运算重载</span></span><br><span class="line">Iterator &amp; <span class="keyword">operator</span> += (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer+=value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器-=运算符重载</span></span><br><span class="line">Iterator &amp; <span class="keyword">operator</span> -= (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer-=value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器解引用和指针操作重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器解引用运算符重载</span></span><br><span class="line">T &amp; <span class="keyword">operator</span> * ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *m_pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器指针操作的运算符重载</span></span><br><span class="line">T * <span class="keyword">operator</span> -&gt; ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起始迭代器和结束迭代器的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//起始迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">begin</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(m_data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">end</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(m_data+m_size)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代器查找某个元素的位置(<strong>该方法STL-vector中未实现</strong>)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">find</span>(<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(Vector&lt;T&gt;::Iterator it=<span class="built_in">begin</span>();it!=<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert()方法的解读：通过在指定位置的元素之前插入新元素来扩展向量，从而有效地增加插入的元素数量的容器大小。</p><p>insert()方法的实现(函数重载)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator it,<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insert</span>(it,<span class="number">1</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator it,<span class="type">int</span> n,<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取插入位置的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> pos=it-<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//插入元素足够存放(无需扩容的情况)  </span></span><br><span class="line">    <span class="keyword">if</span>(m_size+n&lt;=m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当内部内存发生重叠使用memmove，拷贝内存，否则使用memcpy</span></span><br><span class="line">            std::<span class="built_in">memmove</span>(m_data+pos+n,m_data+pos,(m_size-pos)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m_size;i&gt;pos;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                m_data[i+n<span class="number">-1</span>]=m_data[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[pos+i]=value;</span><br><span class="line">        &#125;</span><br><span class="line">        m_size+=n;</span><br><span class="line">        <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">Iterator</span>(m_data+pos);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素过多,大于数组容量(扩容)</span></span><br><span class="line">    <span class="keyword">while</span>(m_size+n&gt;m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_capacity==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T *data=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memcpy</span>(data,m_data,m_size*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pos;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i]=m_data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memcpy</span>(data+pos+n,m_data+pos,(m_size-pos)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;m_size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i]=m_data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[pos+i]=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_data!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">    m_size+=n;</span><br><span class="line">    <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">Iterator</span>(m_data+pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>erase()方法的解读：从向量中移除单个元素（位置）或一系列元素（[第一个，最后一个））。</p><p>erase()方法的实现(函数重载)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断删除的元素是否为最后一个</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">end</span>() - it ==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除其他位置的元素</span></span><br><span class="line">    <span class="type">int</span> pos = it - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memmove</span>(m_data+pos,m_data+pos+<span class="number">1</span>,(m_size-pos<span class="number">-1</span>)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;m_size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[i]=m_data[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_size-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator first,</span><br><span class="line">                                              <span class="type">const</span> Vector&lt;T&gt;::Iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取消除元素的第一个区间</span></span><br><span class="line">    <span class="type">int</span> f=first - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//获取消除元素的第二个区间</span></span><br><span class="line">    <span class="type">int</span> l=last - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//数组长度变化</span></span><br><span class="line">    <span class="type">int</span> pos = last - first;</span><br><span class="line">    <span class="comment">//判断是否为基本类型，提高删除性能</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memmove</span>(m_data+f,m_data+l,(m_size-l)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//元素向前移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size-l;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[f]=m_data[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_size-=pos;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、STL-vector与Sakura-Vector性能对比"><a href="#4、STL-vector与Sakura-Vector性能对比" class="headerlink" title="4、STL-vector与Sakura-Vector性能对比"></a>4、STL-vector与Sakura-Vector性能对比</h2><p>insert()方法性能比较，代码如下：</p><p>STL-vector插入bool类型数据的时间(以插入10000个数据为例)：</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105202833288.png" alt="image-20221105202833288"></p><p>我们可以发现STL-vector所用时间为870.335ms。</p><p>Sakura-Vector插入bool类型数据的时间(以插入10000个数据为例)：</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105202959214.png" alt="image-20221105202959214"></p><p>我们可以发现Sakura-Vector所用时间为4.0109ms，其他类型的插入大体和STL-vector相近。</p><p>STL-vector删除bool类型数据的时间:</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105203859908.png" alt="image-20221105203859908"></p><p>我们可以发现STL-vector所用时间为984.158ms。</p><p>Sakura-Vector删除bool类型数据所用时间：</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105204011490.png" alt="image-20221105204011490"></p><p>我们可以发现Sakura-Vector所用时间为1.0451ms。</p><p>insert()的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*测试insert性能*/</span></span><br><span class="line">    <span class="keyword">auto</span> startTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max=<span class="number">10000</span>;</span><br><span class="line">    <span class="comment">//std::vector&lt;bool&gt;v;</span></span><br><span class="line">    Vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(),<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> endTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//毫秒级</span></span><br><span class="line">    <span class="type">double</span> duration_millsecond=std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>,std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;run time: &quot;</span>&lt;&lt; duration_millsecond&lt;&lt;<span class="string">&quot; ms&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>erase()的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*测试erase性能*/</span></span><br><span class="line"><span class="comment">// std::vector&lt;bool&gt;v1;</span></span><br><span class="line"> Vector&lt;<span class="type">bool</span>&gt;v1;</span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> max=<span class="number">10000</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     v1.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">auto</span> startTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">auto</span> endTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"> <span class="type">double</span> duration_millsecond=std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>,std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"> std::cout&lt;&lt;<span class="string">&quot;run time: &quot;</span>&lt;&lt; duration_millsecond&lt;&lt;<span class="string">&quot; ms&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP造轮子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共享智能指针</title>
      <link href="/posts/4c183086.html"/>
      <url>/posts/4c183086.html</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针的简介"><a href="#智能指针的简介" class="headerlink" title="智能指针的简介"></a>智能指针的简介</h2><p>在C++中没有垃圾回收机制，必须自己释放分配内存，否则就会造成内存泄漏。解决这个问题最有效的方法是使用智能指针(smart pointer)。<strong>智能指针是存储指向动态内存分配(堆)对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动的销毁动态分配的对象，防止内存泄漏。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</strong></p><p>C++11中提供了三种智能指针，使用这些智能指针时所需要引用的头文件为<strong><memory></strong>：</p><ul><li>std::shared_ptr：共享智能指针。</li><li>std::unique_ptr：独占智能指针。</li><li>std::weak_ptr：弱引用智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li></ul><h2 id="1、shared-ptr的初始化"><a href="#1、shared-ptr的初始化" class="headerlink" title="1、shared_ptr的初始化"></a>1、shared_ptr的初始化</h2><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，<strong>共享智能指针shared_ptr是一个模板类</strong>，<strong>如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。</strong>共享智能指针对象初始化完毕后就指向了要管理的那块堆内存，如果想要查看当前有多少智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数<strong>use_count，</strong>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><h2 id="1-1、通过构造函数初始化"><a href="#1-1、通过构造函数初始化" class="headerlink" title="1.1、通过构造函数初始化"></a>1.1、通过构造函数初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数, 语法格式如下:</span></span><br><span class="line">std::shared_ptr&lt;T&gt; 智能指针名字(创建堆内存);</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1.use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2.use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3.use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4.use_count: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191005888.png" alt="image-20220819100556838"></p><p><strong>注意：</strong></p><p><strong>如果智能指针被初始化一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为nullptr空指针，引用计数不会+1，另外，不要使用一个原始指针初始化多个shared_ptr。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">// error, 编译不会报错, 运行会出错，指针p已经初始化了p1了</span></span><br></pre></td></tr></table></figure><h2 id="1-2、通过拷贝和移动构造函数初始化"><a href="#1-2、通过拷贝和移动构造函数初始化" class="headerlink" title="1.2、通过拷贝和移动构造函数初始化"></a>1.2、通过拷贝和移动构造函数初始化</h2><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就可以被自动调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(std::move(ptr1))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">move</span>(ptr2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序结果的输出如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191016085.png" alt="image-20220819101609028"></p><p><strong>注意：</strong></p><p><strong>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始化智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存引用计数不会变化。</strong></p><h2 id="1-3、通过std-make-shared初始化"><a href="#1-3、通过std-make-shared初始化" class="headerlink" title="1.3、通过std::make_shared初始化"></a>1.3、通过std::make_shared初始化</h2><p>通过C++提供的std::make_shared()就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>T：模板参数的数据类型。</strong></p></li><li><p><strong>Arg&amp;&amp;…arg：要初始化的数据，如果是通过make_shared创建对象，需要按照构造函数的参数列表指定。</strong></p></li></ul><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(string str) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr2 = <span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr3 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr4 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码的输出结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191031378.png" alt="image-20220819103120318"></p><p><strong>注意：</strong></p><p><strong>使用st::make_shared()模板函数可以完成内存地址的创建，并将最终的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的()可完成地址的初始化，如果要创建一个类对象，函数的()内部需要指定构造函数对象需要的参数，也就是类构造函数的参数。</strong></p><h2 id="1-4、通过reset方法初始化"><a href="#1-4、通过reset方法初始化" class="headerlink" title="1.4、通过reset方法初始化"></a>1.4、通过reset方法初始化</h2><p>共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter, <span class="keyword">class</span> Alloc &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d, Alloc alloc )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>ptr：指向要取得所有权的对象的指针。</strong></li><li><strong>d：指向要取得所有权的对象的指针。</strong></li><li><strong>aloc：内部存储所用的分配器。</strong></li></ul><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1.use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2.use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3.use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4.use_count: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    ptr4.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1.use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2.use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3.use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4.use_count: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5.use_count: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191041241.png" alt="image-20220819104137179"></p><p><strong>注意：</strong></p><p><strong>对于一个未初始化的共享内存指针，可以通过reset方法初始化，当智能指针中有值时，调用reset方法会使引用计数减1。</strong></p><h2 id="1-5、获取原始指针"><a href="#1-5、获取原始指针" class="headerlink" title="1.5、获取原始指针"></a>1.5、获取原始指针</h2><p>对应用基础数据类型来说，通过操作智能指针和操作智能指针管理内存效果是一样的，可以直接完成数据的读写。</p><p>但是如果共享智能指针管理的是一个对象，那么就需要去除原始内存地址再操作，可以调用共享智能指针类提供的get方法得到原始地址，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">128</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[len])</span></span>;</span><br><span class="line">    <span class="comment">// 得到指针的原始地址</span></span><br><span class="line">    <span class="type">char</span>* add = ptr.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//初始化字符串</span></span><br><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0</span>, len);</span><br><span class="line">    <span class="built_in">strcpy</span>(add, <span class="string">&quot;I will be luffy !!!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; add &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; *p.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序的输出如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191056577.png" alt="image-20220819105634516"></p><h2 id="2、指定删除器"><a href="#2、指定删除器" class="headerlink" title="2、指定删除器"></a>2、指定删除器</h2><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针给析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数的本质就是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义删除器函数，释放int型内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int 型内存被释放了...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), deleteIntPtr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除器函数也可以lambda表达式，因此代码也可以写成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<strong>lambda表达式的参数就是智能指针管理内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</strong></p><p>在C++11中使用shared_ptr管理动态数组，需要指定删除器，因为std::make_shared_ptr的默认删除器不支持数组对象，具体处理代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在删除数组内存时，除了自己编写删除器，也可以使用<strong>C++提供的std::default_delete<T>()</strong>函数作为删除器。</p><p>这个函数内部删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型指定为什么类型即可，具体处理代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们也可以自己封装一个make_shared_array方法让shared_ptr支持数组，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_share_array</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回匿名对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T[size], <span class="built_in">default_delete</span>&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_share_array</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">char</span>&gt; ptr2 = <span class="built_in">make_share_array</span>&lt;<span class="type">char</span>&gt;(<span class="number">128</span>);</span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP11的学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 共享智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RALL原则和unique_ptr</title>
      <link href="/posts/d2973973.html"/>
      <url>/posts/d2973973.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、RALL简介"><a href="#1、RALL简介" class="headerlink" title="1、RALL简介"></a>1、RALL简介</h2><p><strong>RALL是resource acquisition is initialization的缩写，意思是”资源获取即初始化”。</strong>它是C++之父Bjarne Stroustrup提出的设计理念，其核心是把资源和对象的声明周期绑定，对象创建获取资源，对象销毁释放资源。在RALL的指导下，C++把底层的资源管理问题提升到了对象声明周期管理的更高层次。</p><h2 id="2、RALL机制"><a href="#2、RALL机制" class="headerlink" title="2、RALL机制"></a>2、RALL机制</h2><ul><li>使用C++时，最让人头疼的便是内存管理，但却又正是对内存高度可操作性给了C++程序员极大自由和装逼资本。</li><li>当我们在堆区new出一块内存空间，在使用完之后，如果不使用delete来释放这块资源则将导致内存泄漏，这在中大型项目中极具有破坏性。但人无完人，我们并不能保证每次都记得释放无法再次获取到且不再使用的内存，下面给出一个例子，让大家看看忘记释放资源造成内存泄漏多么恐怖！！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *ptr=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">        ptr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        ptr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        ptr[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//delete ptr    //忘记释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果(未释放内存)：</p><p>运行程序并打开资源管理器，可以发现这么简单的程序竟然占用了11点几的MB内存，所以大家千万要记得释放内存。</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105150404335.png" alt="image-20221105150404335"></p><h2 id="3、智能指针的介绍"><a href="#3、智能指针的介绍" class="headerlink" title="3、智能指针的介绍"></a>3、智能指针的介绍</h2><p>在 C++ 中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<strong>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</strong></p><p>C++11中提供了三种智能指针，使用这些智能指针需要引入头文件<memory>：</p><ul><li><strong>std::shared_ptr</strong>:共享的智能指针。</li><li><strong>std::unique_ptr</strong>:独占的智能指针。</li><li><strong>std::weak_ptr</strong>:弱引用智能指针，它不共享指针，不能操作资源，是用来监视std::shared_ptr的。</li></ul><h2 id="4、unique-ptr的初始化"><a href="#4、unique-ptr的初始化" class="headerlink" title="4、unique_ptr的初始化"></a>4、unique_ptr的初始化</h2><p>std::unique_ptr 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 unique_ptr 赋值给另一个 unique_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过构造函数初始化对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="comment">// error, 不允许将一个unique_ptr赋值给另一个unique_ptr</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br></pre></td></tr></table></figure><p>std::unique_ptr不允许复制，但是可以通过函数返回给其他std::unique_ptr，还可以通过std::move来转移给其他的std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">520</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 通过转移所有权的方式初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr3 = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique_ptr的指针类有一个reset方法，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( pointer ptr = pointer() )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>使用reset方法可以让unique_ptr解除对原始内存管理，也可以用来初始化一个独占智能指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr1.<span class="built_in">reset</span>();</span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ptr1.reset()</strong>; 解除对原始内存的管理</li><li><strong>ptr2.reset(new int(250))</strong>; 重新指定智能指针管理的原始内存</li></ul><p>如果想要获取独占智能指针管理原始地址，可以调用get()方法，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; *ptr2.<span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">// 得到内存地址中存储的实际数值 250</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、删除器"><a href="#5、删除器" class="headerlink" title="5、删除器"></a>5、删除器</h2><p>unique_ptr 指定删除器和 shared_ptr 指定删除器是有区别的，unique_ptr 指定删除器的时候需要确定删除器的类型，所以不能像 shared_ptr 那样直接指定删除器，举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;<span class="comment">// ok</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;<span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中第 7 行，<strong>func_ptr 的类型</strong>和 <strong>lambda表达式的类型</strong>是一致的。在 lambda 表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错。</p><p>上面的代码中错误原因是这样的，在 lambda 表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP11的学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RALL原则和独占智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汽车仪表盘绘制</title>
      <link href="/posts/cb2eafdb.html"/>
      <url>/posts/cb2eafdb.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、汽车仪表盘效果图"><a href="#1、汽车仪表盘效果图" class="headerlink" title="1、汽车仪表盘效果图"></a>1、汽车仪表盘效果图</h2><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301516841.png" alt="image-20220830151624760"></p><p>上面是通过QPainter绘制出来的汽车仪表盘，可能与真实的汽车仪表盘有些差距，但总体来说还可以吧，下面将会详细讲解如何绘制汽车仪表盘。</p><h2 id="2、绘制前的准备"><a href="#2、绘制前的准备" class="headerlink" title="2、绘制前的准备"></a>2、绘制前的准备</h2><p>首先我们将窗体背景设置为偏黑色，这样方便我们后续观察效果，以及将窗口固定位1280*800，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1280</span>,<span class="number">800</span>);</span><br><span class="line">QPalette pale=<span class="keyword">this</span>-&gt;<span class="built_in">palette</span>();</span><br><span class="line">pale.<span class="built_in">setBrush</span>(QPalette::Window,<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>)));</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setPalette</span>(pale);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301439671.png" alt="image-20220830143915607"></p><h2 id="3、绘制刻度线"><a href="#3、绘制刻度线" class="headerlink" title="3、绘制刻度线"></a>3、绘制刻度线</h2><p>首先我们要获取仪表盘的中心点radius以及仪表盘的宽高，然后将画笔移动到窗口的中下方，移动画笔也就是移动坐标系。</p><p>然后使用QPainter中的抗锯齿的方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="type">int</span> width=<span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line">   <span class="comment">//仪表盘高度</span></span><br><span class="line">   <span class="type">int</span> height=<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()<span class="number">-100</span>;</span><br><span class="line">   <span class="comment">//仪表盘中心位置</span></span><br><span class="line">   <span class="type">int</span> radius=((width&gt;height)? height:width)/<span class="number">2</span>;</span><br><span class="line">   <span class="comment">//移动画笔到中下方</span></span><br><span class="line">   painter.<span class="built_in">translate</span>(width/<span class="number">2</span>,height*<span class="number">0.6</span>);</span><br><span class="line">   <span class="comment">//启用反锯齿</span></span><br><span class="line">   painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>接下来就是画刻度线，首先我们要组装刻度点的路径，使用QPainterPath。然后是绘制长的刻度线，大于或者等于160的刻度值为红色，其他的刻度线为白色，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//画刻度线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawSmallScale</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//组装点的路径图</span></span><br><span class="line">    QPainterPath pointPath_small;</span><br><span class="line">    pointPath_small.<span class="built_in">moveTo</span>(<span class="number">-2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">-2</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QPainterPath pointPath_big;</span><br><span class="line">    pointPath_big.<span class="built_in">moveTo</span>(<span class="number">-2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">-2</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制121个小点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">121</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="function">QPointF <span class="title">point</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        point.<span class="built_in">setX</span>(radius*<span class="built_in">qCos</span>(((<span class="number">210</span>-i*<span class="number">2</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        point.<span class="built_in">setY</span>(radius*<span class="built_in">qSin</span>(((<span class="number">210</span>-i*<span class="number">2</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        painter.<span class="built_in">translate</span>(point.<span class="built_in">x</span>(),-point.<span class="built_in">y</span>());</span><br><span class="line">        painter.<span class="built_in">rotate</span>(<span class="number">-120</span>+i*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">235</span>,<span class="number">70</span>,<span class="number">70</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPath</span>(pointPath_big);<span class="comment">//绘画大刻度</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPath</span>(pointPath_small);<span class="comment">//绘画小刻度</span></span><br><span class="line">        &#125;</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301452519.png" alt="image-20220830145212461"></p><h2 id="4、刻度数字"><a href="#4、刻度数字" class="headerlink" title="4、刻度数字"></a>4、刻度数字</h2><p>在每一个更长的刻度线上绘制对应的数字，我们要找到对应的坐标，还要设置数字的字体以及大小，而且我们还要旋转画笔，让每个对应的数字都是在正确的位置，通过角度旋转的角度来计算弧度，然后通过弧度来获取对应的坐标，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刻度数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawDigital</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置画笔，画笔默认NOPEN</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">15</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;++i)&#123;</span><br><span class="line">        <span class="function">QPointF <span class="title">point</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        point.<span class="built_in">setX</span>(radius*<span class="built_in">qCos</span>(((<span class="number">210</span>-i*<span class="number">20</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        point.<span class="built_in">setY</span>(radius*<span class="built_in">qSin</span>(((<span class="number">210</span>-i*<span class="number">20</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        painter.<span class="built_in">translate</span>(point.<span class="built_in">x</span>(),-point.<span class="built_in">y</span>());</span><br><span class="line">        painter.<span class="built_in">rotate</span>(<span class="number">-120</span>+i*<span class="number">20</span>);</span><br><span class="line">        painter.<span class="built_in">drawText</span>(<span class="number">-25</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">20</span>,Qt::AlignCenter,QString::<span class="built_in">number</span>(i*<span class="number">20</span>));</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还原画笔</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301459646.png" alt="image-20220830145901581"></p><h2 id="5、绘制发光的圆圈"><a href="#5、绘制发光的圆圈" class="headerlink" title="5、绘制发光的圆圈"></a>5、绘制发光的圆圈</h2><p>在刻度线的四周绘制一种渐变色的发光圆圈，首先我们要创建大小圆的弧圈，通过arcTo方法，然后在小圆中绘制椭圆，通过addEllipse，然后通过QRadialGradient设置渐变色，最后通过drawPath方法获取大圆减小圆之后的路径，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath outRing;</span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    outRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    outRing.<span class="built_in">arcTo</span>(-radius,-radius, <span class="number">2</span>*radius,<span class="number">2</span>*radius,<span class="number">-30</span>,<span class="number">240</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    outRing.<span class="built_in">closeSubpath</span>();</span><br><span class="line">    <span class="comment">//设置渐变色k</span></span><br><span class="line">    <span class="function">QRadialGradient <span class="title">radialGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,radius,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">1</span>,<span class="built_in">QColor</span>(<span class="number">0</span>,<span class="number">82</span>,<span class="number">230</span>));</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">0.9</span>,Qt::transparent);</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(radialGradient);</span><br><span class="line">    <span class="comment">//大圆减小圆</span></span><br><span class="line">    painter.<span class="built_in">drawPath</span>(outRing.<span class="built_in">subtracted</span>(inRing));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301504164.png" alt="image-20220830150437094"></p><h2 id="6、绘制指针"><a href="#6、绘制指针" class="headerlink" title="6、绘制指针"></a>6、绘制指针</h2><p>和之前一样我们要组装点的路径，然后是计算点的坐标，这些都可以自己慢慢的试试，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawPointer</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//组装点的路径图</span></span><br><span class="line">    QPainterPath pointPath;</span><br><span class="line">    pointPath.<span class="built_in">moveTo</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">1</span>,-radius);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">-1</span>,-radius);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">-10</span>,<span class="number">0</span>);</span><br><span class="line">    pointPath.<span class="built_in">arcTo</span>(<span class="number">-10</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">180</span>,<span class="number">180</span>);</span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(<span class="number">-5</span>,<span class="number">-5</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算并选择绘图对象坐标</span></span><br><span class="line">    painter.<span class="built_in">rotate</span>(degRotate - <span class="number">120</span>);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(pointPath.<span class="built_in">subtracted</span>(inRing));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301508886.png" alt="image-20220830150828813"></p><h2 id="7、绘制中间大圆、小圆以及发光内圈"><a href="#7、绘制中间大圆、小圆以及发光内圈" class="headerlink" title="7、绘制中间大圆、小圆以及发光内圈"></a>7、绘制中间大圆、小圆以及发光内圈</h2><p>绘制大圆的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_big</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(inRing);</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制小圆的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_small</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(inRing);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制发光内圈的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_shine</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="function">QRadialGradient <span class="title">radialGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,radius,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//    radialGradient.setColorAt(0.5,QColor(8,77,197));</span></span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">0.5</span>,<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">68</span>,<span class="number">185</span>,<span class="number">150</span>));</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">1.0</span>,Qt::transparent);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QBrush</span>(radialGradient));</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(-radius,-radius,<span class="number">2</span>*(radius),<span class="number">2</span>*(radius));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301513631.png" alt="image-20220830151303554"></p><h2 id="8、绘制单位和时速"><a href="#8、绘制单位和时速" class="headerlink" title="8、绘制单位和时速"></a>8、绘制单位和时速</h2><p>绘制速度单位的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawUnit</span><span class="params">(QPainter &amp; painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">16</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-50</span>, -radius, <span class="number">100</span>, <span class="number">20</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;km/h&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-60</span>, -radius + <span class="number">130</span>, <span class="number">120</span>, <span class="number">40</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;当前车速&quot;</span>));</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">50</span>));</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-120</span>, -radius + <span class="number">280</span>, <span class="number">250</span>, <span class="number">40</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;-请按space键加速-&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制时速的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawNum</span><span class="params">(QPainter &amp; painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">45</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-75</span>, -radius - <span class="number">20</span>, <span class="number">150</span>, <span class="number">100</span>,Qt::AlignCenter,QString::<span class="built_in">number</span>(degRotate));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301515543.png" alt="image-20220830151543465"></p><h2 id="9、键盘事件和鼠标事件控制车速"><a href="#9、键盘事件和鼠标事件控制车速" class="headerlink" title="9、键盘事件和鼠标事件控制车速"></a>9、键盘事件和鼠标事件控制车速</h2><p>首先我们需要定义一个定时器timer，然后先将以下键盘事件，我们定义一个direction和degRotate，direction为0时代表减速或者车速为0，为1代表加速，degRotate代表车速，一开始为0。</p><p>当我们按下空格键时，定时器开始，同样的direction变为1，当定时器超时的时候，执行槽函数speed_changed。</p><p>下面是键盘按下事件的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>()==Qt::Key_Space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">            direction=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是槽函数speed_changed的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::speed_changed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(direction == <span class="number">1</span>)<span class="comment">//加速</span></span><br><span class="line">    &#123;</span><br><span class="line">        degRotate++;</span><br><span class="line">        <span class="keyword">if</span>(degRotate &gt; <span class="number">240</span>)</span><br><span class="line">            degRotate = <span class="number">240</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(direction == <span class="number">0</span>)<span class="comment">//减速</span></span><br><span class="line">    &#123;</span><br><span class="line">        degRotate--;</span><br><span class="line">        <span class="keyword">if</span>(degRotate &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            degRotate = <span class="number">0</span>;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们松开空格键时，direction为0，开始减速。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyReleaseEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>()==Qt::Key_Space)</span><br><span class="line">    &#123;</span><br><span class="line">        direction=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是鼠标点击事件和鼠标松开事件，当我们点击鼠标时，车速增加，松开时车速减少。</p><p>鼠标点击事件代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            is_Pressed=<span class="literal">true</span>;</span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">            direction=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标松开事件代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line">    is_Pressed=<span class="literal">false</span>;</span><br><span class="line">    direction=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、代码获取"><a href="#10、代码获取" class="headerlink" title="10、代码获取"></a>10、代码获取</h2><p>我已经将代码推送到了gitee上面了，想要源码的可以通过下方链接获取：</p><p><a href="https://gitee.com/GoodNightZoe/car-board.git">汽车仪表盘</a></p>]]></content>
      
      
      <categories>
          
          <category> QtWidget </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QtWidget自绘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值引用和完美转发</title>
      <link href="/posts/eaeeda04.html"/>
      <url>/posts/eaeeda04.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、右值引用的简介"><a href="#1、右值引用的简介" class="headerlink" title="1、右值引用的简介"></a>1、右值引用的简介</h2><p>C++11增加了一个新的类型，称为<strong>右值引用(R-value reference)</strong>，标记为 <strong>&amp;&amp;。</strong>在介绍右值引用类型之前要先了解什么是左值和右值：</p><ul><li>lvalue是<strong>locator value</strong>的缩写，rvalue是 <strong>read value</strong>的缩写。</li><li>左值是指<strong>存储在内存中、有明确存储地址(可取地址)的数据。</strong></li><li>右值是指<strong>可以提供数据值的数据(不可取地址)。</strong></li></ul><p>通过描述可以看出，区分左值与右值的便捷方法是：<strong>可以对表达式取地址(&amp;)就是左值，否则为右值。</strong></p><p>所有有名字的变量或者对象都是左值，而右值是匿名的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1314</span>;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><p>一般情况下，位于 = 前面的表达式为左值，位于 = 后边的表达式为右值。也就是说例子中的a,b为左值，520,1314为右值。a=b是一种特殊情况，在这个表达式中a，b都是左值，因为变量b是可以被取地址的，不能视为右值。</p><p>C++11中右值可以分为两种：一个是将亡值，另一个则是纯右值：</p><ul><li><strong>纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambada表达式等。</strong></li><li><strong>将亡值：与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值、std::move的返回值等。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">520</span>;</span><br></pre></td></tr></table></figure><p>上面语句中的value为左值，520为字面量也就是右值。其中value可以被引用，但是520就不行了，因为字面量都是右值。</p><h2 id="2、右值引用的使用"><a href="#2、右值引用的使用" class="headerlink" title="2、右值引用的使用"></a>2、右值引用的使用</h2><p>右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用它的方式找到它。<strong>无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又”重获新生”。</strong></p><p>其生命周期与右值引用类型变量的声明周期一样，只要该变量还活着，该右值临时量将会一直存活下去。</p><p>关于右值引用的使用，参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; value = <span class="number">520</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1;</span><br><span class="line">    <span class="type">int</span> &amp;&amp;a2 = a1;        <span class="comment">// error</span></span><br><span class="line">    Test&amp; t = <span class="built_in">getObj</span>();   <span class="comment">// error</span></span><br><span class="line">    Test &amp;&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="type">const</span> Test&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上面的例子中<strong>int &amp;&amp;value=520;</strong>里面的520为纯右值，<strong>value</strong>是字面量<strong>520</strong>这个右值的引用。</li><li>在<strong>int &amp;&amp;a2=a1</strong>中；<strong>a1</strong>虽然写在<strong>=</strong>的右边，但是它仍然是一个左值，使<strong>用左值初始化一个右值引用是不合法的。</strong></li><li><strong>Test &amp; t=getObj()</strong>这段代码语法是错误的，<strong>右值不能给普通的左值引用赋值。</strong></li><li><strong>Test &amp;&amp; t=getObj()</strong>中getObj()返回的<strong>临时对象称为将亡值，t是这个将亡值的右值引用。</strong></li><li><strong>const Test &amp; t=getObj()</strong>这段代码语法是正确的，<strong>常量左值引用是一个万能的引用类型，它可以接受左值、右值、常量左值和常量右值。</strong></li></ul><h2 id="3、性能优化"><a href="#3、性能优化" class="headerlink" title="3、性能优化"></a>3、性能优化</h2><p>在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能优化。</p><p>修改以下上面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_num: &quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208161702687.png" alt="image-20220816170224552"></p><p>通过输出结果我们可以看到调用Test t=getObj()的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到对象t，在getObj()函数中创建的对象虽然进行了内存申请操作，但是没有使用就释放掉了。如果能够使用临时对象已经申请的资源，既能节省资源，还能节省申请和释放的时间，如果要执行这样的操作就需要使用右值引用了。</p><p><strong>右值引用具有移动语义，移动语义可将资源(堆、系统对象等)通过浅拷贝从一个对象转义到另一个对象这样就能减少不必要的临时对象的创建、拷贝及销毁，可以大幅度提高C++应用程序的性能。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加移动构造函数</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">m_num</span>(a.m_num)</span><br><span class="line">    &#123;</span><br><span class="line">        a.m_num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct: my name is sunny&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test class ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_num: &quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码执行结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208161712211.png" alt="image-20220816171225155"></p><p>通过修改，在上面的代码给Test类添加了<strong>移动构造函数(参数为右值引用类型)，</strong>这样在进行Test t=getObj()操作时候并没有调用拷贝构造函数进行深拷贝，而是调用移动构造函数，这个函数中只是进行了浅拷贝，没有对临时对象进行深拷贝，提高性能。</p><p>如果不使用移动构造，在执行Test t=getObj()时候也是进行浅拷贝，但是临时对象被析构的时候，类成员指针int *m_num指向的内存也就被析构了，对象t也就无法访问这块内存地址了。</p><p>在测试程序中getObj()的返回值就是一个将亡值，也就是一个右值，在进行赋值操作的时候如果右边是一个右值，那么移动构造就会被调用。<strong>移动构造中使用了右值引用，会将临时对象的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。</strong></p><p><strong>注意：</strong></p><p><strong>对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数。</strong></p><h2 id="4、-amp-amp-的特性"><a href="#4、-amp-amp-的特性" class="headerlink" title="4、&amp;&amp;的特性"></a>4、&amp;&amp;的特性</h2><p>在 C++ 中，并不是所有情况下 <strong>&amp;&amp; 都代表是一个右值引用，</strong>具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为 T&amp;&amp;，如果是自动类型推导需要指定为 auto &amp;&amp;，在这两种场景下 &amp;&amp; 被称作未定的引用类型。另外还有一点需要额外注意 const T&amp;&amp; 表示一个右值引用，不是未定引用类型。</p><p>先看第一个例子，在函数模板中使用&amp;&amp;：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); </span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x); </span><br><span class="line"><span class="built_in">f1</span>(x);</span><br></pre></td></tr></table></figure><p>在上面的例子中函数模板进行了自动类型推导，需要通过传入的实参来确定参数param的实际类型。</p><ul><li>第4行中，对于f(10)来说传入的实参10是右值，因此T&amp;&amp;表示右值引用。</li><li>第6行中，对于f(x)来说传入的实参x是左值，因此T&amp;&amp;表示左值引用。</li><li>第7行中，f1(x)的参数是const T&amp;&amp;不是未定引用类型，不需要推导，本身就表示一个右值引用。</li></ul><p>再来看第二个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>, y = <span class="number">1314</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v1 = x;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v2 = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(x)&amp;&amp; v3 = y;   <span class="comment">// error</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;, v2: &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第4行中<strong>auto&amp;&amp;</strong>表示一个整形的左值引用。</li><li>第5行中<strong>auto&amp;&amp;</strong>表示一个整形的右值引用。</li><li>第6行中<strong>decltype(x)&amp;&amp;</strong>等价于<strong>int&amp;&amp;</strong>是一个右值引用不是未定义引用类型，y是一个左值，<strong>不能使用左值初始化一个右值引用类型。</strong></li></ul><p>由于上述代码存在T&amp;&amp;或者auto&amp;&amp;这种未定义引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，在进行类型推导时右值引用类型(&amp;&amp;)会发生变化，这种变化被称为引用折叠。在C++11中引用折叠规则如下：</p><ul><li><p><strong>通过右值推导T&amp;&amp;或者auto&amp;&amp;得到的是一个右值引用类型。</strong></p></li><li><p><strong>通过非右值(右值引用、左值、左值引用、常量右值引用、常量左值引用)推导T&amp;&amp;或者auto&amp;&amp;得到的是一个左值引用类型。</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; a1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb = a1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb1 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;a3 = a2;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc = a3;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc1 = a2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; s1 = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; s2 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; dd = s1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; ee = s2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li>第2行：a1为右值引用，推导出bb为左值引用类型。</li><li>第3行：5为右值，推导出的bb1为右值引用类型。</li><li>第7行：a3为左值引用，推导出的cc为左值引用。</li><li>第8行：a2为左值引用，推导出的cc1为左值引用。</li><li>第12行：s1为常量左值引用，推导出的dd为常量左值引用。</li><li>第13行：s2为常量右值引用，推导出的ee为常量右值引用。</li><li>第15行：x为右值引用，不需要推导，只能通过右值初始化。</li></ul><p>最后再看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;&amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">520</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(i);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">1314</span>);</span><br><span class="line">    forward(<span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208171011704.png" alt="image-20220817101112650"></p><p>根据测试代码可以得知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重置函数（printValue），函数 forward () 接收的是一个右值，但是在这个函数中调用函数 printValue () 时，参数 k 变成了一个命名对象，编译器会将其当做左值来处理。</p><p>最后总结以下关于&amp;&amp;的使用：</p><ul><li><strong>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</strong></li><li><strong>编译器会将已命名的右值视为左值，将未命名的右值视为右值。</strong></li><li><strong>auto&amp;&amp;或者参数类型自动类型推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型。</strong></li><li><strong>通过右值推导T&amp;&amp;或者auto&amp;&amp;得到的是一个右值引用类型，其余都是左值引用类型。</strong></li></ul><h2 id="5、std-move"><a href="#5、std-move" class="headerlink" title="5、std::move"></a>5、std::move</h2><p>在C++11中添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，<strong>使用std::move方法可以将左值转化为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样具有移动语义，将对象的状态或者所有权从一个对象移动到另一个对象上，只是转移，没有内存拷贝。</strong></p><p>从实现上讲，std::move基本等同于一个类型转换：<strong>static_cast<T&&>(lvalue)；</strong>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Ty&gt;</span></span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// forward _Arg as movable</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    Test &amp;&amp; v1 = t;          <span class="comment">// error</span></span><br><span class="line">    Test &amp;&amp; v2 = <span class="built_in">move</span>(t);    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第10行中，使用左值初始化右值引用，因此语法错误。</li><li>第11行中，使用move函数将左值转化为右值，这样就可以初始化右值引用了。</li></ul><p>假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; ls;</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">......</span><br><span class="line">list&lt;string&gt; ls1 = ls;        <span class="comment">// 需要拷贝, 效率低</span></span><br><span class="line">list&lt;string&gt; ls2 = <span class="built_in">move</span>(ls);</span><br></pre></td></tr></table></figure><p>如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权，如果一个对象内部有较大的堆内存或者动态数组时，使用move就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数<strong>(T::T(T&amp;&amp;another))</strong>和具有移动语义的赋值函数<strong>(T&amp;&amp;T::operator=(T&amp;&amp;rhs))</strong>，在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。</p><h2 id="6、std-forward"><a href="#6、std-forward" class="headerlink" title="6、std::forward"></a>6、std::forward</h2><p>右值引用类型是独立于值的，一个右值引用作为函数的形参时，在函数内部转发该参数给内部其他函数时，它就变成了一个左值，并不是原来的类型了。如果需要按照原来的类型转发到另一个函数，<strong>可以使用C++11提供的std::forward函数，该函数实现的功能称之为完美转发。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简之后的样子</span></span><br><span class="line">std::forward&lt;T&gt;(t);</span><br></pre></td></tr></table></figure><ul><li>当T为左值引用类型时，t将被转化为T类型的左值。</li><li>当T不是左值引用类型时，t将被转化为T类型的右值。</li></ul><p>下面通过一个例子演示一下关于forward的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">520</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1314</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(num);</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码的结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208171101969.png" alt="image-20220817110147910"></p>]]></content>
      
      
      <categories>
          
          <category> CPP11的学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"Sakura???","short_name":"Sakura","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/weibo.css"/>
      <url>/css/weibo.css</url>
      
        <content type="html"><![CDATA[/* #weibo-container{    width: 100%;     height: 150px;    font-size: 95%;  }    .weibo-new{    background:#ff3852  }  .weibo-hot{    background:#ff9406  }  .weibo-jyzy{    background:#ffc000  }  .weibo-recommend{    background:#00b7ee  }  .weibo-adrecommend{    background:#febd22  }  .weibo-friend{    background:#8fc21e  }  .weibo-boom{    background:#bd0000  }  .weibo-topic{    background:#ff6f49  }  .weibo-topic-ad{    background:#4dadff  }  .weibo-boil{    background:#f86400  }  #weibo-container{    overflow-y:auto;    -ms-overflow-style:none;    scrollbar-width:none  }  #weibo-container::-webkit-scrollbar{    display:none  }  .weibo-list-item{    display:flex;    flex-direction:row;    justify-content:space-between;    flex-wrap:nowrap  }  .weibo-title{    white-space:nowrap;    overflow:hidden;    text-overflow:ellipsis;    margin-right:auto  }  .weibo-num{    float:right  }  .weibo-hotness{    display:inline-block;    padding:0 6px;    transform:scale(.8) translateX(-3px);    color:#fff;    border-radius:8px  } */]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* 鼠标图标 */  body {    cursor: url("/img/x1.cur"), auto;  }  a,  [type="button"]:not(:disabled),  [type="reset"]:not(:disabled),  [type="submit"]:not(:disabled),  button:not(:disabled) {    cursor: url("/img/x2.cur"), auto !important;  }  /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }      #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }  /* 归档样式 */span.card-archive-list-count {  width: auto;  text-align: left;  font-size: 1.5rem;  line-height: 0.9;  font-weight: 700;}.card-archive-list-count-group {  display: flex;  flex-direction: row;  align-items: baseline;}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a span:last-child,#aside-content .card-categories ul.card-category-list > .card-category-list-item a span:last-child {  width: fit-content;  margin-left: 4px;}span.card-archive-list-count {  width: auto;  text-align: left;  font-size: 1.1rem;  line-height: 0.9;  font-weight: 700;}.card-archive-list-date {  font-size: 14px;  opacity: 0.6;}li.card-archive-list-item {  width: 100%;  flex: 0 0 48%;}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:hover,#aside-content .card-categories ul.card-category-list > .card-category-list-item a:hover {  color: var(--anzhiyu-white);  background-color: var(--anzhiyu-theme);  box-shadow: var(--anzhiyu-shadow-theme);  border-radius: 8px;  padding-left: 0.5rem;  padding-right: 0.5rem;}@media screen and (min-width: 1300px) {  #aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:hover,  #aside-content .card-categories ul.card-category-list > .card-category-list-item a:hover {    transform: scale(1.03);  }  #aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:active,  #aside-content .card-categories ul.card-category-list > .card-category-list-item a:active {    transform: scale(0.97);  }}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a,#aside-content .card-categories ul.card-category-list > .card-category-list-item a {  border-radius: 8px;  margin: 4px 0;  display: flex;  flex-direction: column;  align-content: space-between;  border: var(--style-border);}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a span:first-child,#aside-content .card-categories ul.card-category-list > .card-category-list-item a span:first-child {  width: auto;  flex: inherit;}#aside-content .card-archives ul.card-archive-list,#aside-content .card-categories ul.card-category-list {  display: flex;  flex-direction: row;  justify-content: space-between;  flex-wrap: wrap;}/* tags样式 */#aside-content .card-tag-cloud a {  color: var(--anzhiyu-fontcolor) !important;  font-size: 1.05rem !important;  border-radius: 8px;  display: inline-block;  margin-right: 4px;}#aside-content .card-tag-cloud a:hover {  background: var(--anzhiyu-theme);  color: var(--anzhiyu-white) !important;  box-shadow: var(--anzhiyu-shadow-theme);}@media screen and (min-width: 1300px) {  #aside-content .card-tag-cloud a:hover {    transform: scale(1.03);  }  #aside-content .card-tag-cloud a:active {    transform: scale(0.97);  }}#aside-content .card-tag-cloud a sup {  opacity: 0.4;  margin-left: 2px;}/* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/coin/coin.js"/>
      <url>/js/coin/coin.js</url>
      
        <content type="html"><![CDATA[var tipButtons = document.querySelectorAll(".tip-button");function coinAudio() {  var coinAudio = document.getElementById("coinAudio");  if (coinAudio) {    coinAudio.play(); //有音频时播放  }}// Loop through all buttons (allows for multiple buttons on page)tipButtons.forEach(button => {  var coin = button.querySelector(".coin");  // The larger the number, the slower the animation  coin.maxMoveLoopCount = 90;  button.addEventListener("click", () => {    if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true; //媒体选择    if (button.clicked) return;    button.classList.add("clicked");    // Wait to start flipping th coin because of the button tilt animation    setTimeout(() => {      // Randomize the flipping speeds just for fun      coin.sideRotationCount = Math.floor(Math.random() * 5) * 90;      coin.maxFlipAngle = (Math.floor(Math.random() * 4) + 3) * Math.PI;      button.clicked = true;      flipCoin();      coinAudio();    }, 50);  });  var flipCoin = () => {    coin.moveLoopCount = 0;    flipCoinLoop();  };  var resetCoin = () => {    coin.style.setProperty("--coin-x-multiplier", 0);    coin.style.setProperty("--coin-scale-multiplier", 0);    coin.style.setProperty("--coin-rotation-multiplier", 0);    coin.style.setProperty("--shine-opacity-multiplier", 0.4);    coin.style.setProperty("--shine-bg-multiplier", "50%");    coin.style.setProperty("opacity", 1);    // Delay to give the reset animation some time before you can click again    setTimeout(() => {      button.clicked = false;    }, 300);  };  var flipCoinLoop = () => {    coin.moveLoopCount++;    var percentageCompleted = coin.moveLoopCount / coin.maxMoveLoopCount;    coin.angle = -coin.maxFlipAngle * Math.pow(percentageCompleted - 1, 2) + coin.maxFlipAngle;    // Calculate the scale and position of the coin moving through the air    coin.style.setProperty("--coin-y-multiplier", -11 * Math.pow(percentageCompleted * 2 - 1, 4) + 11);    coin.style.setProperty("--coin-x-multiplier", percentageCompleted);    coin.style.setProperty("--coin-scale-multiplier", percentageCompleted * 0.6);    coin.style.setProperty("--coin-rotation-multiplier", percentageCompleted * coin.sideRotationCount);    // Calculate the scale and position values for the different coin faces    // The math uses sin/cos wave functions to similate the circular motion of 3D spin    coin.style.setProperty("--front-scale-multiplier", Math.max(Math.cos(coin.angle), 0));    coin.style.setProperty("--front-y-multiplier", Math.sin(coin.angle));    coin.style.setProperty("--middle-scale-multiplier", Math.abs(Math.cos(coin.angle), 0));    coin.style.setProperty("--middle-y-multiplier", Math.cos((coin.angle + Math.PI / 2) % Math.PI));    coin.style.setProperty("--back-scale-multiplier", Math.max(Math.cos(coin.angle - Math.PI), 0));    coin.style.setProperty("--back-y-multiplier", Math.sin(coin.angle - Math.PI));    coin.style.setProperty("--shine-opacity-multiplier", 4 * Math.sin((coin.angle + Math.PI / 2) % Math.PI) - 3.2);    coin.style.setProperty("--shine-bg-multiplier", -40 * (Math.cos((coin.angle + Math.PI / 2) % Math.PI) - 0.5) + "%");    // Repeat animation loop    if (coin.moveLoopCount < coin.maxMoveLoopCount) {      if (coin.moveLoopCount === coin.maxMoveLoopCount - 6) button.classList.add("shrink-landing");      window.requestAnimationFrame(flipCoinLoop);    } else {      button.classList.add("coin-landed");      coin.style.setProperty("opacity", 0);      setTimeout(() => {        button.classList.remove("clicked", "shrink-landing", "coin-landed");        setTimeout(() => {          resetCoin();        }, 300);      }, 1500);    }  };});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/coin/coin.css"/>
      <url>/css/coin/coin.css</url>
      
        <content type="html"><![CDATA[.tip-button {    border: 0;    border-radius: 0.25rem;    cursor: pointer;    font-size: 20px;    font-weight: 600;    height: 2.6rem;    margin-bottom: -4rem;    outline: 0;    position: relative;    top: 0;    transform-origin: 0% 100%;    transition: transform 50ms ease-in-out;    width: auto;    -webkit-tap-highlight-color: transparent;  }  .tip-button:active {    transform: rotate(4deg);  }  .tip-button.clicked {    animation: 150ms ease-in-out 1 shake;    pointer-events: none;  }  .tip-button.clicked .tip-button__text {    opacity: 0;    transition: opacity 100ms linear 200ms;  }  .tip-button.clicked::before {    height: 0.5rem;    width: 60%;    background: $button-hover-color;  }  .tip-button.clicked .coin {    transition: margin-bottom 1s linear 200ms;    margin-bottom: 0;  }  .tip-button.shrink-landing::before {    transition: width 200ms ease-in;    width: 0;  }  .tip-button.coin-landed::after {    opacity: 1;    transform: scale(1);    transform-origin: 50% 100%;  }  .tip-button.coin-landed .coin-wrapper {    background: radial-gradient(circle at 35% 97%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient(        circle at 45% 92%,        rgba(3, 16, 50, 0.4) 0.04rem,        transparent 0.02rem      ), radial-gradient(circle at 55% 98%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient(circle at          65% 96%, rgba(3, 16, 50, 0.4) 0.06rem, transparent 0.06rem);    background-position: center bottom;    background-size: 100%;    bottom: -1rem;    opacity: 0;    transform: scale(2) translateY(-10px);  }  .tip-button__text {    color: #fff;    margin-right: 1.8rem;    opacity: 1;    position: relative;    transition: opacity 100ms linear 500ms;    z-index: 3;  }  .tip-button::before {    border-radius: 0.25rem;    bottom: 0;    content: "";    display: block;    height: 100%;    left: 50%;    position: absolute;    transform: translateX(-50%);    transition: height 250ms ease-in-out 400ms, width 250ms ease-in-out 300ms;    width: 100%;    z-index: 2;  }  .tip-button::after {    bottom: -1rem;    color: white;    content: "ヾ(≧O≦)〃嗷~"; /*点击后显示的内容*/    height: 110%;    left: 0;    opacity: 0;    position: absolute;    pointer-events: none;    text-align: center;    transform: scale(0);    transform-origin: 50% 20%;    transition: transform 200ms cubic-bezier(0, 0, 0.35, 1.43);    width: 100%;    z-index: 1;  }    .coin-wrapper {    background: none;    bottom: 0;    height: 18rem;    left: 0;    opacity: 1;    overflow: hidden;    pointer-events: none;    position: absolute;    transform: none;    transform-origin: 50% 100%;    transition: opacity 200ms linear 100ms, transform 300ms ease-out;    width: 100%;  }    .coin {    --front-y-multiplier: 0;    --back-y-multiplier: 0;    --coin-y-multiplier: 0;    --coin-x-multiplier: 0;    --coin-scale-multiplier: 0;    --coin-rotation-multiplier: 0;    --shine-opacity-multiplier: 0.4;    --shine-bg-multiplier: 50%;    bottom: calc(var(--coin-y-multiplier) * 1rem - 3.5rem);    height: 3.5rem;    margin-bottom: 3.05rem;    position: absolute;    right: calc(var(--coin-x-multiplier) * 34% + 16%);    transform: translateX(50%) scale(calc(0.4 + var(--coin-scale-multiplier))) rotate(calc(var(              --coin-rotation-multiplier            ) * -1deg));    transition: opacity 100ms linear 200ms;    width: 3.5rem;    z-index: 3;  }  .coin__front,  .coin__middle,  .coin__back,  .coin::before,  .coin__front::after,  .coin__back::after {    border-radius: 50%;    box-sizing: border-box;    height: 100%;    left: 0;    position: absolute;    width: 100%;    z-index: 3;  }  .coin__front {    background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%),      linear-gradient(210deg, #8590b3 32%, transparent 32%), linear-gradient(150deg, #8590b3 32%, transparent 32%),      linear-gradient(to right, #8590b3 22%, transparent 22%, transparent 78%, #8590b3 78%), linear-gradient(        to bottom,        #fcfaf9 44%,        transparent 44%,        transparent 65%,        #fcfaf9 65%,        #fcfaf9 71%,        #8590b3 71%      ), linear-gradient(to right, transparent 28%, #fcfaf9 28%, #fcfaf9 34%, #8590b3 34%, #8590b3 40%, #fcfaf9 40%, #fcfaf9          47%, #8590b3 47%, #8590b3 53%, #fcfaf9 53%, #fcfaf9 60%, #8590b3 60%, #8590b3 66%, #fcfaf9 66%, #fcfaf9 72%, transparent          72%);    background-color: #8590b3;    background-size: 100% 100%;    transform: translateY(calc(var(--front-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--front-scale-multiplier));  }  .coin__front::after {    background: rgba(0, 0, 0, 0.2);    content: "";    opacity: var(--front-y-multiplier);  }  .coin__middle {    background: #737c99;    transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--middle-scale-multiplier));  }  .coin__back {    background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%),      radial-gradient(circle at 50% 40%, #fcfaf9 23%, transparent 23%), radial-gradient(circle at 50% 100%, #fcfaf9 35%, transparent          35%);    background-color: #8590b3;    background-size: 100% 100%;    transform: translateY(calc(var(--back-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--back-scale-multiplier));  }  .coin__back::after {    background: rgba(0, 0, 0, 0.2);    content: "";    opacity: var(--back-y-multiplier);  }  .coin::before {    background: radial-gradient(circle at 25% 65%, transparent 50%, rgba(255, 255, 255, 0.9) 90%), linear-gradient(55deg, transparent          calc(var(--shine-bg-multiplier) + 0%), #e9f4ff calc(var(--shine-bg-multiplier) + 0%), transparent calc(var(                --shine-bg-multiplier              ) + 50%));    content: "";    opacity: var(--shine-opacity-multiplier);    transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / -2)) scaleY(var(--middle-scale-multiplier))      rotate(calc(var(--coin-rotation-multiplier) * 1deg));    z-index: 10;  }  .coin::after {    background: #737c99;    content: "";    height: 0.3181818182rem;    left: 0;    position: absolute;    top: 50%;    transform: translateY(-50%);    width: 100%;    z-index: 2;  }    @keyframes shake {    0% {      transform: rotate(4deg);    }    66% {      transform: rotate(-4deg);    }    100% {      transform: rotate();    }  }]]></content>
      
    </entry>
    
    
  
</search>
