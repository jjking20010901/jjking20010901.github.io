<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakura的博客</title>
  
  <subtitle>乐观和热爱才是生活的解药</subtitle>
  <link href="https://jjking20010901.github.io/atom.xml" rel="self"/>
  
  <link href="https://jjking20010901.github.io/"/>
  <updated>2022-11-11T06:46:26.904Z</updated>
  <id>https://jjking20010901.github.io/</id>
  
  <author>
    <name>Sakura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPP面试题目02</title>
    <link href="https://jjking20010901.github.io/posts/2b7ca3bb.html"/>
    <id>https://jjking20010901.github.io/posts/2b7ca3bb.html</id>
    <published>2022-11-11T06:45:08.000Z</published>
    <updated>2022-11-11T06:46:26.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、C-的虚函数实现机制"><a href="#1、C-的虚函数实现机制" class="headerlink" title="1、C++的虚函数实现机制"></a>1、C++的虚函数实现机制</h2><p>虚函数是实现多态/接口函数的基础。利用虚表实现。C++对象的内存布局，对象的前8位（64位系统）为虚表指针（vtpr），指向对象所对应的虚表。虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。</p><h2 id="2、C-的智能指针相关实现"><a href="#2、C-的智能指针相关实现" class="headerlink" title="2、C++的智能指针相关实现"></a>2、C++的智能指针相关实现</h2><p>C++11为C++标准库带来了三个智能指针，分别是shared_ptr，unique_ptr，weak_ptr。</p><p>C++智能指针的实现原理为引用计数。引用计数无法处理循环引用的情况。</p><p>shared_ptr实现原理是同一个内存空间每多一个指针指向就计数加1，如果计数变为0就释放内存空间。当用普通指针初始化的时候，只能使用一次普通指针。它还可以自定义释放函数。</p><p>unique_ptr是计数只能为1，没有拷贝构造函数。</p><p>weak_ptr只能指向该内存空间而没有所有权。主要用于辅助第一个指针，防止出现互锁。借助weak_ptr类型指针， 我们可以获取weak_ptr指针的一些状态信息，比如有多少指向相同的shared_ptr指针、shared_ptr指针指向的堆内存是否已经被释放等等。在构建weak_ptr指针对象时，可经常利用已有的shared_ptr指针为其初始化。</p><h2 id="3、互斥锁、可重入锁、读写锁与自旋锁"><a href="#3、互斥锁、可重入锁、读写锁与自旋锁" class="headerlink" title="3、互斥锁、可重入锁、读写锁与自旋锁"></a>3、互斥锁、可重入锁、读写锁与自旋锁</h2><p>mutex(互斥量)是睡眠等待类型的锁，当线程抢互斥锁失败的时候，线程会陷入休眠。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。</p><p>依据同一线程是否能多次加锁，把互斥量又分为如下两类：</p><ul><li>是：递归互斥量recursive mutex，也称<strong>可重入锁</strong>，reentrant lock。</li><li>否：非递归互斥量non-recursive mutex，也称<strong>不可重入锁</strong>，non-reentrant mutex。</li></ul><p>read-write lock读写锁，又称”共享-独占锁”，对于临界区区分读和写，读共享，写独占。</p><p>读写锁的特性：</p><ul><li>当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会<strong>阻塞</strong>。</li><li>当读写锁被加了读锁时，其他线程对该锁加写锁会<strong>阻塞</strong>，加读锁会成功。</li></ul><p>spinlock(自旋锁)<strong>自旋，更通俗的一个词时“忙等待”（busy waiting）。最通俗的一个理解，其实就是死循环。</strong></p><p>自旋锁不会引起线程休眠。当共享资源的状态不满足时，自旋锁会不停地<strong>循环检测状态</strong>(循环检测状态利用了CPU提供的原语Compare&amp;Exchange来保证原子性)。因为不会陷入休眠，而是忙等待的方式也就不需要条件变量。不休眠就不会引起上下文切换，但是会比较浪费CPU。</p><h2 id="4、定义和声明的区别"><a href="#4、定义和声明的区别" class="headerlink" title="4、定义和声明的区别"></a>4、定义和声明的区别</h2><p>声明是告诉编译器变量的类型和名字，不会为变量分配空间。定义需要分配空间，同一个变量可以被声明多次，但是只能被定义一次。</p><h2 id="5、C-文件编译与执行的四个阶段"><a href="#5、C-文件编译与执行的四个阶段" class="headerlink" title="5、C++文件编译与执行的四个阶段"></a>5、C++文件编译与执行的四个阶段</h2><p>1）预处理：根据文件中的预处理指令来修改源文件的内容</p><p>2）编译：编译成汇编代码</p><p>3）汇编：把汇编代码翻译成目标机器指令</p><p>4）链接：链接目标代码生成可执行程序</p><h2 id="6、STL中的vector的实现，是怎么扩容的？"><a href="#6、STL中的vector的实现，是怎么扩容的？" class="headerlink" title="6、STL中的vector的实现，是怎么扩容的？"></a>6、STL中的vector的实现，是怎么扩容的？</h2><p>vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。vector就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。当删除的时候空间并不会被释放，只是清空了里面的数据。对比array是静态空间一旦配置了就不能改变大小。vector的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在VS下是1.5倍扩容，在GCC下是2倍扩容。</p><h2 id="7、STL中的unordered-map和map的区别"><a href="#7、STL中的unordered-map和map的区别" class="headerlink" title="7、STL中的unordered_map和map的区别"></a>7、STL中的unordered_map和map的区别</h2><p>map是STL中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在map内部所有的数据都是有序的，且map的查询、插入、删除操作的时间复杂度都是O(logN)。</p><p>unordered_map和map类似，都是存储key-value对，可以通过key快速索引到value，不同的是unordered_map不会根据key进行排序。unordered_map底层是一个防冗余的哈希表，存储时根据key的hash值判断元素是否相同，即unoredered_map内部是无序的。</p><h2 id="8、引用能否实现动态绑定，为什么引用可以实现"><a href="#8、引用能否实现动态绑定，为什么引用可以实现" class="headerlink" title="8、引用能否实现动态绑定，为什么引用可以实现"></a>8、引用能否实现动态绑定，为什么引用可以实现</h2><p>可以。因为引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。</p><h2 id="9、深拷贝和浅拷贝的区别"><a href="#9、深拷贝和浅拷贝的区别" class="headerlink" title="9、深拷贝和浅拷贝的区别"></a>9、深拷贝和浅拷贝的区别</h2><p>深拷贝和浅拷贝可以简单的理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。</p><h2 id="10、extern“C”作用"><a href="#10、extern“C”作用" class="headerlink" title="10、extern“C”作用"></a>10、extern“C”作用</h2><p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。</p><h2 id="11、纯虚函数"><a href="#11、纯虚函数" class="headerlink" title="11、纯虚函数"></a>11、纯虚函数</h2><p>纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承，包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象。</p><h2 id="12、什么是野指针"><a href="#12、什么是野指针" class="headerlink" title="12、什么是野指针"></a>12、什么是野指针</h2><p>野指针不是NULL指针，是未初始化或者未清零的指针，它指向的内存地址不是程序员所期望的，可能指向了受限的内存。</p><p>成因：</p><p>1）指针变量没有被初始化</p><p>2）指针指向的内存被释放了，但是指针没有置NULL</p><p>3）指针超过了变量了的作用范围，比如b[10]，指针b+11</p><h2 id="13、线程安全和线程不安全"><a href="#13、线程安全和线程不安全" class="headerlink" title="13、线程安全和线程不安全"></a>13、线程安全和线程不安全</h2><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可以使用，不会出现数据不一致或者数据污染。</p><p>线程不安全就是不提供数据访问保护，有可能多个线程先后更改数据所得到的数据就是脏数据。</p><h2 id="14、const-charp和char-const-p的区别"><a href="#14、const-charp和char-const-p的区别" class="headerlink" title="14、const charp和char  const p的区别"></a>14、const char<em>p和char </em> const p的区别</h2><p>如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br>如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。</p><h2 id="15、如何定义和实现一个类的成员函数为回调函数"><a href="#15、如何定义和实现一个类的成员函数为回调函数" class="headerlink" title="15、如何定义和实现一个类的成员函数为回调函数"></a>15、如何定义和实现一个类的成员函数为回调函数</h2><p>所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在，以后，当某个事件发生时，再调用这个函数对事件进行响应。<br>定义一个类的成员函数时在该函数前加CALLBACK即将其定义为回调函数，函数的实现和普通成员函数没有区别。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、C-的虚函数实现机制&quot;&gt;&lt;a href=&quot;#1、C-的虚函数实现机制&quot; class=&quot;headerlink&quot; title=&quot;1、C++的虚函数实现机制&quot;&gt;&lt;/a&gt;1、C++的虚函数实现机制&lt;/h2&gt;&lt;p&gt;虚函数是实现多态/接口函数的基础。利用虚表实现。C++对</summary>
      
    
    
    
    <category term="CPP面试题目" scheme="https://jjking20010901.github.io/categories/CPP%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
    <category term="面试题目" scheme="https://jjking20010901.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>模型与视图</title>
    <link href="https://jjking20010901.github.io/posts/546960bf.html"/>
    <id>https://jjking20010901.github.io/posts/546960bf.html</id>
    <published>2022-11-09T10:59:53.000Z</published>
    <updated>2022-11-09T11:01:26.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、模型视图设计模式核心思想"><a href="#1、模型视图设计模式核心思想" class="headerlink" title="1、模型视图设计模式核心思想"></a>1、模型视图设计模式核心思想</h2><ul><li>使模型(数据)与视图(显示)相分离。</li><li>模型只需要对外提供标准接口存取数据，无需数据如何显示。</li><li>视图只需要自定义数据显示方式，无需数据如何组织存储。</li><li>当数据发生改变时，会通过信号通知视图。</li><li>当用户与视图进行交互时，会通过信号向模型发送交互信息。</li></ul><p>在QT中提供了以下几种定义模型：</p><p><strong>QStringListModel：存储一个字符串列表。</strong></p><p><strong>QStandardItemModel：存储任意分层次的数据。</strong></p><p><strong>QDirModel：封装本地文件系统。</strong></p><p><strong>QSqlQueryModel：封装一个SQL结果集。</strong></p><p><strong>QSqlTableModel：封装一个SQL表。</strong></p><p><strong>QSqlRelationTableModel：利用外键封装一个SQL表。</strong></p><p><strong>QSortFilterProxyModel：排序和/或筛选另一个模型。</strong></p><p>其中QAbstractItemModel的常见子集有：</p><ul><li><strong>QAbstractListModel：用来创建一维列表模型。</strong></li><li><strong>QStandardItemModel：用来存储定制数据的通用模型。</strong></li><li><strong>QAbstractTableModel：用来创建二维列表模型。</strong></li></ul><p>不同的model对应着不同的view，比如我们想要显示该QAbstractTableModel模型数据，则需要使用QTableView视图。</p><h2 id="2、QAbstractIemView-视图基类"><a href="#2、QAbstractIemView-视图基类" class="headerlink" title="2、QAbstractIemView-视图基类"></a>2、QAbstractIemView-视图基类</h2><p>QAbstractIemView它的子类有：QColumnView，QHeaderView，QListView，QTableView，QTreeView。</p><p>接下来以QTreeView视图为例，设置模型视图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line"></span><br><span class="line"><span class="function">QFileSystemModel  <span class="title">model</span><span class="params">(&amp;w)</span></span>;              <span class="comment">//定义文件系统模型</span></span><br><span class="line"></span><br><span class="line"><span class="function">QTreeView   <span class="title">treeView</span><span class="params">(&amp;w)</span></span>;                 <span class="comment">//定义树形显示视图</span></span><br><span class="line"></span><br><span class="line">treeView.<span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">setRootPath</span>(QDir::<span class="built_in">currentPath</span>()); <span class="comment">//设置根目录</span></span><br><span class="line"></span><br><span class="line">treeView.<span class="built_in">setModel</span>(&amp;model);          <span class="comment">//连接模型与视图</span></span><br><span class="line"></span><br><span class="line">treeView.<span class="built_in">setRootIndex</span>(model.<span class="built_in">index</span>(QDir::<span class="built_in">currentPath</span>()));</span><br><span class="line"><span class="comment">// setRootInedex():设置树形显示视图的数据索引,以当前目录为根部显示</span></span><br><span class="line"><span class="comment">// QModelIndex index(QDir::currentPath()):以当前目录为模型项索引</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><p>其中index()是个重载函数，用来获取QModelIndex索引值，完整的index()函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QModelIndex <span class="title">QAbstractItemModel::index</span> <span class="params">( <span class="type">int</span> row, <span class="type">int</span> column, <span class="type">const</span> QModelIndex &amp; parent = QModelIndex() )</span></span>;</span><br><span class="line">       <span class="comment">//返回指定的row(行)、column(列)、parent(父索引)引所在的索引值</span></span><br></pre></td></tr></table></figure><p>也可通过index索引值来查找数据，以QFileSystemModel模型为例，与index相关的成员函数有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QIcon     <span class="title">fileIcon</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span></span>;    <span class="comment">//通过索引值获取文件图标</span></span><br><span class="line"><span class="function">QFileInfo <span class="title">fileInfo</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span></span>;    <span class="comment">//通过索引值获取文件信息</span></span><br><span class="line"><span class="function">QString   <span class="title">fileName</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span> </span>;   <span class="comment">//通过索引值获取文件名</span></span><br><span class="line"><span class="function">QString   <span class="title">filePath</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span> </span>;  <span class="comment">//通过索引值获取文件路径</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDir</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span> </span>;          <span class="comment">//通过索引值,判断是否是目录</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">columnCount</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; parent = QModelIndex() )</span> </span>; </span><br><span class="line"><span class="comment">//通过索引值获取当前列数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">rowCount</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; parent = QModelIndex() )</span> </span>; <span class="comment">//通过索引值获取行数</span></span><br><span class="line"> </span><br><span class="line"><span class="function">QModelIndex <span class="title">parent</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span> </span>; <span class="comment">//通过索引值获取其父节点的索引值</span></span><br><span class="line"> </span><br><span class="line"><span class="function">QVariant  <span class="title">data</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index, <span class="type">int</span> role = Qt::DisplayRole )</span> </span>;</span><br><span class="line">                                                 <span class="comment">//通过索引值获取模型数据</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">setData</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; idx, <span class="type">const</span> QVariant &amp; value, <span class="type">int</span> role = Qt::EditRole )</span></span>;</span><br><span class="line">                                           <span class="comment">//通过索引值设置模型数据</span></span><br></pre></td></tr></table></figure><p>其中data()和setData()函数的参数role是模型数据角色。</p><h2 id="3、role数据角色"><a href="#3、role数据角色" class="headerlink" title="3、role数据角色"></a>3、role数据角色</h2><p>当role值不同时，则显示在视图上的方式也会不同。</p><p>对于role角色，常用的值有：</p><ul><li>Qt::DisplayRole             0          以文本方式显示数据(QString)</li><li>Qt::DecorationRole       1         将数据作为图标来装饰(QIcon,QPixmap)</li><li>Qt::EditRole                   2          可编辑的数据信息显示(QString)</li><li>Qt::ToolTipRole             3          作为工具提示显示(QString)</li><li>Qt::StatusTipRole          4         作为状态栏中显示的数据(QString)</li><li>Qt::WhatsThisRole        5         作为帮助信息栏中显示的数据(QString)</li><li>Qt::FontRole                   6        设置字体(QFont)</li><li>Qt::TextAlignmentRole   7       设置模型数据的文本对齐(Qt::AlignmentFlag)</li><li>Qt::BackgroundRole      8        设置模型数据的背景色(QBrush)</li><li>Qt::ForegroundRole      9         设置模型数据的前景色,比如字体(QBrush)</li></ul><p>以QTableView为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line"><span class="function">QTableView <span class="title">view</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line"><span class="function">QStandardItemModel  <span class="title">model</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">view.<span class="built_in">setModel</span>(&amp;model);          <span class="comment">//设置视图的模型</span></span><br><span class="line"></span><br><span class="line">QStandardItem itemA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置text*/</span></span><br><span class="line">itemA.<span class="built_in">setData</span>(<span class="string">&quot;A&quot;</span>,Qt::DisplayRole);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置图标*/</span></span><br><span class="line"><span class="function">QPixmap <span class="title">pix</span><span class="params">(<span class="string">&quot;:user.png&quot;</span>)</span></span>;</span><br><span class="line">pix = pix.<span class="built_in">scaled</span>(<span class="number">24</span>,<span class="number">24</span>,Qt::KeepAspectRatio);</span><br><span class="line">itemA.<span class="built_in">setData</span>(pix,Qt::DecorationRole);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置渐变背景色*/</span></span><br><span class="line"><span class="function">QLinearGradient  <span class="title">back</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">back.<span class="built_in">setColorAt</span>(<span class="number">0</span>,Qt::white);</span><br><span class="line">back.<span class="built_in">setColorAt</span>(<span class="number">0.5</span>,Qt::green);</span><br><span class="line">back.<span class="built_in">setColorAt</span>(<span class="number">1</span>,Qt::blue);</span><br><span class="line">itemA.<span class="built_in">setData</span>(<span class="built_in">QBrush</span>(back),Qt::BackgroundRole);</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">0</span>,&amp;itemA);</span><br><span class="line">model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QIcon</span>(pix),<span class="string">&quot;B&quot;</span>));</span><br><span class="line">model.<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QIcon</span>(pix),<span class="string">&quot;C&quot;</span>));</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、模型视图设计模式核心思想&quot;&gt;&lt;a href=&quot;#1、模型视图设计模式核心思想&quot; class=&quot;headerlink&quot; title=&quot;1、模型视图设计模式核心思想&quot;&gt;&lt;/a&gt;1、模型视图设计模式核心思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使模型(数据)与视图(显示)相分</summary>
      
    
    
    
    <category term="QtWidget" scheme="https://jjking20010901.github.io/categories/QtWidget/"/>
    
    
    <category term="模型与视图" scheme="https://jjking20010901.github.io/tags/%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>QTabelView函数的使用</title>
    <link href="https://jjking20010901.github.io/posts/615115d7.html"/>
    <id>https://jjking20010901.github.io/posts/615115d7.html</id>
    <published>2022-11-09T02:48:26.000Z</published>
    <updated>2022-11-09T03:05:01.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、view和model常用函数"><a href="#1、view和model常用函数" class="headerlink" title="1、view和model常用函数"></a>1、view和model常用函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTableView <span class="title">view</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置表头水平标题*/</span></span><br><span class="line">model.<span class="built_in">setHorizontalHeaderItem</span>(<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line">model.<span class="built_in">setHorizontalHeaderItem</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Sex&quot;</span>));</span><br><span class="line">model.<span class="built_in">setHorizontalHeaderItem</span>(<span class="number">2</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Age&quot;</span>));</span><br><span class="line">model.<span class="built_in">horizontalHeaderItem</span>(<span class="number">0</span>)-&gt;<span class="built_in">setFont</span>(<span class="built_in">QFont</span>(<span class="string">&quot;Helvetica&quot;</span>,<span class="number">20</span>,<span class="number">50</span>));   <span class="comment">//设置标题字体</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置表头垂直标题*/</span></span><br><span class="line">model.<span class="built_in">setVerticalHeaderItem</span>(<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;No.1&quot;</span>));</span><br><span class="line">model.<span class="built_in">setVerticalHeaderItem</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;No.2&quot;</span>));</span><br><span class="line">model.<span class="built_in">setVerticalHeaderItem</span>(<span class="number">2</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;No.3&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置列表条目数据*/</span></span><br><span class="line"><span class="function">QPixmap  <span class="title">pix</span><span class="params">(<span class="string">&quot;:user.png&quot;</span>)</span></span>;</span><br><span class="line">pix = pix.<span class="built_in">scaled</span>(<span class="number">24</span>,<span class="number">24</span>,Qt::KeepAspectRatio);</span><br><span class="line">QStandardItem *itemA=<span class="keyword">new</span> <span class="built_in">QStandardItem</span>();</span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(pix,Qt::DecorationRole);                        <span class="comment">//设置条目图标</span></span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(<span class="string">&quot;A&quot;</span>,Qt::DisplayRole);</span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(<span class="string">&quot;A:tooltip&quot;</span>,Qt::ToolTipRole);</span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(<span class="built_in">QFont</span>(<span class="string">&quot;宋体&quot;</span>,<span class="number">12</span>,QFont::Bold,<span class="literal">true</span>),Qt::FontRole); <span class="comment">//设置条目字体</span></span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(Qt::AlignCenter,Qt::TextAlignmentRole);         <span class="comment">//设置条目中心对齐</span></span><br><span class="line"><span class="comment">//可以实现按数值排序,否则的话&quot;2&quot;&gt;&quot;123&quot;itemA-&gt;setData(Qt::DisplayRole, 2); </span></span><br><span class="line"> <span class="function">QLinearGradient <span class="title">linearGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"> linearGradient.<span class="built_in">setColorAt</span>(<span class="number">0.2</span>, Qt::white);</span><br><span class="line"> linearGradient.<span class="built_in">setColorAt</span>(<span class="number">0.6</span>, Qt::green);</span><br><span class="line"> linearGradient.<span class="built_in">setColorAt</span>(<span class="number">1.0</span>, Qt::black);</span><br><span class="line"> itemA-&gt;<span class="built_in">setData</span>(<span class="built_in">QBrush</span>(linearGradient),Qt::BackgroundRole);    <span class="comment">//设置条目背景色(为渐变色)</span></span><br><span class="line"> </span><br><span class="line">   model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">0</span>,itemA);</span><br><span class="line">   model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">   model.<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;C&quot;</span>));  </span><br><span class="line">   model.<span class="built_in">item</span>(<span class="number">0</span>,<span class="number">1</span>)-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignCenter);  <span class="comment">//设置条目居中对齐</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*将数据模型的第一列进行下降排序(从大到小,不会进行整行排序)*/</span></span><br><span class="line">model.<span class="built_in">sort</span>(<span class="number">0</span>,Qt::DescendingOrder);</span><br><span class="line"><span class="comment">/*根据视图里的第一列数据,进行整行大小排序*/</span> </span><br><span class="line"> view.<span class="built_in">sortByColumn</span>(<span class="number">0</span>); </span><br><span class="line"><span class="comment">/*设置视图能够自动使能排序*/</span></span><br><span class="line">view.<span class="built_in">setSortingEnabled</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="comment">/*设置视图是否支持自动滑动*/</span> </span><br><span class="line">view.<span class="built_in">setAutoScroll</span>(<span class="type">bool</span> enable);　　  </span><br><span class="line"><span class="comment">/*设置选中一行后,标题的字体不会加粗*/</span></span><br><span class="line">view-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setHighlightSections</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="comment">/*设置列宽不可变动,在5.X后改为了setSectionResizeMode()*/</span></span><br><span class="line">view.<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setResizeMode</span>(QHeaderView::Fixed);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置行宽不可变动*/</span></span><br><span class="line">view.<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setResizeMode</span>(QHeaderView::Fixed); </span><br><span class="line"><span class="comment">/*设置用户选择模式, NoSelection表示不能选择表格*/</span> view.<span class="built_in">setSelectionMode</span>(QAbstractItemView::NoSelection);  </span><br><span class="line"><span class="comment">/*隐藏垂直标题*/</span> </span><br><span class="line">view.<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">hide</span>();  </span><br><span class="line"> </span><br><span class="line">view.<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection);                <span class="comment">//设置选择模式,表示只能选中单个  </span></span><br><span class="line">view.<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);                      <span class="comment">//设置选择行为,表示只能选择一行(也可以设置为列,或者单个Item项目) </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置表格不可编辑*/</span></span><br><span class="line">view.<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);</span><br><span class="line"><span class="comment">/*设置表头的显示与隐藏*/</span></span><br><span class="line">view.<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">view.<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*禁止显示网格线*/</span></span><br><span class="line">view.<span class="built_in">setShowGrid</span>(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*禁止显示滚动条*/</span></span><br><span class="line">view.<span class="built_in">setHorizontalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置行列的高宽*/</span></span><br><span class="line">view.<span class="built_in">setColumnWidth</span>(<span class="number">0</span>,<span class="number">50</span>);       <span class="comment">//设置column0(第1列)的宽度为50,必须要设置好model后,再来设置宽度　　</span></span><br><span class="line">view.<span class="built_in">setRowHeight</span>(<span class="number">0</span>,<span class="number">30</span>);          <span class="comment">//设置row0(第1行)的高度为30,必须setModel()后,再来设置高度</span></span><br><span class="line">view.<span class="built_in">resizeRowsToContents</span>();    <span class="comment">//更据当前内容自动调整行距</span></span><br><span class="line">view.<span class="built_in">resizeColumnsToContents</span>(); <span class="comment">//更据当前内容自动调整列距 /*禁止焦点(取消QTableView选中后的虚线框)*/  view.setFocusPolicy(Qt::NoFocus); /*获取鼠标当前位于视图的哪个index位置*/qDebug()&lt;&lt;view.currentIndex().row();  //获取行号,如果为-1,表示无效qDebug()&lt;&lt;view.currentIndex().column();//获取列号,如果为-1,表示无效  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTableView::setSpan</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, <span class="type">int</span> rowSpanCount, <span class="type">int</span> columnSpanCount)</span></span>;</span><br><span class="line"><span class="comment">//合并单元格</span></span><br><span class="line"><span class="comment">//第一个参数：要改变的单元格行数</span></span><br><span class="line"><span class="comment">//第二个参数：要改变的单元格列数</span></span><br><span class="line"><span class="comment">//第三个参数：需要合并的行数</span></span><br><span class="line"><span class="comment">//第四个参数：需要合并的列数</span></span><br><span class="line"><span class="comment">//比如: setSpan(0,0,2,3);   表示从table(0,0)开始到2,3结束,合并共2行和3列  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setVerticalScrollMode</span><span class="params">(QAbstractItemView::ScrollMode mode)</span></span>;<span class="comment">//设置滑动模式.可以设置按行滑动,还是按像素点来滑动</span></span><br></pre></td></tr></table></figure><h2 id="2、合并单元格的提醒"><a href="#2、合并单元格的提醒" class="headerlink" title="2、合并单元格的提醒"></a>2、合并单元格的提醒</h2><p>数据更新后，还要继续使用setSpan再次合并(主要是要对全表格进行重新的单元格合并，已经合并过的地方行列又要重新进行新的合并，因为数据已经更新)，这时不能直接使用setSpan，而是要先把QTableView的row还原为原来没有合并行列的情形，再次使用setSpan。</p><p><strong>对于QStandardItem的setData()的成员函数的第二个参数role是模型数据角色。</strong></p><p><strong>当role值不同时，则显示在视图上的方式也会不同。对于role角色，常用值有</strong>：</p><ul><li>Qt::DisplayRole   0      以文本方式显示数据(QString)</li><li>Qt::DecorationRole    1   将数据作为图标来装饰(QIcon,QPixmap)</li><li>Qt::EditRole    2         可编辑的数据信息显示(QString)</li><li>Qt::ToolTipRole   3     作为工具提示显示(QString)</li><li>Qt::StatusTipRole  4     作为状态栏中显示的数据(QString)</li><li>Qt::WhatsThisRole 5       作为帮助信息栏中显示的数据(QString)</li><li>Qt::FontRole     6        设置字体(QFont)</li><li>Qt::TextAlignmentRole  7   设置模型数据的文本对齐(Qt::AlignmentFlag)</li><li>Qt::BackgroundRole   8   设置模型数据的背景色(QBrush)</li><li>Qt::ForegroundRole   9   设置模型数据的前景色,比如字体(QBrush)</li></ul><h2 id="3、实现右击菜单"><a href="#3、实现右击菜单" class="headerlink" title="3、实现右击菜单"></a>3、实现右击菜单</h2><p>当用户在QTableView视图里右击鼠标时，便会触发一个QEvent::ContextMenu类型的事件。所以通过事件过滤器来实现右击菜单的效果。</p><p>步骤：</p><ul><li><strong>定义菜单对象。</strong></li><li><strong>通过QMenu的addAction()函数来添加子项，并连接槽函数。</strong></li><li><strong>定义事件过滤器，判断是否是QTableView的QEvent::ContextMenu事件。</strong></li><li><strong>判断成功，则调用menu.exec(this-&gt;cursor.pos())，在当前鼠标光标位置打开菜单。</strong></li></ul><p>Widget.h的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QMenu&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">Widget</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_delete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    QTableView view;</span><br><span class="line">    QStandardItemModel model;</span><br><span class="line">    QMenu menu;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Widget.cpp代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent),</span><br><span class="line">      <span class="built_in">view</span>(<span class="keyword">this</span>),</span><br><span class="line">      <span class="built_in">model</span>(<span class="keyword">this</span>),</span><br><span class="line">      <span class="built_in">menu</span>(<span class="keyword">this</span>)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模型设置</span></span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;C++&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Python&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">2</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;C#&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Js&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">3</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;CSS&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">3</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;html&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*视图只能选中一行，取消焦点，禁止编辑*/</span></span><br><span class="line">    view.<span class="built_in">setFocusPolicy</span>(Qt::NoFocus);</span><br><span class="line">    view.<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);</span><br><span class="line">    view.<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection);</span><br><span class="line">    view.<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);</span><br><span class="line">    view.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安装过滤器</span></span><br><span class="line">    view.<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置菜单并绑定槽函数</span></span><br><span class="line">    menu.<span class="built_in">addAction</span>(<span class="string">&quot;删除&quot;</span>,<span class="keyword">this</span>,Widget::on_delete);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Widget::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(watched==&amp;view &amp;&amp; event-&gt;<span class="built_in">type</span>()==QEvent::ContextMenu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(view.<span class="built_in">currentIndex</span>().<span class="built_in">isValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在当前鼠标位置运行菜单</span></span><br><span class="line">            menu.<span class="built_in">exec</span>(<span class="keyword">this</span>-&gt;<span class="built_in">cursor</span>().<span class="built_in">pos</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(watched,event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据视图中索引行的的位置删除一行</span></span><br><span class="line">    model.<span class="built_in">removeRow</span>(view.<span class="built_in">currentIndex</span>().<span class="built_in">row</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、view和model常用函数&quot;&gt;&lt;a href=&quot;#1、view和model常用函数&quot; class=&quot;headerlink&quot; title=&quot;1、view和model常用函数&quot;&gt;&lt;/a&gt;1、view和model常用函数&lt;/h2&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="QtWidget" scheme="https://jjking20010901.github.io/categories/QtWidget/"/>
    
    
    <category term="view和model" scheme="https://jjking20010901.github.io/tags/view%E5%92%8Cmodel/"/>
    
  </entry>
  
  <entry>
    <title>chrono时间库</title>
    <link href="https://jjking20010901.github.io/posts/ae80a404.html"/>
    <id>https://jjking20010901.github.io/posts/ae80a404.html</id>
    <published>2022-11-08T11:35:37.000Z</published>
    <updated>2022-11-08T11:37:19.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、std-chrono标准时间库"><a href="#1、std-chrono标准时间库" class="headerlink" title="1、std::chrono标准时间库"></a>1、std::chrono标准时间库</h2><p>利用CPP强类型的特点，明确区分<strong>时间点和时间段</strong>，明确区分不同的<strong>时间单位</strong>。</p><ul><li>时间点例子：2022年11月8日12点:55分:10秒。</li><li>时间段例子：1分30秒。</li><li>时间点类型：chrono::steady_clock::time_point等。</li><li>时间段类型：chrono::millseconds，chrono::seconds，chrono::minutes等。</li><li>方便的运算符重载：时间点+时间段=时间点，时间点-时间点=时间段。</li></ul><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t0=chrono::steady_clock::<span class="built_in">now</span>();     <span class="comment">//获取当前时间点</span></span><br><span class="line"><span class="keyword">auto</span> t1=t0+chrono::<span class="built_in">seconds</span>(<span class="number">30</span>); <span class="comment">//当前时间点的30秒后</span></span><br><span class="line"><span class="keyword">auto</span> dt=t1-t0;  <span class="comment">//获取两个时间点的差(时间段)</span></span><br><span class="line"><span class="keyword">auto</span> sec=chrono::<span class="built_in">duration_cast</span>&lt;chrono::seconds&gt;(dt).<span class="built_in">count</span>(); <span class="comment">//时间差的秒数</span></span><br></pre></td></tr></table></figure><h2 id="2、案例：计算花费时间"><a href="#2、案例：计算花费时间" class="headerlink" title="2、案例：计算花费时间"></a>2、案例：计算花费时间</h2><p>在所执行的程序未执行时，先通过chrono::steady_clock::now()获取当前时间点，然后执行程序，再通过chrono::steady_clock::now()获取执行程序后的时间点，最后两个时间点相减得到程序所耗费时间段，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++);</span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">int</span> dt = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(endTime - startTime).<span class="built_in">count</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;run time: &quot;</span> &lt;&lt; dt &lt;&lt; <span class="string">&quot;ms&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202211081320809.png" alt="image-20221108132005750"></p><p>上面是执行时间段为整形，如下是输出double类型的时间段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++);</span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">using</span> double_ms = std::chrono::duration&lt;<span class="type">double</span>, std::milli&gt;;</span><br><span class="line"><span class="keyword">auto</span> dt = std::chrono::<span class="built_in">duration_cast</span>&lt;double_ms&gt;(endTime - startTime).<span class="built_in">count</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;run time: &quot;</span> &lt;&lt; dt &lt;&lt; <span class="string">&quot;ms&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：duration_cast可以在任意的duration类型之间转换，duration<T,R>表示用T类型表示，且时间单位用R。</strong></p><p><strong>R省略不写就代表秒，std::milli就是毫秒，std::micro就是微秒。seconds是duration<int64_t>的类型别名。</strong></p><p><strong>millseconds是duration&lt; int64_t,std::mill &gt;的类型别名。</strong></p><p><strong>这里我们创建了double_ms作为duration&lt; double,std::mill&gt;的别名。</strong></p><h2 id="3、跨平台sleep：this-thread-sleep-for"><a href="#3、跨平台sleep：this-thread-sleep-for" class="headerlink" title="3、跨平台sleep：this_thread::sleep_for"></a>3、跨平台sleep：this_thread::sleep_for</h2><p>可以使用std::this_thread::sleep_for代替Unix操作系统专有的usleep。它可以让当前线程休眠一段时间，然后继续运行，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的休眠单位可以自己指定，比如这里是millseconds表示毫秒，也可以换成microseconds表示微秒，seconds表示秒，chrono的强类型让单位选择更自由，而且chrono时间库的精度更准确。</strong></p><h2 id="4、睡到时间点：std-this-thread-sleep-until"><a href="#4、睡到时间点：std-this-thread-sleep-until" class="headerlink" title="4、睡到时间点：std::this_thread::sleep_until"></a>4、睡到时间点：std::this_thread::sleep_until</h2><p>除了接受一个时间段sleep_for，还有接受一个时间点的sleep_until，表示让当前线程休眠到某个时间点。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> t=std::chrono::steady_clock::<span class="built_in">now</span>()+std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_until</span>(t);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、std-chrono标准时间库&quot;&gt;&lt;a href=&quot;#1、std-chrono标准时间库&quot; class=&quot;headerlink&quot; title=&quot;1、std::chrono标准时间库&quot;&gt;&lt;/a&gt;1、std::chrono标准时间库&lt;/h2&gt;&lt;p&gt;利用CPP强类型</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="chrono时间库" scheme="https://jjking20010901.github.io/tags/chrono%E6%97%B6%E9%97%B4%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CPP面试题目01</title>
    <link href="https://jjking20010901.github.io/posts/b275f201.html"/>
    <id>https://jjking20010901.github.io/posts/b275f201.html</id>
    <published>2022-11-06T10:50:53.000Z</published>
    <updated>2022-11-06T12:14:30.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、C和CPP的区别"><a href="#1、C和CPP的区别" class="headerlink" title="1、C和CPP的区别"></a>1、C和CPP的区别</h2><p>1、C是面向过程的语言，是一个结构化的语言，而CPP是面向对象的语言，主要特征是封装、继承、多态。</p><p>2、C和C++动态管理内存的方法不一样，C是使用malloc/free，而CPP是new/delete、。</p><p>3、CPP中有引用，C不存在引用的概念。</p><h2 id="2、CPP中指针和引用的区别"><a href="#2、CPP中指针和引用的区别" class="headerlink" title="2、CPP中指针和引用的区别"></a>2、CPP中指针和引用的区别</h2><p>1、指针是一个新的变量，存储另一个变量的地址，我们可以通过访问这个地址来修改这个变量。引用只是一个别名，还是变量本身，对引用的任何操作就是对变量本身的操作，以达到修改变量的目的。</p><p>2、引用只有一级，而指针有多级。</p><p>3、指针传参时，还是值传递，指针本身的值不可修改，需要通过解引用才能对指向对象进行操作。引用传参时，传进来的就是变量本身，因此变量可以被修改。</p><h2 id="3、结构体struct和union-联合-的区别"><a href="#3、结构体struct和union-联合-的区别" class="headerlink" title="3、结构体struct和union(联合)的区别"></a>3、结构体struct和union(联合)的区别</h2><p>1、结构体：将不同类型的数据组合成一个整体，是自定义类型。共同体：不同类型的几个变量共同占用一段内存</p><p>2、结构体中的每个成员都有自己独立的地址，它们是同时存在的。共同体中的所有成员占用同一段内存，它们不能同时存在。</p><h2 id="4、-define和const的区别"><a href="#4、-define和const的区别" class="headerlink" title="4、#define和const的区别"></a>4、#define和const的区别</h2><p>1、#define定义的常量没有类型，所以给出的是一个立即数；const定义的常量有类型名字，存放在静态区域。</p><p>2、处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。</p><p>3、#define定义的常量是不可以用指针去指向的，const定义的常量可以用指针去指向该常量的地址。</p><p>4、#define可以定义简单的函数，const不可以定义函数。</p><h2 id="5、new、delete、malloc、free之间的关系"><a href="#5、new、delete、malloc、free之间的关系" class="headerlink" title="5、new、delete、malloc、free之间的关系"></a>5、new、delete、malloc、free之间的关系</h2><p>1、malloc对开辟的空间大小严格指定，而new只需要对象名。</p><p>2、new为对象分配空间时，调用类对象的构造函数，delete调用类对象的析构函数。</p><p>3、malloc/free是库函数，new/delete是CPP的运算符。</p><p>对于非内部数据类型而言，光用malloc/free无法满足动态类对象的要求。new/delete是运算符，编译器保证调用构造和析构函数对类对象进行初始化/析构。但是库函数malloc/free，不会执行构造/析构。</p><h2 id="6、delete和delete-的区别"><a href="#6、delete和delete-的区别" class="headerlink" title="6、delete和delete[]的区别"></a>6、delete和delete[]的区别</h2><p>1、delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数。</p><p>2、用new分配的内存用delete释放，用new[]分配的内存用delete[]释放。</p><h2 id="7、const的作用"><a href="#7、const的作用" class="headerlink" title="7、const的作用"></a>7、const的作用</h2><p>1、const修饰类的成员变量，表示常量不可能被修改。</p><p>2、const修饰类的成员函数，表示函数不会修改类中的数据成员，不会调用其他非const的成员函数。</p><p>3、const函数只能调用const函数，非const函数可以调用const函数。</p><h2 id="8、堆和栈的区别"><a href="#8、堆和栈的区别" class="headerlink" title="8、堆和栈的区别"></a>8、堆和栈的区别</h2><p>1、栈 stack 存放函数的参数值、局部变量，由编译器自动分配释放。堆heap，是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收。</p><p>2、因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片。</p><h2 id="9、关键字static的作用"><a href="#9、关键字static的作用" class="headerlink" title="9、关键字static的作用"></a>9、关键字static的作用</h2><p>1、函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值。</p><p>2、模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内。</p><p>3、类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝。</p><p>4、类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量。</p><p><strong>注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象。</strong></p><h2 id="10、什么是内存泄漏？面对内存泄漏和指针越界的方法？"><a href="#10、什么是内存泄漏？面对内存泄漏和指针越界的方法？" class="headerlink" title="10、什么是内存泄漏？面对内存泄漏和指针越界的方法？"></a>10、什么是内存泄漏？面对内存泄漏和指针越界的方法？</h2><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p><p>方法：malloc/free要配套，对指针赋值的时候应该注意被赋值的指针是否需要释放；使用的时候记得指针的长度，防止越界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、C和CPP的区别&quot;&gt;&lt;a href=&quot;#1、C和CPP的区别&quot; class=&quot;headerlink&quot; title=&quot;1、C和CPP的区别&quot;&gt;&lt;/a&gt;1、C和CPP的区别&lt;/h2&gt;&lt;p&gt;1、C是面向过程的语言，是一个结构化的语言，而CPP是面向对象的语言，主要特</summary>
      
    
    
    
    <category term="CPP面试题目" scheme="https://jjking20010901.github.io/categories/CPP%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
    <category term="面试题目" scheme="https://jjking20010901.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>CPP实现Vector容器</title>
    <link href="https://jjking20010901.github.io/posts/f6e04cde.html"/>
    <id>https://jjking20010901.github.io/posts/f6e04cde.html</id>
    <published>2022-11-05T12:42:52.000Z</published>
    <updated>2022-11-06T02:30:33.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、实现一个高性能且跨平台的Vector"><a href="#1、实现一个高性能且跨平台的Vector" class="headerlink" title="1、实现一个高性能且跨平台的Vector"></a>1、实现一个高性能且跨平台的Vector</h2><p>知识点：</p><ul><li>CPP泛型编程(模板)</li><li>面向对象</li><li>运算符重载</li><li>CPP11的时间库</li><li>std标准库中实现内存移动的api</li></ul><p>Github：<a href="https://github.com/jjking20010901/Vector/tree/master">cpp实现vector</a></p><h2 id="2、API的封装"><a href="#2、API的封装" class="headerlink" title="2、API的封装"></a>2、API的封装</h2><p><strong>push_back(const T &amp;value)</strong>的解读：在向量的末尾，在其当前最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新元素。这有效地将容器大小增加了一个，这会导致自动重新分配分配的存储空间，前提是（并且仅当）新的向量大小超过当前向量容量。</p><p>push_back的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:尾插法插入数据</span></span><br><span class="line"><span class="comment"> * @param:泛型的数据</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&lt;m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[m_size]=value;</span><br><span class="line">        m_size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_capacity == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_capacity=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//容量不为0，则二倍扩容</span></span><br><span class="line">        m_capacity *=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开辟新的容量的容器</span></span><br><span class="line">    T *data= <span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="comment">//将原来容器中的数据移动到新的容器中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将原来容器的位置的内存释放</span></span><br><span class="line">    <span class="keyword">if</span>(m_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">    m_data[m_size]=value;</span><br><span class="line">    m_size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop_back()的解读：删除最后一个元素，移除向量中的最后一个元素，有效地将容器大小减少一个。</p><p>pop_back()的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:尾部弹出数据</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size()和capacity()方法的解读：获取容器中的元素数目；获取容器的容量。</p><p>size()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器当前大小</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器当前大小</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>capacity()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器容量</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器容量</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">capacity</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reserve(int n)方法解读：如果n大于当前向量容量，则该函数会导致容器重新分配其存储，将其容量增加到n（或更大）。在所有其他情况下，函数调用不会导致重新分配，向量容量也不会受到影响。</p><p>reserve(int n)方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:重新分配容器容量</span></span><br><span class="line"><span class="comment"> * @param:输入的容量</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">reserve</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_capacity&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩容，条件是当容量小于传入的容量大小</span></span><br><span class="line">    <span class="keyword">while</span>(m_capacity&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_capacity ==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态内存申请容量</span></span><br><span class="line">    T *data=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_data!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resize(int size)方法的解读：调整容器大小，使其包含size个元素，如果size小于当前容器大小，则内容将减少到其前size个元素，并删除（并销毁）超出的元素，如果size大于当前容器大小，则通过在末尾插入尽可能多的元素来扩展内容，以达到size的大小。如果指定了val，则将新元素初始化为val的副本，否则将对其进行值初始化。</p><p>resize(int size)方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:重新分配容器大小</span></span><br><span class="line"><span class="comment"> * @param:输入的大小</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">resize</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//容器内部大小大于或等于输入的大小</span></span><br><span class="line">    <span class="keyword">if</span>(m_size&gt;=size)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size=size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容器内部大小小于输入大小并且输入大小小于容器容量</span></span><br><span class="line">    <span class="keyword">if</span>(m_size &lt; size &amp;&amp; size&lt; m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m_size;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[i]=<span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_size=size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入大小大于容器容量</span></span><br><span class="line">    <span class="keyword">while</span>(m_capacity&lt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_capacity==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态申请扩容</span></span><br><span class="line">    T *data=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m_size;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_data!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">    m_size=size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>at(int index)方法的解读：返回容器中index索引位置的值。</p><p>at(int index)方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器索引下标的值</span></span><br><span class="line"><span class="comment"> * @param:容器索引下标</span></span><br><span class="line"><span class="comment"> * @return:返回容器索引下标的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不符合要求的数组下标，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;= m_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vec[] out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[]运算符的重载的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:重载中括号并获取索引下标值</span></span><br><span class="line"><span class="comment"> * @param:索引下标</span></span><br><span class="line"><span class="comment"> * @return:容器索引下标的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="keyword">operator</span> [] (<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>empty()方法和clear()方法的解读：判断容器是否为空；清空容器的元素。</p><p>empty()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:判断容器是否为空</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:若容器有数据返回true,否则返回false</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Vector&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:清空容器的数据</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_size=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>front()方法和back()方法的解读：获取容器第一个元素的值；获取最后一个元素的值。</p><p>front()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器的第一个元素的值</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器第一个元素的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vec is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>back()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器最后一个元素的值</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器最后一个元素的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vec is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_data[m_size<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap()方法的解读：交换两个容器的元素、大小以及容量。</p><p>swap()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:交换两个容器的数据、大小以及容量</span></span><br><span class="line"><span class="comment"> * @param:另一个容器对象</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">swap</span>(Vector&lt;T&gt; &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存储另外一个数组的临时数据</span></span><br><span class="line">    T *data=other.m_data;</span><br><span class="line">    <span class="type">int</span> size=other.m_size;</span><br><span class="line">    <span class="type">int</span> capacity=other.m_capacity;</span><br><span class="line"></span><br><span class="line">    other.m_data=m_data;</span><br><span class="line">    other.m_size=m_size;</span><br><span class="line">    other.m_capacity=m_capacity;</span><br><span class="line"></span><br><span class="line">    m_data=data;</span><br><span class="line">    m_size=size;</span><br><span class="line">    m_capacity=capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些api这里就不再做过多的解释，直接去gtihub看我的代码就行。</p><h2 id="3、Iterator的封装"><a href="#3、Iterator的封装" class="headerlink" title="3、Iterator的封装"></a>3、Iterator的封装</h2><p>在Vector中封装一个Iterator的类，用来代表迭代器。这里主要是通过运算符重载来实现迭代器的api。</p><p>两个迭代器相等的判断以及不等的判断的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Iterator &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pointer==other.m_pointer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> Iterator &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pointer !=other.m_pointer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器的拷贝赋值重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator &amp; <span class="keyword">operator</span> = (<span class="type">const</span> Iterator &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer=other.m_pointer;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器前置加1以及后置加1的封装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置加1</span></span><br><span class="line">Iterator <span class="keyword">operator</span> ++ ()</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置加1</span></span><br><span class="line">Iterator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Iterator it=*<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器加法和减法运算重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器加法运算重载</span></span><br><span class="line">Iterator <span class="keyword">operator</span> + (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    Iterator it=*<span class="keyword">this</span>;</span><br><span class="line">    it.m_pointer+=value;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器减法运算重载</span></span><br><span class="line">Iterator &amp; <span class="keyword">operator</span> - (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    Iterator it=*<span class="keyword">this</span>;</span><br><span class="line">    it.m_pointer-=value;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器+=和-=的重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器+=运算重载</span></span><br><span class="line">Iterator &amp; <span class="keyword">operator</span> += (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer+=value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器-=运算符重载</span></span><br><span class="line">Iterator &amp; <span class="keyword">operator</span> -= (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer-=value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器解引用和指针操作重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器解引用运算符重载</span></span><br><span class="line">T &amp; <span class="keyword">operator</span> * ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *m_pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器指针操作的运算符重载</span></span><br><span class="line">T * <span class="keyword">operator</span> -&gt; ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起始迭代器和结束迭代器的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//起始迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">begin</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(m_data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">end</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(m_data+m_size)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代器查找某个元素的位置(<strong>该方法STL-vector中未实现</strong>)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">find</span>(<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(Vector&lt;T&gt;::Iterator it=<span class="built_in">begin</span>();it!=<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert()方法的解读：通过在指定位置的元素之前插入新元素来扩展向量，从而有效地增加插入的元素数量的容器大小。</p><p>insert()方法的实现(函数重载)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator it,<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insert</span>(it,<span class="number">1</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator it,<span class="type">int</span> n,<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取插入位置的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> pos=it-<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//插入元素足够存放(无需扩容的情况)  </span></span><br><span class="line">    <span class="keyword">if</span>(m_size+n&lt;=m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当内部内存发生重叠使用memmove，拷贝内存，否则使用memcpy</span></span><br><span class="line">            std::<span class="built_in">memmove</span>(m_data+pos+n,m_data+pos,(m_size-pos)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m_size;i&gt;pos;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                m_data[i+n<span class="number">-1</span>]=m_data[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[pos+i]=value;</span><br><span class="line">        &#125;</span><br><span class="line">        m_size+=n;</span><br><span class="line">        <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">Iterator</span>(m_data+pos);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素过多,大于数组容量(扩容)</span></span><br><span class="line">    <span class="keyword">while</span>(m_size+n&gt;m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_capacity==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T *data=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memcpy</span>(data,m_data,m_size*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pos;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i]=m_data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memcpy</span>(data+pos+n,m_data+pos,(m_size-pos)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;m_size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i]=m_data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[pos+i]=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_data!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">    m_size+=n;</span><br><span class="line">    <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">Iterator</span>(m_data+pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>erase()方法的解读：从向量中移除单个元素（位置）或一系列元素（[第一个，最后一个））。</p><p>erase()方法的实现(函数重载)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断删除的元素是否为最后一个</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">end</span>() - it ==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除其他位置的元素</span></span><br><span class="line">    <span class="type">int</span> pos = it - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memmove</span>(m_data+pos,m_data+pos+<span class="number">1</span>,(m_size-pos<span class="number">-1</span>)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;m_size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[i]=m_data[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_size-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator first,</span><br><span class="line">                                              <span class="type">const</span> Vector&lt;T&gt;::Iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取消除元素的第一个区间</span></span><br><span class="line">    <span class="type">int</span> f=first - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//获取消除元素的第二个区间</span></span><br><span class="line">    <span class="type">int</span> l=last - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//数组长度变化</span></span><br><span class="line">    <span class="type">int</span> pos = last - first;</span><br><span class="line">    <span class="comment">//判断是否为基本类型，提高删除性能</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memmove</span>(m_data+f,m_data+l,(m_size-l)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//元素向前移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size-l;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[f]=m_data[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_size-=pos;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、STL-vector与Sakura-Vector性能对比"><a href="#4、STL-vector与Sakura-Vector性能对比" class="headerlink" title="4、STL-vector与Sakura-Vector性能对比"></a>4、STL-vector与Sakura-Vector性能对比</h2><p>insert()方法性能比较，代码如下：</p><p>STL-vector插入bool类型数据的时间(以插入10000个数据为例)：</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105202833288.png" alt="image-20221105202833288"></p><p>我们可以发现STL-vector所用时间为870.335ms。</p><p>Sakura-Vector插入bool类型数据的时间(以插入10000个数据为例)：</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105202959214.png" alt="image-20221105202959214"></p><p>我们可以发现Sakura-Vector所用时间为4.0109ms，其他类型的插入大体和STL-vector相近。</p><p>STL-vector删除bool类型数据的时间:</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105203859908.png" alt="image-20221105203859908"></p><p>我们可以发现STL-vector所用时间为984.158ms。</p><p>Sakura-Vector删除bool类型数据所用时间：</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105204011490.png" alt="image-20221105204011490"></p><p>我们可以发现Sakura-Vector所用时间为1.0451ms。</p><p>insert()的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*测试insert性能*/</span></span><br><span class="line">    <span class="keyword">auto</span> startTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max=<span class="number">10000</span>;</span><br><span class="line">    <span class="comment">//std::vector&lt;bool&gt;v;</span></span><br><span class="line">    Vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(),<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> endTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//毫秒级</span></span><br><span class="line">    <span class="type">double</span> duration_millsecond=std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>,std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;run time: &quot;</span>&lt;&lt; duration_millsecond&lt;&lt;<span class="string">&quot; ms&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>erase()的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*测试erase性能*/</span></span><br><span class="line"><span class="comment">// std::vector&lt;bool&gt;v1;</span></span><br><span class="line"> Vector&lt;<span class="type">bool</span>&gt;v1;</span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> max=<span class="number">10000</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     v1.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">auto</span> startTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">auto</span> endTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"> <span class="type">double</span> duration_millsecond=std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>,std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"> std::cout&lt;&lt;<span class="string">&quot;run time: &quot;</span>&lt;&lt; duration_millsecond&lt;&lt;<span class="string">&quot; ms&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、实现一个高性能且跨平台的Vector&quot;&gt;&lt;a href=&quot;#1、实现一个高性能且跨平台的Vector&quot; class=&quot;headerlink&quot; title=&quot;1、实现一个高性能且跨平台的Vector&quot;&gt;&lt;/a&gt;1、实现一个高性能且跨平台的Vector&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="CPP项目实战" scheme="https://jjking20010901.github.io/categories/CPP%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="CPP造轮子" scheme="https://jjking20010901.github.io/tags/CPP%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>共享智能指针</title>
    <link href="https://jjking20010901.github.io/posts/4c183086.html"/>
    <id>https://jjking20010901.github.io/posts/4c183086.html</id>
    <published>2022-11-05T07:39:40.000Z</published>
    <updated>2022-11-06T02:30:36.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="智能指针的简介"><a href="#智能指针的简介" class="headerlink" title="智能指针的简介"></a>智能指针的简介</h2><p>在C++中没有垃圾回收机制，必须自己释放分配内存，否则就会造成内存泄漏。解决这个问题最有效的方法是使用智能指针(smart pointer)。<strong>智能指针是存储指向动态内存分配(堆)对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动的销毁动态分配的对象，防止内存泄漏。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</strong></p><p>C++11中提供了三种智能指针，使用这些智能指针时所需要引用的头文件为<strong><memory></strong>：</p><ul><li>std::shared_ptr：共享智能指针。</li><li>std::unique_ptr：独占智能指针。</li><li>std::weak_ptr：弱引用智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li></ul><h2 id="1、shared-ptr的初始化"><a href="#1、shared-ptr的初始化" class="headerlink" title="1、shared_ptr的初始化"></a>1、shared_ptr的初始化</h2><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，<strong>共享智能指针shared_ptr是一个模板类</strong>，<strong>如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。</strong>共享智能指针对象初始化完毕后就指向了要管理的那块堆内存，如果想要查看当前有多少智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数<strong>use_count，</strong>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><h2 id="1-1、通过构造函数初始化"><a href="#1-1、通过构造函数初始化" class="headerlink" title="1.1、通过构造函数初始化"></a>1.1、通过构造函数初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数, 语法格式如下:</span></span><br><span class="line">std::shared_ptr&lt;T&gt; 智能指针名字(创建堆内存);</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1.use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2.use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3.use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4.use_count: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191005888.png" alt="image-20220819100556838"></p><p><strong>注意：</strong></p><p><strong>如果智能指针被初始化一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为nullptr空指针，引用计数不会+1，另外，不要使用一个原始指针初始化多个shared_ptr。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">// error, 编译不会报错, 运行会出错，指针p已经初始化了p1了</span></span><br></pre></td></tr></table></figure><h2 id="1-2、通过拷贝和移动构造函数初始化"><a href="#1-2、通过拷贝和移动构造函数初始化" class="headerlink" title="1.2、通过拷贝和移动构造函数初始化"></a>1.2、通过拷贝和移动构造函数初始化</h2><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就可以被自动调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(std::move(ptr1))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">move</span>(ptr2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序结果的输出如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191016085.png" alt="image-20220819101609028"></p><p><strong>注意：</strong></p><p><strong>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始化智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存引用计数不会变化。</strong></p><h2 id="1-3、通过std-make-shared初始化"><a href="#1-3、通过std-make-shared初始化" class="headerlink" title="1.3、通过std::make_shared初始化"></a>1.3、通过std::make_shared初始化</h2><p>通过C++提供的std::make_shared()就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>T：模板参数的数据类型。</strong></p></li><li><p><strong>Arg&amp;&amp;…arg：要初始化的数据，如果是通过make_shared创建对象，需要按照构造函数的参数列表指定。</strong></p></li></ul><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(string str) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr2 = <span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr3 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr4 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码的输出结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191031378.png" alt="image-20220819103120318"></p><p><strong>注意：</strong></p><p><strong>使用st::make_shared()模板函数可以完成内存地址的创建，并将最终的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的()可完成地址的初始化，如果要创建一个类对象，函数的()内部需要指定构造函数对象需要的参数，也就是类构造函数的参数。</strong></p><h2 id="1-4、通过reset方法初始化"><a href="#1-4、通过reset方法初始化" class="headerlink" title="1.4、通过reset方法初始化"></a>1.4、通过reset方法初始化</h2><p>共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter, <span class="keyword">class</span> Alloc &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d, Alloc alloc )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>ptr：指向要取得所有权的对象的指针。</strong></li><li><strong>d：指向要取得所有权的对象的指针。</strong></li><li><strong>aloc：内部存储所用的分配器。</strong></li></ul><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1.use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2.use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3.use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4.use_count: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    ptr4.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1.use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2.use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3.use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4.use_count: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5.use_count: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191041241.png" alt="image-20220819104137179"></p><p><strong>注意：</strong></p><p><strong>对于一个未初始化的共享内存指针，可以通过reset方法初始化，当智能指针中有值时，调用reset方法会使引用计数减1。</strong></p><h2 id="1-5、获取原始指针"><a href="#1-5、获取原始指针" class="headerlink" title="1.5、获取原始指针"></a>1.5、获取原始指针</h2><p>对应用基础数据类型来说，通过操作智能指针和操作智能指针管理内存效果是一样的，可以直接完成数据的读写。</p><p>但是如果共享智能指针管理的是一个对象，那么就需要去除原始内存地址再操作，可以调用共享智能指针类提供的get方法得到原始地址，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">128</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[len])</span></span>;</span><br><span class="line">    <span class="comment">// 得到指针的原始地址</span></span><br><span class="line">    <span class="type">char</span>* add = ptr.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//初始化字符串</span></span><br><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0</span>, len);</span><br><span class="line">    <span class="built_in">strcpy</span>(add, <span class="string">&quot;I will be luffy !!!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; add &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; *p.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序的输出如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191056577.png" alt="image-20220819105634516"></p><h2 id="2、指定删除器"><a href="#2、指定删除器" class="headerlink" title="2、指定删除器"></a>2、指定删除器</h2><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针给析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数的本质就是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义删除器函数，释放int型内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int 型内存被释放了...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), deleteIntPtr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除器函数也可以lambda表达式，因此代码也可以写成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<strong>lambda表达式的参数就是智能指针管理内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</strong></p><p>在C++11中使用shared_ptr管理动态数组，需要指定删除器，因为std::make_shared_ptr的默认删除器不支持数组对象，具体处理代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在删除数组内存时，除了自己编写删除器，也可以使用<strong>C++提供的std::default_delete<T>()</strong>函数作为删除器。</p><p>这个函数内部删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型指定为什么类型即可，具体处理代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们也可以自己封装一个make_shared_array方法让shared_ptr支持数组，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_share_array</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回匿名对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T[size], <span class="built_in">default_delete</span>&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_share_array</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">char</span>&gt; ptr2 = <span class="built_in">make_share_array</span>&lt;<span class="type">char</span>&gt;(<span class="number">128</span>);</span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;智能指针的简介&quot;&gt;&lt;a href=&quot;#智能指针的简介&quot; class=&quot;headerlink&quot; title=&quot;智能指针的简介&quot;&gt;&lt;/a&gt;智能指针的简介&lt;/h2&gt;&lt;p&gt;在C++中没有垃圾回收机制，必须自己释放分配内存，否则就会造成内存泄漏。解决这个问题最有效的方法是使</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="共享智能指针" scheme="https://jjking20010901.github.io/tags/%E5%85%B1%E4%BA%AB%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>RALL原则和unique_ptr</title>
    <link href="https://jjking20010901.github.io/posts/d2973973.html"/>
    <id>https://jjking20010901.github.io/posts/d2973973.html</id>
    <published>2022-11-05T07:31:56.000Z</published>
    <updated>2022-11-06T02:30:38.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、RALL简介"><a href="#1、RALL简介" class="headerlink" title="1、RALL简介"></a>1、RALL简介</h2><p><strong>RALL是resource acquisition is initialization的缩写，意思是”资源获取即初始化”。</strong>它是C++之父Bjarne Stroustrup提出的设计理念，其核心是把资源和对象的声明周期绑定，对象创建获取资源，对象销毁释放资源。在RALL的指导下，C++把底层的资源管理问题提升到了对象声明周期管理的更高层次。</p><h2 id="2、RALL机制"><a href="#2、RALL机制" class="headerlink" title="2、RALL机制"></a>2、RALL机制</h2><ul><li>使用C++时，最让人头疼的便是内存管理，但却又正是对内存高度可操作性给了C++程序员极大自由和装逼资本。</li><li>当我们在堆区new出一块内存空间，在使用完之后，如果不使用delete来释放这块资源则将导致内存泄漏，这在中大型项目中极具有破坏性。但人无完人，我们并不能保证每次都记得释放无法再次获取到且不再使用的内存，下面给出一个例子，让大家看看忘记释放资源造成内存泄漏多么恐怖！！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *ptr=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">        ptr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        ptr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        ptr[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//delete ptr    //忘记释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果(未释放内存)：</p><p>运行程序并打开资源管理器，可以发现这么简单的程序竟然占用了11点几的MB内存，所以大家千万要记得释放内存。</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105150404335.png" alt="image-20221105150404335"></p><h2 id="3、智能指针的介绍"><a href="#3、智能指针的介绍" class="headerlink" title="3、智能指针的介绍"></a>3、智能指针的介绍</h2><p>在 C++ 中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<strong>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</strong></p><p>C++11中提供了三种智能指针，使用这些智能指针需要引入头文件<memory>：</p><ul><li><strong>std::shared_ptr</strong>:共享的智能指针。</li><li><strong>std::unique_ptr</strong>:独占的智能指针。</li><li><strong>std::weak_ptr</strong>:弱引用智能指针，它不共享指针，不能操作资源，是用来监视std::shared_ptr的。</li></ul><h2 id="4、unique-ptr的初始化"><a href="#4、unique-ptr的初始化" class="headerlink" title="4、unique_ptr的初始化"></a>4、unique_ptr的初始化</h2><p>std::unique_ptr 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 unique_ptr 赋值给另一个 unique_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过构造函数初始化对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="comment">// error, 不允许将一个unique_ptr赋值给另一个unique_ptr</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br></pre></td></tr></table></figure><p>std::unique_ptr不允许复制，但是可以通过函数返回给其他std::unique_ptr，还可以通过std::move来转移给其他的std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">520</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 通过转移所有权的方式初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr3 = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique_ptr的指针类有一个reset方法，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( pointer ptr = pointer() )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>使用reset方法可以让unique_ptr解除对原始内存管理，也可以用来初始化一个独占智能指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr1.<span class="built_in">reset</span>();</span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ptr1.reset()</strong>; 解除对原始内存的管理</li><li><strong>ptr2.reset(new int(250))</strong>; 重新指定智能指针管理的原始内存</li></ul><p>如果想要获取独占智能指针管理原始地址，可以调用get()方法，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; *ptr2.<span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">// 得到内存地址中存储的实际数值 250</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、删除器"><a href="#5、删除器" class="headerlink" title="5、删除器"></a>5、删除器</h2><p>unique_ptr 指定删除器和 shared_ptr 指定删除器是有区别的，unique_ptr 指定删除器的时候需要确定删除器的类型，所以不能像 shared_ptr 那样直接指定删除器，举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;<span class="comment">// ok</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;<span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中第 7 行，<strong>func_ptr 的类型</strong>和 <strong>lambda表达式的类型</strong>是一致的。在 lambda 表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错。</p><p>上面的代码中错误原因是这样的，在 lambda 表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、RALL简介&quot;&gt;&lt;a href=&quot;#1、RALL简介&quot; class=&quot;headerlink&quot; title=&quot;1、RALL简介&quot;&gt;&lt;/a&gt;1、RALL简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;RALL是resource acquisition is initializ</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="RALL原则和独占智能指针" scheme="https://jjking20010901.github.io/tags/RALL%E5%8E%9F%E5%88%99%E5%92%8C%E7%8B%AC%E5%8D%A0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>汽车仪表盘绘制</title>
    <link href="https://jjking20010901.github.io/posts/cb2eafdb.html"/>
    <id>https://jjking20010901.github.io/posts/cb2eafdb.html</id>
    <published>2022-11-05T04:53:44.000Z</published>
    <updated>2022-11-06T02:30:34.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、汽车仪表盘效果图"><a href="#1、汽车仪表盘效果图" class="headerlink" title="1、汽车仪表盘效果图"></a>1、汽车仪表盘效果图</h2><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301516841.png" alt="image-20220830151624760"></p><p>上面是通过QPainter绘制出来的汽车仪表盘，可能与真实的汽车仪表盘有些差距，但总体来说还可以吧，下面将会详细讲解如何绘制汽车仪表盘。</p><h2 id="2、绘制前的准备"><a href="#2、绘制前的准备" class="headerlink" title="2、绘制前的准备"></a>2、绘制前的准备</h2><p>首先我们将窗体背景设置为偏黑色，这样方便我们后续观察效果，以及将窗口固定位1280*800，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1280</span>,<span class="number">800</span>);</span><br><span class="line">QPalette pale=<span class="keyword">this</span>-&gt;<span class="built_in">palette</span>();</span><br><span class="line">pale.<span class="built_in">setBrush</span>(QPalette::Window,<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>)));</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setPalette</span>(pale);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301439671.png" alt="image-20220830143915607"></p><h2 id="3、绘制刻度线"><a href="#3、绘制刻度线" class="headerlink" title="3、绘制刻度线"></a>3、绘制刻度线</h2><p>首先我们要获取仪表盘的中心点radius以及仪表盘的宽高，然后将画笔移动到窗口的中下方，移动画笔也就是移动坐标系。</p><p>然后使用QPainter中的抗锯齿的方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="type">int</span> width=<span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line">   <span class="comment">//仪表盘高度</span></span><br><span class="line">   <span class="type">int</span> height=<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()<span class="number">-100</span>;</span><br><span class="line">   <span class="comment">//仪表盘中心位置</span></span><br><span class="line">   <span class="type">int</span> radius=((width&gt;height)? height:width)/<span class="number">2</span>;</span><br><span class="line">   <span class="comment">//移动画笔到中下方</span></span><br><span class="line">   painter.<span class="built_in">translate</span>(width/<span class="number">2</span>,height*<span class="number">0.6</span>);</span><br><span class="line">   <span class="comment">//启用反锯齿</span></span><br><span class="line">   painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>接下来就是画刻度线，首先我们要组装刻度点的路径，使用QPainterPath。然后是绘制长的刻度线，大于或者等于160的刻度值为红色，其他的刻度线为白色，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//画刻度线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawSmallScale</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//组装点的路径图</span></span><br><span class="line">    QPainterPath pointPath_small;</span><br><span class="line">    pointPath_small.<span class="built_in">moveTo</span>(<span class="number">-2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">-2</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QPainterPath pointPath_big;</span><br><span class="line">    pointPath_big.<span class="built_in">moveTo</span>(<span class="number">-2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">-2</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制121个小点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">121</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="function">QPointF <span class="title">point</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        point.<span class="built_in">setX</span>(radius*<span class="built_in">qCos</span>(((<span class="number">210</span>-i*<span class="number">2</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        point.<span class="built_in">setY</span>(radius*<span class="built_in">qSin</span>(((<span class="number">210</span>-i*<span class="number">2</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        painter.<span class="built_in">translate</span>(point.<span class="built_in">x</span>(),-point.<span class="built_in">y</span>());</span><br><span class="line">        painter.<span class="built_in">rotate</span>(<span class="number">-120</span>+i*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">235</span>,<span class="number">70</span>,<span class="number">70</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPath</span>(pointPath_big);<span class="comment">//绘画大刻度</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPath</span>(pointPath_small);<span class="comment">//绘画小刻度</span></span><br><span class="line">        &#125;</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301452519.png" alt="image-20220830145212461"></p><h2 id="4、刻度数字"><a href="#4、刻度数字" class="headerlink" title="4、刻度数字"></a>4、刻度数字</h2><p>在每一个更长的刻度线上绘制对应的数字，我们要找到对应的坐标，还要设置数字的字体以及大小，而且我们还要旋转画笔，让每个对应的数字都是在正确的位置，通过角度旋转的角度来计算弧度，然后通过弧度来获取对应的坐标，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刻度数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawDigital</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置画笔，画笔默认NOPEN</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">15</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;++i)&#123;</span><br><span class="line">        <span class="function">QPointF <span class="title">point</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        point.<span class="built_in">setX</span>(radius*<span class="built_in">qCos</span>(((<span class="number">210</span>-i*<span class="number">20</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        point.<span class="built_in">setY</span>(radius*<span class="built_in">qSin</span>(((<span class="number">210</span>-i*<span class="number">20</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        painter.<span class="built_in">translate</span>(point.<span class="built_in">x</span>(),-point.<span class="built_in">y</span>());</span><br><span class="line">        painter.<span class="built_in">rotate</span>(<span class="number">-120</span>+i*<span class="number">20</span>);</span><br><span class="line">        painter.<span class="built_in">drawText</span>(<span class="number">-25</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">20</span>,Qt::AlignCenter,QString::<span class="built_in">number</span>(i*<span class="number">20</span>));</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还原画笔</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301459646.png" alt="image-20220830145901581"></p><h2 id="5、绘制发光的圆圈"><a href="#5、绘制发光的圆圈" class="headerlink" title="5、绘制发光的圆圈"></a>5、绘制发光的圆圈</h2><p>在刻度线的四周绘制一种渐变色的发光圆圈，首先我们要创建大小圆的弧圈，通过arcTo方法，然后在小圆中绘制椭圆，通过addEllipse，然后通过QRadialGradient设置渐变色，最后通过drawPath方法获取大圆减小圆之后的路径，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath outRing;</span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    outRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    outRing.<span class="built_in">arcTo</span>(-radius,-radius, <span class="number">2</span>*radius,<span class="number">2</span>*radius,<span class="number">-30</span>,<span class="number">240</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    outRing.<span class="built_in">closeSubpath</span>();</span><br><span class="line">    <span class="comment">//设置渐变色k</span></span><br><span class="line">    <span class="function">QRadialGradient <span class="title">radialGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,radius,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">1</span>,<span class="built_in">QColor</span>(<span class="number">0</span>,<span class="number">82</span>,<span class="number">230</span>));</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">0.9</span>,Qt::transparent);</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(radialGradient);</span><br><span class="line">    <span class="comment">//大圆减小圆</span></span><br><span class="line">    painter.<span class="built_in">drawPath</span>(outRing.<span class="built_in">subtracted</span>(inRing));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301504164.png" alt="image-20220830150437094"></p><h2 id="6、绘制指针"><a href="#6、绘制指针" class="headerlink" title="6、绘制指针"></a>6、绘制指针</h2><p>和之前一样我们要组装点的路径，然后是计算点的坐标，这些都可以自己慢慢的试试，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawPointer</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//组装点的路径图</span></span><br><span class="line">    QPainterPath pointPath;</span><br><span class="line">    pointPath.<span class="built_in">moveTo</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">1</span>,-radius);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">-1</span>,-radius);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">-10</span>,<span class="number">0</span>);</span><br><span class="line">    pointPath.<span class="built_in">arcTo</span>(<span class="number">-10</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">180</span>,<span class="number">180</span>);</span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(<span class="number">-5</span>,<span class="number">-5</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算并选择绘图对象坐标</span></span><br><span class="line">    painter.<span class="built_in">rotate</span>(degRotate - <span class="number">120</span>);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(pointPath.<span class="built_in">subtracted</span>(inRing));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301508886.png" alt="image-20220830150828813"></p><h2 id="7、绘制中间大圆、小圆以及发光内圈"><a href="#7、绘制中间大圆、小圆以及发光内圈" class="headerlink" title="7、绘制中间大圆、小圆以及发光内圈"></a>7、绘制中间大圆、小圆以及发光内圈</h2><p>绘制大圆的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_big</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(inRing);</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制小圆的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_small</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(inRing);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制发光内圈的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_shine</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="function">QRadialGradient <span class="title">radialGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,radius,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//    radialGradient.setColorAt(0.5,QColor(8,77,197));</span></span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">0.5</span>,<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">68</span>,<span class="number">185</span>,<span class="number">150</span>));</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">1.0</span>,Qt::transparent);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QBrush</span>(radialGradient));</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(-radius,-radius,<span class="number">2</span>*(radius),<span class="number">2</span>*(radius));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301513631.png" alt="image-20220830151303554"></p><h2 id="8、绘制单位和时速"><a href="#8、绘制单位和时速" class="headerlink" title="8、绘制单位和时速"></a>8、绘制单位和时速</h2><p>绘制速度单位的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawUnit</span><span class="params">(QPainter &amp; painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">16</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-50</span>, -radius, <span class="number">100</span>, <span class="number">20</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;km/h&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-60</span>, -radius + <span class="number">130</span>, <span class="number">120</span>, <span class="number">40</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;当前车速&quot;</span>));</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">50</span>));</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-120</span>, -radius + <span class="number">280</span>, <span class="number">250</span>, <span class="number">40</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;-请按space键加速-&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制时速的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawNum</span><span class="params">(QPainter &amp; painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">45</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-75</span>, -radius - <span class="number">20</span>, <span class="number">150</span>, <span class="number">100</span>,Qt::AlignCenter,QString::<span class="built_in">number</span>(degRotate));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301515543.png" alt="image-20220830151543465"></p><h2 id="9、键盘事件和鼠标事件控制车速"><a href="#9、键盘事件和鼠标事件控制车速" class="headerlink" title="9、键盘事件和鼠标事件控制车速"></a>9、键盘事件和鼠标事件控制车速</h2><p>首先我们需要定义一个定时器timer，然后先将以下键盘事件，我们定义一个direction和degRotate，direction为0时代表减速或者车速为0，为1代表加速，degRotate代表车速，一开始为0。</p><p>当我们按下空格键时，定时器开始，同样的direction变为1，当定时器超时的时候，执行槽函数speed_changed。</p><p>下面是键盘按下事件的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>()==Qt::Key_Space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">            direction=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是槽函数speed_changed的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::speed_changed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(direction == <span class="number">1</span>)<span class="comment">//加速</span></span><br><span class="line">    &#123;</span><br><span class="line">        degRotate++;</span><br><span class="line">        <span class="keyword">if</span>(degRotate &gt; <span class="number">240</span>)</span><br><span class="line">            degRotate = <span class="number">240</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(direction == <span class="number">0</span>)<span class="comment">//减速</span></span><br><span class="line">    &#123;</span><br><span class="line">        degRotate--;</span><br><span class="line">        <span class="keyword">if</span>(degRotate &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            degRotate = <span class="number">0</span>;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们松开空格键时，direction为0，开始减速。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyReleaseEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>()==Qt::Key_Space)</span><br><span class="line">    &#123;</span><br><span class="line">        direction=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是鼠标点击事件和鼠标松开事件，当我们点击鼠标时，车速增加，松开时车速减少。</p><p>鼠标点击事件代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            is_Pressed=<span class="literal">true</span>;</span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">            direction=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标松开事件代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line">    is_Pressed=<span class="literal">false</span>;</span><br><span class="line">    direction=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、代码获取"><a href="#10、代码获取" class="headerlink" title="10、代码获取"></a>10、代码获取</h2><p>我已经将代码推送到了gitee上面了，想要源码的可以通过下方链接获取：</p><p><a href="https://gitee.com/GoodNightZoe/car-board.git">汽车仪表盘</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、汽车仪表盘效果图&quot;&gt;&lt;a href=&quot;#1、汽车仪表盘效果图&quot; class=&quot;headerlink&quot; title=&quot;1、汽车仪表盘效果图&quot;&gt;&lt;/a&gt;1、汽车仪表盘效果图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubuserconten</summary>
      
    
    
    
    <category term="QtWidget" scheme="https://jjking20010901.github.io/categories/QtWidget/"/>
    
    
    <category term="QtWidget自绘" scheme="https://jjking20010901.github.io/tags/QtWidget%E8%87%AA%E7%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>右值引用和完美转发</title>
    <link href="https://jjking20010901.github.io/posts/eaeeda04.html"/>
    <id>https://jjking20010901.github.io/posts/eaeeda04.html</id>
    <published>2022-11-04T09:09:13.000Z</published>
    <updated>2022-11-06T02:30:30.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、右值引用的简介"><a href="#1、右值引用的简介" class="headerlink" title="1、右值引用的简介"></a>1、右值引用的简介</h2><p>C++11增加了一个新的类型，称为<strong>右值引用(R-value reference)</strong>，标记为 <strong>&amp;&amp;。</strong>在介绍右值引用类型之前要先了解什么是左值和右值：</p><ul><li>lvalue是<strong>locator value</strong>的缩写，rvalue是 <strong>read value</strong>的缩写。</li><li>左值是指<strong>存储在内存中、有明确存储地址(可取地址)的数据。</strong></li><li>右值是指<strong>可以提供数据值的数据(不可取地址)。</strong></li></ul><p>通过描述可以看出，区分左值与右值的便捷方法是：<strong>可以对表达式取地址(&amp;)就是左值，否则为右值。</strong></p><p>所有有名字的变量或者对象都是左值，而右值是匿名的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1314</span>;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><p>一般情况下，位于 = 前面的表达式为左值，位于 = 后边的表达式为右值。也就是说例子中的a,b为左值，520,1314为右值。a=b是一种特殊情况，在这个表达式中a，b都是左值，因为变量b是可以被取地址的，不能视为右值。</p><p>C++11中右值可以分为两种：一个是将亡值，另一个则是纯右值：</p><ul><li><strong>纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambada表达式等。</strong></li><li><strong>将亡值：与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值、std::move的返回值等。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">520</span>;</span><br></pre></td></tr></table></figure><p>上面语句中的value为左值，520为字面量也就是右值。其中value可以被引用，但是520就不行了，因为字面量都是右值。</p><h2 id="2、右值引用的使用"><a href="#2、右值引用的使用" class="headerlink" title="2、右值引用的使用"></a>2、右值引用的使用</h2><p>右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用它的方式找到它。<strong>无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又”重获新生”。</strong></p><p>其生命周期与右值引用类型变量的声明周期一样，只要该变量还活着，该右值临时量将会一直存活下去。</p><p>关于右值引用的使用，参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; value = <span class="number">520</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1;</span><br><span class="line">    <span class="type">int</span> &amp;&amp;a2 = a1;        <span class="comment">// error</span></span><br><span class="line">    Test&amp; t = <span class="built_in">getObj</span>();   <span class="comment">// error</span></span><br><span class="line">    Test &amp;&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="type">const</span> Test&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上面的例子中<strong>int &amp;&amp;value=520;</strong>里面的520为纯右值，<strong>value</strong>是字面量<strong>520</strong>这个右值的引用。</li><li>在<strong>int &amp;&amp;a2=a1</strong>中；<strong>a1</strong>虽然写在<strong>=</strong>的右边，但是它仍然是一个左值，使<strong>用左值初始化一个右值引用是不合法的。</strong></li><li><strong>Test &amp; t=getObj()</strong>这段代码语法是错误的，<strong>右值不能给普通的左值引用赋值。</strong></li><li><strong>Test &amp;&amp; t=getObj()</strong>中getObj()返回的<strong>临时对象称为将亡值，t是这个将亡值的右值引用。</strong></li><li><strong>const Test &amp; t=getObj()</strong>这段代码语法是正确的，<strong>常量左值引用是一个万能的引用类型，它可以接受左值、右值、常量左值和常量右值。</strong></li></ul><h2 id="3、性能优化"><a href="#3、性能优化" class="headerlink" title="3、性能优化"></a>3、性能优化</h2><p>在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能优化。</p><p>修改以下上面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_num: &quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208161702687.png" alt="image-20220816170224552"></p><p>通过输出结果我们可以看到调用Test t=getObj()的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到对象t，在getObj()函数中创建的对象虽然进行了内存申请操作，但是没有使用就释放掉了。如果能够使用临时对象已经申请的资源，既能节省资源，还能节省申请和释放的时间，如果要执行这样的操作就需要使用右值引用了。</p><p><strong>右值引用具有移动语义，移动语义可将资源(堆、系统对象等)通过浅拷贝从一个对象转义到另一个对象这样就能减少不必要的临时对象的创建、拷贝及销毁，可以大幅度提高C++应用程序的性能。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加移动构造函数</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">m_num</span>(a.m_num)</span><br><span class="line">    &#123;</span><br><span class="line">        a.m_num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct: my name is sunny&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test class ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_num: &quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码执行结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208161712211.png" alt="image-20220816171225155"></p><p>通过修改，在上面的代码给Test类添加了<strong>移动构造函数(参数为右值引用类型)，</strong>这样在进行Test t=getObj()操作时候并没有调用拷贝构造函数进行深拷贝，而是调用移动构造函数，这个函数中只是进行了浅拷贝，没有对临时对象进行深拷贝，提高性能。</p><p>如果不使用移动构造，在执行Test t=getObj()时候也是进行浅拷贝，但是临时对象被析构的时候，类成员指针int *m_num指向的内存也就被析构了，对象t也就无法访问这块内存地址了。</p><p>在测试程序中getObj()的返回值就是一个将亡值，也就是一个右值，在进行赋值操作的时候如果右边是一个右值，那么移动构造就会被调用。<strong>移动构造中使用了右值引用，会将临时对象的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。</strong></p><p><strong>注意：</strong></p><p><strong>对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数。</strong></p><h2 id="4、-amp-amp-的特性"><a href="#4、-amp-amp-的特性" class="headerlink" title="4、&amp;&amp;的特性"></a>4、&amp;&amp;的特性</h2><p>在 C++ 中，并不是所有情况下 <strong>&amp;&amp; 都代表是一个右值引用，</strong>具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为 T&amp;&amp;，如果是自动类型推导需要指定为 auto &amp;&amp;，在这两种场景下 &amp;&amp; 被称作未定的引用类型。另外还有一点需要额外注意 const T&amp;&amp; 表示一个右值引用，不是未定引用类型。</p><p>先看第一个例子，在函数模板中使用&amp;&amp;：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); </span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x); </span><br><span class="line"><span class="built_in">f1</span>(x);</span><br></pre></td></tr></table></figure><p>在上面的例子中函数模板进行了自动类型推导，需要通过传入的实参来确定参数param的实际类型。</p><ul><li>第4行中，对于f(10)来说传入的实参10是右值，因此T&amp;&amp;表示右值引用。</li><li>第6行中，对于f(x)来说传入的实参x是左值，因此T&amp;&amp;表示左值引用。</li><li>第7行中，f1(x)的参数是const T&amp;&amp;不是未定引用类型，不需要推导，本身就表示一个右值引用。</li></ul><p>再来看第二个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>, y = <span class="number">1314</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v1 = x;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v2 = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(x)&amp;&amp; v3 = y;   <span class="comment">// error</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;, v2: &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第4行中<strong>auto&amp;&amp;</strong>表示一个整形的左值引用。</li><li>第5行中<strong>auto&amp;&amp;</strong>表示一个整形的右值引用。</li><li>第6行中<strong>decltype(x)&amp;&amp;</strong>等价于<strong>int&amp;&amp;</strong>是一个右值引用不是未定义引用类型，y是一个左值，<strong>不能使用左值初始化一个右值引用类型。</strong></li></ul><p>由于上述代码存在T&amp;&amp;或者auto&amp;&amp;这种未定义引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，在进行类型推导时右值引用类型(&amp;&amp;)会发生变化，这种变化被称为引用折叠。在C++11中引用折叠规则如下：</p><ul><li><p><strong>通过右值推导T&amp;&amp;或者auto&amp;&amp;得到的是一个右值引用类型。</strong></p></li><li><p><strong>通过非右值(右值引用、左值、左值引用、常量右值引用、常量左值引用)推导T&amp;&amp;或者auto&amp;&amp;得到的是一个左值引用类型。</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; a1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb = a1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb1 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;a3 = a2;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc = a3;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc1 = a2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; s1 = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; s2 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; dd = s1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; ee = s2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li>第2行：a1为右值引用，推导出bb为左值引用类型。</li><li>第3行：5为右值，推导出的bb1为右值引用类型。</li><li>第7行：a3为左值引用，推导出的cc为左值引用。</li><li>第8行：a2为左值引用，推导出的cc1为左值引用。</li><li>第12行：s1为常量左值引用，推导出的dd为常量左值引用。</li><li>第13行：s2为常量右值引用，推导出的ee为常量右值引用。</li><li>第15行：x为右值引用，不需要推导，只能通过右值初始化。</li></ul><p>最后再看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;&amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">520</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(i);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">1314</span>);</span><br><span class="line">    forward(<span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208171011704.png" alt="image-20220817101112650"></p><p>根据测试代码可以得知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重置函数（printValue），函数 forward () 接收的是一个右值，但是在这个函数中调用函数 printValue () 时，参数 k 变成了一个命名对象，编译器会将其当做左值来处理。</p><p>最后总结以下关于&amp;&amp;的使用：</p><ul><li><strong>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</strong></li><li><strong>编译器会将已命名的右值视为左值，将未命名的右值视为右值。</strong></li><li><strong>auto&amp;&amp;或者参数类型自动类型推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型。</strong></li><li><strong>通过右值推导T&amp;&amp;或者auto&amp;&amp;得到的是一个右值引用类型，其余都是左值引用类型。</strong></li></ul><h2 id="5、std-move"><a href="#5、std-move" class="headerlink" title="5、std::move"></a>5、std::move</h2><p>在C++11中添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，<strong>使用std::move方法可以将左值转化为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样具有移动语义，将对象的状态或者所有权从一个对象移动到另一个对象上，只是转移，没有内存拷贝。</strong></p><p>从实现上讲，std::move基本等同于一个类型转换：<strong>static_cast<T&&>(lvalue)；</strong>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Ty&gt;</span></span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// forward _Arg as movable</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    Test &amp;&amp; v1 = t;          <span class="comment">// error</span></span><br><span class="line">    Test &amp;&amp; v2 = <span class="built_in">move</span>(t);    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第10行中，使用左值初始化右值引用，因此语法错误。</li><li>第11行中，使用move函数将左值转化为右值，这样就可以初始化右值引用了。</li></ul><p>假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; ls;</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">......</span><br><span class="line">list&lt;string&gt; ls1 = ls;        <span class="comment">// 需要拷贝, 效率低</span></span><br><span class="line">list&lt;string&gt; ls2 = <span class="built_in">move</span>(ls);</span><br></pre></td></tr></table></figure><p>如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权，如果一个对象内部有较大的堆内存或者动态数组时，使用move就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数<strong>(T::T(T&amp;&amp;another))</strong>和具有移动语义的赋值函数<strong>(T&amp;&amp;T::operator=(T&amp;&amp;rhs))</strong>，在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。</p><h2 id="6、std-forward"><a href="#6、std-forward" class="headerlink" title="6、std::forward"></a>6、std::forward</h2><p>右值引用类型是独立于值的，一个右值引用作为函数的形参时，在函数内部转发该参数给内部其他函数时，它就变成了一个左值，并不是原来的类型了。如果需要按照原来的类型转发到另一个函数，<strong>可以使用C++11提供的std::forward函数，该函数实现的功能称之为完美转发。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简之后的样子</span></span><br><span class="line">std::forward&lt;T&gt;(t);</span><br></pre></td></tr></table></figure><ul><li>当T为左值引用类型时，t将被转化为T类型的左值。</li><li>当T不是左值引用类型时，t将被转化为T类型的右值。</li></ul><p>下面通过一个例子演示一下关于forward的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">520</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1314</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(num);</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码的结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208171101969.png" alt="image-20220817110147910"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、右值引用的简介&quot;&gt;&lt;a href=&quot;#1、右值引用的简介&quot; class=&quot;headerlink&quot; title=&quot;1、右值引用的简介&quot;&gt;&lt;/a&gt;1、右值引用的简介&lt;/h2&gt;&lt;p&gt;C++11增加了一个新的类型，称为&lt;strong&gt;右值引用(R-value refe</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="CPP11新特性" scheme="https://jjking20010901.github.io/tags/CPP11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
</feed>
