<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakura的博客</title>
  
  <subtitle>生命不息,内卷不止</subtitle>
  <link href="https://jjking20010901.github.io/atom.xml" rel="self"/>
  
  <link href="https://jjking20010901.github.io/"/>
  <updated>2022-11-05T04:56:02.973Z</updated>
  <id>https://jjking20010901.github.io/</id>
  
  <author>
    <name>Sakura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汽车仪表盘绘制</title>
    <link href="https://jjking20010901.github.io/posts/cb2eafdb.html"/>
    <id>https://jjking20010901.github.io/posts/cb2eafdb.html</id>
    <published>2022-11-05T04:53:44.000Z</published>
    <updated>2022-11-05T04:56:02.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、汽车仪表盘效果图"><a href="#1、汽车仪表盘效果图" class="headerlink" title="1、汽车仪表盘效果图"></a>1、汽车仪表盘效果图</h2><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301516841.png" alt="image-20220830151624760"></p><p>上面是通过QPainter绘制出来的汽车仪表盘，可能与真实的汽车仪表盘有些差距，但总体来说还可以吧，下面将会详细讲解如何绘制汽车仪表盘。</p><h2 id="2、绘制前的准备"><a href="#2、绘制前的准备" class="headerlink" title="2、绘制前的准备"></a>2、绘制前的准备</h2><p>首先我们将窗体背景设置为偏黑色，这样方便我们后续观察效果，以及将窗口固定位1280*800，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1280</span>,<span class="number">800</span>);</span><br><span class="line">QPalette pale=<span class="keyword">this</span>-&gt;<span class="built_in">palette</span>();</span><br><span class="line">pale.<span class="built_in">setBrush</span>(QPalette::Window,<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>)));</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setPalette</span>(pale);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301439671.png" alt="image-20220830143915607"></p><h2 id="3、绘制刻度线"><a href="#3、绘制刻度线" class="headerlink" title="3、绘制刻度线"></a>3、绘制刻度线</h2><p>首先我们要获取仪表盘的中心点radius以及仪表盘的宽高，然后将画笔移动到窗口的中下方，移动画笔也就是移动坐标系。</p><p>然后使用QPainter中的抗锯齿的方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="type">int</span> width=<span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line">   <span class="comment">//仪表盘高度</span></span><br><span class="line">   <span class="type">int</span> height=<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()<span class="number">-100</span>;</span><br><span class="line">   <span class="comment">//仪表盘中心位置</span></span><br><span class="line">   <span class="type">int</span> radius=((width&gt;height)? height:width)/<span class="number">2</span>;</span><br><span class="line">   <span class="comment">//移动画笔到中下方</span></span><br><span class="line">   painter.<span class="built_in">translate</span>(width/<span class="number">2</span>,height*<span class="number">0.6</span>);</span><br><span class="line">   <span class="comment">//启用反锯齿</span></span><br><span class="line">   painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>接下来就是画刻度线，首先我们要组装刻度点的路径，使用QPainterPath。然后是绘制长的刻度线，大于或者等于160的刻度值为红色，其他的刻度线为白色，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//画刻度线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawSmallScale</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//组装点的路径图</span></span><br><span class="line">    QPainterPath pointPath_small;</span><br><span class="line">    pointPath_small.<span class="built_in">moveTo</span>(<span class="number">-2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">-2</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QPainterPath pointPath_big;</span><br><span class="line">    pointPath_big.<span class="built_in">moveTo</span>(<span class="number">-2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">-2</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制121个小点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">121</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="function">QPointF <span class="title">point</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        point.<span class="built_in">setX</span>(radius*<span class="built_in">qCos</span>(((<span class="number">210</span>-i*<span class="number">2</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        point.<span class="built_in">setY</span>(radius*<span class="built_in">qSin</span>(((<span class="number">210</span>-i*<span class="number">2</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        painter.<span class="built_in">translate</span>(point.<span class="built_in">x</span>(),-point.<span class="built_in">y</span>());</span><br><span class="line">        painter.<span class="built_in">rotate</span>(<span class="number">-120</span>+i*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">235</span>,<span class="number">70</span>,<span class="number">70</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPath</span>(pointPath_big);<span class="comment">//绘画大刻度</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPath</span>(pointPath_small);<span class="comment">//绘画小刻度</span></span><br><span class="line">        &#125;</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301452519.png" alt="image-20220830145212461"></p><h2 id="4、刻度数字"><a href="#4、刻度数字" class="headerlink" title="4、刻度数字"></a>4、刻度数字</h2><p>在每一个更长的刻度线上绘制对应的数字，我们要找到对应的坐标，还要设置数字的字体以及大小，而且我们还要旋转画笔，让每个对应的数字都是在正确的位置，通过角度旋转的角度来计算弧度，然后通过弧度来获取对应的坐标，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刻度数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawDigital</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置画笔，画笔默认NOPEN</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">15</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;++i)&#123;</span><br><span class="line">        <span class="function">QPointF <span class="title">point</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        point.<span class="built_in">setX</span>(radius*<span class="built_in">qCos</span>(((<span class="number">210</span>-i*<span class="number">20</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        point.<span class="built_in">setY</span>(radius*<span class="built_in">qSin</span>(((<span class="number">210</span>-i*<span class="number">20</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        painter.<span class="built_in">translate</span>(point.<span class="built_in">x</span>(),-point.<span class="built_in">y</span>());</span><br><span class="line">        painter.<span class="built_in">rotate</span>(<span class="number">-120</span>+i*<span class="number">20</span>);</span><br><span class="line">        painter.<span class="built_in">drawText</span>(<span class="number">-25</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">20</span>,Qt::AlignCenter,QString::<span class="built_in">number</span>(i*<span class="number">20</span>));</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还原画笔</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301459646.png" alt="image-20220830145901581"></p><h2 id="5、绘制发光的圆圈"><a href="#5、绘制发光的圆圈" class="headerlink" title="5、绘制发光的圆圈"></a>5、绘制发光的圆圈</h2><p>在刻度线的四周绘制一种渐变色的发光圆圈，首先我们要创建大小圆的弧圈，通过arcTo方法，然后在小圆中绘制椭圆，通过addEllipse，然后通过QRadialGradient设置渐变色，最后通过drawPath方法获取大圆减小圆之后的路径，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath outRing;</span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    outRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    outRing.<span class="built_in">arcTo</span>(-radius,-radius, <span class="number">2</span>*radius,<span class="number">2</span>*radius,<span class="number">-30</span>,<span class="number">240</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    outRing.<span class="built_in">closeSubpath</span>();</span><br><span class="line">    <span class="comment">//设置渐变色k</span></span><br><span class="line">    <span class="function">QRadialGradient <span class="title">radialGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,radius,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">1</span>,<span class="built_in">QColor</span>(<span class="number">0</span>,<span class="number">82</span>,<span class="number">230</span>));</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">0.9</span>,Qt::transparent);</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(radialGradient);</span><br><span class="line">    <span class="comment">//大圆减小圆</span></span><br><span class="line">    painter.<span class="built_in">drawPath</span>(outRing.<span class="built_in">subtracted</span>(inRing));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301504164.png" alt="image-20220830150437094"></p><h2 id="6、绘制指针"><a href="#6、绘制指针" class="headerlink" title="6、绘制指针"></a>6、绘制指针</h2><p>和之前一样我们要组装点的路径，然后是计算点的坐标，这些都可以自己慢慢的试试，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawPointer</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//组装点的路径图</span></span><br><span class="line">    QPainterPath pointPath;</span><br><span class="line">    pointPath.<span class="built_in">moveTo</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">1</span>,-radius);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">-1</span>,-radius);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">-10</span>,<span class="number">0</span>);</span><br><span class="line">    pointPath.<span class="built_in">arcTo</span>(<span class="number">-10</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">180</span>,<span class="number">180</span>);</span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(<span class="number">-5</span>,<span class="number">-5</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算并选择绘图对象坐标</span></span><br><span class="line">    painter.<span class="built_in">rotate</span>(degRotate - <span class="number">120</span>);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(pointPath.<span class="built_in">subtracted</span>(inRing));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301508886.png" alt="image-20220830150828813"></p><h2 id="7、绘制中间大圆、小圆以及发光内圈"><a href="#7、绘制中间大圆、小圆以及发光内圈" class="headerlink" title="7、绘制中间大圆、小圆以及发光内圈"></a>7、绘制中间大圆、小圆以及发光内圈</h2><p>绘制大圆的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_big</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(inRing);</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制小圆的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_small</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(inRing);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制发光内圈的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_shine</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="function">QRadialGradient <span class="title">radialGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,radius,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//    radialGradient.setColorAt(0.5,QColor(8,77,197));</span></span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">0.5</span>,<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">68</span>,<span class="number">185</span>,<span class="number">150</span>));</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">1.0</span>,Qt::transparent);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QBrush</span>(radialGradient));</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(-radius,-radius,<span class="number">2</span>*(radius),<span class="number">2</span>*(radius));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301513631.png" alt="image-20220830151303554"></p><h2 id="8、绘制单位和时速"><a href="#8、绘制单位和时速" class="headerlink" title="8、绘制单位和时速"></a>8、绘制单位和时速</h2><p>绘制速度单位的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawUnit</span><span class="params">(QPainter &amp; painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">16</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-50</span>, -radius, <span class="number">100</span>, <span class="number">20</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;km/h&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-60</span>, -radius + <span class="number">130</span>, <span class="number">120</span>, <span class="number">40</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;当前车速&quot;</span>));</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">50</span>));</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-120</span>, -radius + <span class="number">280</span>, <span class="number">250</span>, <span class="number">40</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;-请按space键加速-&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制时速的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawNum</span><span class="params">(QPainter &amp; painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">45</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-75</span>, -radius - <span class="number">20</span>, <span class="number">150</span>, <span class="number">100</span>,Qt::AlignCenter,QString::<span class="built_in">number</span>(degRotate));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301515543.png" alt="image-20220830151543465"></p><h2 id="9、键盘事件和鼠标事件控制车速"><a href="#9、键盘事件和鼠标事件控制车速" class="headerlink" title="9、键盘事件和鼠标事件控制车速"></a>9、键盘事件和鼠标事件控制车速</h2><p>首先我们需要定义一个定时器timer，然后先将以下键盘事件，我们定义一个direction和degRotate，direction为0时代表减速或者车速为0，为1代表加速，degRotate代表车速，一开始为0。</p><p>当我们按下空格键时，定时器开始，同样的direction变为1，当定时器超时的时候，执行槽函数speed_changed。</p><p>下面是键盘按下事件的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>()==Qt::Key_Space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">            direction=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是槽函数speed_changed的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::speed_changed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(direction == <span class="number">1</span>)<span class="comment">//加速</span></span><br><span class="line">    &#123;</span><br><span class="line">        degRotate++;</span><br><span class="line">        <span class="keyword">if</span>(degRotate &gt; <span class="number">240</span>)</span><br><span class="line">            degRotate = <span class="number">240</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(direction == <span class="number">0</span>)<span class="comment">//减速</span></span><br><span class="line">    &#123;</span><br><span class="line">        degRotate--;</span><br><span class="line">        <span class="keyword">if</span>(degRotate &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            degRotate = <span class="number">0</span>;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们松开空格键时，direction为0，开始减速。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyReleaseEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>()==Qt::Key_Space)</span><br><span class="line">    &#123;</span><br><span class="line">        direction=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是鼠标点击事件和鼠标松开事件，当我们点击鼠标时，车速增加，松开时车速减少。</p><p>鼠标点击事件代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            is_Pressed=<span class="literal">true</span>;</span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">            direction=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标松开事件代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line">    is_Pressed=<span class="literal">false</span>;</span><br><span class="line">    direction=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、代码获取"><a href="#10、代码获取" class="headerlink" title="10、代码获取"></a>10、代码获取</h2><p>我已经将代码推送到了gitee上面了，想要源码的可以通过下方链接获取：</p><p><a href="https://gitee.com/GoodNightZoe/car-board.git">汽车仪表盘</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、汽车仪表盘效果图&quot;&gt;&lt;a href=&quot;#1、汽车仪表盘效果图&quot; class=&quot;headerlink&quot; title=&quot;1、汽车仪表盘效果图&quot;&gt;&lt;/a&gt;1、汽车仪表盘效果图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubuserconten</summary>
      
    
    
    
    <category term="QtWidget" scheme="https://jjking20010901.github.io/categories/QtWidget/"/>
    
    
    <category term="QtWidget自绘" scheme="https://jjking20010901.github.io/tags/QtWidget%E8%87%AA%E7%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>右值引用和完美转发</title>
    <link href="https://jjking20010901.github.io/posts/eaeeda04.html"/>
    <id>https://jjking20010901.github.io/posts/eaeeda04.html</id>
    <published>2022-11-04T09:09:13.000Z</published>
    <updated>2022-11-05T04:54:30.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、右值引用的简介"><a href="#1、右值引用的简介" class="headerlink" title="1、右值引用的简介"></a>1、右值引用的简介</h2><p>C++11增加了一个新的类型，称为<strong>右值引用(R-value reference)</strong>，标记为 <strong>&amp;&amp;。</strong>在介绍右值引用类型之前要先了解什么是左值和右值：</p><ul><li>lvalue是<strong>locator value</strong>的缩写，rvalue是 <strong>read value</strong>的缩写。</li><li>左值是指<strong>存储在内存中、有明确存储地址(可取地址)的数据。</strong></li><li>右值是指<strong>可以提供数据值的数据(不可取地址)。</strong></li></ul><p>通过描述可以看出，区分左值与右值的便捷方法是：<strong>可以对表达式取地址(&amp;)就是左值，否则为右值。</strong></p><p>所有有名字的变量或者对象都是左值，而右值是匿名的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1314</span>;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><p>一般情况下，位于 = 前面的表达式为左值，位于 = 后边的表达式为右值。也就是说例子中的a,b为左值，520,1314为右值。a=b是一种特殊情况，在这个表达式中a，b都是左值，因为变量b是可以被取地址的，不能视为右值。</p><p>C++11中右值可以分为两种：一个是将亡值，另一个则是纯右值：</p><ul><li><strong>纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambada表达式等。</strong></li><li><strong>将亡值：与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值、std::move的返回值等。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">520</span>;</span><br></pre></td></tr></table></figure><p>上面语句中的value为左值，520为字面量也就是右值。其中value可以被引用，但是520就不行了，因为字面量都是右值。</p><h2 id="2、右值引用的使用"><a href="#2、右值引用的使用" class="headerlink" title="2、右值引用的使用"></a>2、右值引用的使用</h2><p>右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用它的方式找到它。<strong>无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又”重获新生”。</strong></p><p>其生命周期与右值引用类型变量的声明周期一样，只要该变量还活着，该右值临时量将会一直存活下去。</p><p>关于右值引用的使用，参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; value = <span class="number">520</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1;</span><br><span class="line">    <span class="type">int</span> &amp;&amp;a2 = a1;        <span class="comment">// error</span></span><br><span class="line">    Test&amp; t = <span class="built_in">getObj</span>();   <span class="comment">// error</span></span><br><span class="line">    Test &amp;&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="type">const</span> Test&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上面的例子中<strong>int &amp;&amp;value=520;</strong>里面的520为纯右值，<strong>value</strong>是字面量<strong>520</strong>这个右值的引用。</li><li>在<strong>int &amp;&amp;a2=a1</strong>中；<strong>a1</strong>虽然写在<strong>=</strong>的右边，但是它仍然是一个左值，使<strong>用左值初始化一个右值引用是不合法的。</strong></li><li><strong>Test &amp; t=getObj()</strong>这段代码语法是错误的，<strong>右值不能给普通的左值引用赋值。</strong></li><li><strong>Test &amp;&amp; t=getObj()</strong>中getObj()返回的<strong>临时对象称为将亡值，t是这个将亡值的右值引用。</strong></li><li><strong>const Test &amp; t=getObj()</strong>这段代码语法是正确的，<strong>常量左值引用是一个万能的引用类型，它可以接受左值、右值、常量左值和常量右值。</strong></li></ul><h2 id="3、性能优化"><a href="#3、性能优化" class="headerlink" title="3、性能优化"></a>3、性能优化</h2><p>在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能优化。</p><p>修改以下上面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_num: &quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208161702687.png" alt="image-20220816170224552"></p><p>通过输出结果我们可以看到调用Test t=getObj()的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到对象t，在getObj()函数中创建的对象虽然进行了内存申请操作，但是没有使用就释放掉了。如果能够使用临时对象已经申请的资源，既能节省资源，还能节省申请和释放的时间，如果要执行这样的操作就需要使用右值引用了。</p><p><strong>右值引用具有移动语义，移动语义可将资源(堆、系统对象等)通过浅拷贝从一个对象转义到另一个对象这样就能减少不必要的临时对象的创建、拷贝及销毁，可以大幅度提高C++应用程序的性能。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加移动构造函数</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">m_num</span>(a.m_num)</span><br><span class="line">    &#123;</span><br><span class="line">        a.m_num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct: my name is sunny&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test class ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_num: &quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码执行结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208161712211.png" alt="image-20220816171225155"></p><p>通过修改，在上面的代码给Test类添加了<strong>移动构造函数(参数为右值引用类型)，</strong>这样在进行Test t=getObj()操作时候并没有调用拷贝构造函数进行深拷贝，而是调用移动构造函数，这个函数中只是进行了浅拷贝，没有对临时对象进行深拷贝，提高性能。</p><p>如果不使用移动构造，在执行Test t=getObj()时候也是进行浅拷贝，但是临时对象被析构的时候，类成员指针int *m_num指向的内存也就被析构了，对象t也就无法访问这块内存地址了。</p><p>在测试程序中getObj()的返回值就是一个将亡值，也就是一个右值，在进行赋值操作的时候如果右边是一个右值，那么移动构造就会被调用。<strong>移动构造中使用了右值引用，会将临时对象的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。</strong></p><p><strong>注意：</strong></p><p><strong>对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数。</strong></p><h2 id="4、-amp-amp-的特性"><a href="#4、-amp-amp-的特性" class="headerlink" title="4、&amp;&amp;的特性"></a>4、&amp;&amp;的特性</h2><p>在 C++ 中，并不是所有情况下 <strong>&amp;&amp; 都代表是一个右值引用，</strong>具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为 T&amp;&amp;，如果是自动类型推导需要指定为 auto &amp;&amp;，在这两种场景下 &amp;&amp; 被称作未定的引用类型。另外还有一点需要额外注意 const T&amp;&amp; 表示一个右值引用，不是未定引用类型。</p><p>先看第一个例子，在函数模板中使用&amp;&amp;：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); </span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x); </span><br><span class="line"><span class="built_in">f1</span>(x);</span><br></pre></td></tr></table></figure><p>在上面的例子中函数模板进行了自动类型推导，需要通过传入的实参来确定参数param的实际类型。</p><ul><li>第4行中，对于f(10)来说传入的实参10是右值，因此T&amp;&amp;表示右值引用。</li><li>第6行中，对于f(x)来说传入的实参x是左值，因此T&amp;&amp;表示左值引用。</li><li>第7行中，f1(x)的参数是const T&amp;&amp;不是未定引用类型，不需要推导，本身就表示一个右值引用。</li></ul><p>再来看第二个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>, y = <span class="number">1314</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v1 = x;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v2 = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(x)&amp;&amp; v3 = y;   <span class="comment">// error</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;, v2: &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第4行中<strong>auto&amp;&amp;</strong>表示一个整形的左值引用。</li><li>第5行中<strong>auto&amp;&amp;</strong>表示一个整形的右值引用。</li><li>第6行中<strong>decltype(x)&amp;&amp;</strong>等价于<strong>int&amp;&amp;</strong>是一个右值引用不是未定义引用类型，y是一个左值，<strong>不能使用左值初始化一个右值引用类型。</strong></li></ul><p>由于上述代码存在T&amp;&amp;或者auto&amp;&amp;这种未定义引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，在进行类型推导时右值引用类型(&amp;&amp;)会发生变化，这种变化被称为引用折叠。在C++11中引用折叠规则如下：</p><ul><li><p><strong>通过右值推导T&amp;&amp;或者auto&amp;&amp;得到的是一个右值引用类型。</strong></p></li><li><p><strong>通过非右值(右值引用、左值、左值引用、常量右值引用、常量左值引用)推导T&amp;&amp;或者auto&amp;&amp;得到的是一个左值引用类型。</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; a1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb = a1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb1 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;a3 = a2;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc = a3;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc1 = a2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; s1 = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; s2 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; dd = s1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; ee = s2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li>第2行：a1为右值引用，推导出bb为左值引用类型。</li><li>第3行：5为右值，推导出的bb1为右值引用类型。</li><li>第7行：a3为左值引用，推导出的cc为左值引用。</li><li>第8行：a2为左值引用，推导出的cc1为左值引用。</li><li>第12行：s1为常量左值引用，推导出的dd为常量左值引用。</li><li>第13行：s2为常量右值引用，推导出的ee为常量右值引用。</li><li>第15行：x为右值引用，不需要推导，只能通过右值初始化。</li></ul><p>最后再看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;&amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">520</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(i);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">1314</span>);</span><br><span class="line">    forward(<span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208171011704.png" alt="image-20220817101112650"></p><p>根据测试代码可以得知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重置函数（printValue），函数 forward () 接收的是一个右值，但是在这个函数中调用函数 printValue () 时，参数 k 变成了一个命名对象，编译器会将其当做左值来处理。</p><p>最后总结以下关于&amp;&amp;的使用：</p><ul><li><strong>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</strong></li><li><strong>编译器会将已命名的右值视为左值，将未命名的右值视为右值。</strong></li><li><strong>auto&amp;&amp;或者参数类型自动类型推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型。</strong></li><li><strong>通过右值推导T&amp;&amp;或者auto&amp;&amp;得到的是一个右值引用类型，其余都是左值引用类型。</strong></li></ul><h2 id="5、std-move"><a href="#5、std-move" class="headerlink" title="5、std::move"></a>5、std::move</h2><p>在C++11中添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，<strong>使用std::move方法可以将左值转化为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样具有移动语义，将对象的状态或者所有权从一个对象移动到另一个对象上，只是转移，没有内存拷贝。</strong></p><p>从实现上讲，std::move基本等同于一个类型转换：<strong>static_cast<T&&>(lvalue)；</strong>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Ty&gt;</span></span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// forward _Arg as movable</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    Test &amp;&amp; v1 = t;          <span class="comment">// error</span></span><br><span class="line">    Test &amp;&amp; v2 = <span class="built_in">move</span>(t);    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第10行中，使用左值初始化右值引用，因此语法错误。</li><li>第11行中，使用move函数将左值转化为右值，这样就可以初始化右值引用了。</li></ul><p>假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; ls;</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">......</span><br><span class="line">list&lt;string&gt; ls1 = ls;        <span class="comment">// 需要拷贝, 效率低</span></span><br><span class="line">list&lt;string&gt; ls2 = <span class="built_in">move</span>(ls);</span><br></pre></td></tr></table></figure><p>如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权，如果一个对象内部有较大的堆内存或者动态数组时，使用move就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数<strong>(T::T(T&amp;&amp;another))</strong>和具有移动语义的赋值函数<strong>(T&amp;&amp;T::operator=(T&amp;&amp;rhs))</strong>，在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。</p><h2 id="6、std-forward"><a href="#6、std-forward" class="headerlink" title="6、std::forward"></a>6、std::forward</h2><p>右值引用类型是独立于值的，一个右值引用作为函数的形参时，在函数内部转发该参数给内部其他函数时，它就变成了一个左值，并不是原来的类型了。如果需要按照原来的类型转发到另一个函数，<strong>可以使用C++11提供的std::forward函数，该函数实现的功能称之为完美转发。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简之后的样子</span></span><br><span class="line">std::forward&lt;T&gt;(t);</span><br></pre></td></tr></table></figure><ul><li>当T为左值引用类型时，t将被转化为T类型的左值。</li><li>当T不是左值引用类型时，t将被转化为T类型的右值。</li></ul><p>下面通过一个例子演示一下关于forward的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">520</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1314</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(num);</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码的结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208171101969.png" alt="image-20220817110147910"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、右值引用的简介&quot;&gt;&lt;a href=&quot;#1、右值引用的简介&quot; class=&quot;headerlink&quot; title=&quot;1、右值引用的简介&quot;&gt;&lt;/a&gt;1、右值引用的简介&lt;/h2&gt;&lt;p&gt;C++11增加了一个新的类型，称为&lt;strong&gt;右值引用(R-value refe</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="CPP11新特性" scheme="https://jjking20010901.github.io/tags/CPP11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
</feed>
