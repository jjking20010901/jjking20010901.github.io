<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakura的博客</title>
  
  <subtitle>乐观和热爱才是生活的解药</subtitle>
  <link href="https://jjking20010901.github.io/atom.xml" rel="self"/>
  
  <link href="https://jjking20010901.github.io/"/>
  <updated>2022-11-23T11:11:18.655Z</updated>
  <id>https://jjking20010901.github.io/</id>
  
  <author>
    <name>Sakura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>条件变量</title>
    <link href="https://jjking20010901.github.io/posts/85bac27c.html"/>
    <id>https://jjking20010901.github.io/posts/85bac27c.html</id>
    <published>2022-11-23T11:10:30.000Z</published>
    <updated>2022-11-23T11:11:18.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、std-condition-variable"><a href="#1、std-condition-variable" class="headerlink" title="1、std::condition_variable"></a>1、std::condition_variable</h2><p><strong>条件变量是 C++11 提供的另外一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时时，才会唤醒当前阻塞的线程。条件变量需要和互斥量配合起来使用。</strong></p><h3 id="1-1、条件变量：等待被唤醒"><a href="#1-1、条件变量：等待被唤醒" class="headerlink" title="1.1、条件变量：等待被唤醒"></a>1.1、条件变量：等待被唤醒</h3><p>std::condition_variable中的wait()方法会让当前线程陷入等待状态，在其他线程中调用notify_one()方法则会唤醒陷入等待的线程。</p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">条件变量类似于信号量，只有某个事件发生，这个线程才能执行。</span></span><br><span class="line"><span class="comment">条件变量等待被唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt;ulock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//等待cv上发生的事件,让当前线程陷入等待</span></span></span></span><br><span class="line"><span class="params"><span class="function">cv.wait(ulock);</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;thread awake...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">400</span>));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;notifying...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//唤醒陷入等待的线程</span></span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2、条件变量：等待某一条件为真"><a href="#1-2、条件变量：等待某一条件为真" class="headerlink" title="1.2、条件变量：等待某一条件为真"></a>1.2、条件变量：等待某一条件为真</h3><p>std::condition_variable中的wait()方法除了传入锁之后，还可以传入一个lambda表达式，lambda表达式返回值为true时，才会唤醒线程，否则继续等待。</p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">条件变量等待某一条件为真，才能被唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt;grd(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cv.wait(grd, [&amp;]() &#123;<span class="keyword">return</span> ready; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">grd.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;thread is awake....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">400</span>));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;notifying is not ready...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;notifying is ready&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3、条件变量：多个等待者"><a href="#1-3、条件变量：多个等待者" class="headerlink" title="1.3、条件变量：多个等待者"></a>1.3、条件变量：多个等待者</h3><p>std::condition_variable中的notify_one()方法只会唤醒其中一个等待中的线程，而notify_all()方法则会唤醒所有等待的线程。</p><p>这就是为什么wait需要传入unique_lock作为参数，因为我们要保证多个线程被唤醒，但只有一个线程执行，其他线程需要等待那个线程解锁后再执行。</p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">条件变量：多个等待者</span></span><br><span class="line"><span class="comment">notify_one只会唤醒其中的一个等待的线程，而notify_all会唤醒所有等待的线程。</span></span><br><span class="line"><span class="comment">这也解释了为什么wait需要一个unique_lock作为参数。</span></span><br><span class="line"><span class="comment">因为可能同一时间出现多个线程（相当于消息队列），确保线程1执行时，其他线程不会执行，</span></span><br><span class="line"><span class="comment">只有当线程1解锁后，其他线程才能执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt;grd(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cv.wait(grd);</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;t1 is awake...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt;grd(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cv.wait(grd);</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;t2 is awake...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt;grd(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cv.wait(grd);</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;t3 is awake...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">400</span>));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;notifying one&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">400</span>));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;notifying all&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">t3.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、实现生产者-消费者模式"><a href="#2、实现生产者-消费者模式" class="headerlink" title="2、实现生产者-消费者模式"></a>2、实现生产者-消费者模式</h2><p>生产者-消费者模式类似于消息队列，生产者：厨师，向foods队列中推送食物，推送后会通知消费者用餐。</p><p>消费者：等待foods队列中推送的食物，没有食物则会陷入等待，直到被通知。</p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">模拟生产者-消费者模式，类似于消息队列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;foods;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt;grd(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cv.wait(grd, [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> foods.size() != <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">auto</span> ret = foods.back();</span></span></span><br><span class="line"><span class="params"><span class="function">foods.pop_back();</span></span></span><br><span class="line"><span class="params"><span class="function">grd.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;t1 get foods:&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt;grd(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cv.wait(grd, [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> foods.size() != <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">auto</span> ret = foods.back();</span></span></span><br><span class="line"><span class="params"><span class="function">foods.pop_back();</span></span></span><br><span class="line"><span class="params"><span class="function">grd.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;t2 get foods:&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">foods.<span class="built_in">push_back</span>(<span class="number">45</span>);</span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br><span class="line">foods.<span class="built_in">push_back</span>(<span class="number">255</span>);</span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">foods.<span class="built_in">push_back</span>(<span class="number">333</span>);</span><br><span class="line">foods.<span class="built_in">push_back</span>(<span class="number">4398</span>);</span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、实现多线程安全消息队列"><a href="#3、实现多线程安全消息队列" class="headerlink" title="3、实现多线程安全消息队列"></a>3、实现多线程安全消息队列</h2><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义多线程安全的消息队列容器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MTQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt;<span class="built_in">grd</span>(m_mtx);</span><br><span class="line">m_cv.<span class="built_in">wait</span>(grd, [&amp;]() &#123;</span><br><span class="line"><span class="keyword">return</span> !m_vec.<span class="built_in">empty</span>();</span><br><span class="line">&#125;);</span><br><span class="line">T ret = std::<span class="built_in">move</span>(m_vec.<span class="built_in">back</span>());</span><br><span class="line">m_vec.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//推1个数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt;<span class="built_in">grd</span>(m_mtx);</span><br><span class="line">m_vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">m_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//推多个数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 C++ 的 STL 容器中，可以进行任意长度的数据的初始化，</span></span><br><span class="line"><span class="comment">使用初始化列表也只能进行固定参数的初始化，如果想要做到和 STL 一样有任意长度初始化的能力，</span></span><br><span class="line"><span class="comment">可以使用 std::initializer_list 这个轻量级的类模板来实现。</span></span><br><span class="line"><span class="comment">如果要把一个序列（sequence）拷贝到一个容器（container）中去，通常用std::copy算法。</span></span><br><span class="line"><span class="comment">C++17语法：</span></span><br><span class="line"><span class="comment">std::back_insert_iterator:构造向尾端插入的插入迭代器，可以通过该迭代器对容器插入元素。</span></span><br><span class="line"><span class="comment">std::move_iterator:移动迭代器，其可以实现以移动而非复制的方式，将某个区域空间中的元素移动至另一个指定的空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_many</span><span class="params">(std::initializer_list&lt;T&gt;vals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt;<span class="built_in">grd</span>(m_mtx);</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">move_iterator</span>(vals.<span class="built_in">begin</span>()),</span><br><span class="line">std::<span class="built_in">move_iterator</span>(vals.<span class="built_in">end</span>()),</span><br><span class="line">std::<span class="built_in">back_insert_iterator</span>(m_vec));</span><br><span class="line"><span class="comment">//std::copy(vals.begin(), vals.end(), m_vec);</span></span><br><span class="line">m_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;T&gt;m_vec;</span><br><span class="line">std::mutex m_mtx;</span><br><span class="line">std::condition_variable m_cv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MTQueue&lt;<span class="type">int</span>&gt;foods;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">auto</span> food = foods.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;t1 get foods:&quot;</span> &lt;&lt; food &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">auto</span> food = foods.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;t2 get foods:&quot;</span> &lt;&lt; food &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">foods.<span class="built_in">push</span>(<span class="number">44</span>);</span><br><span class="line">foods.<span class="built_in">push</span>(<span class="number">523</span>);</span><br><span class="line">foods.<span class="built_in">push_many</span>(&#123; <span class="number">4399</span>,<span class="number">6666</span> &#125;);</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：上述代码中的move_iterator(移动迭代器)和back_insert_iterator(尾端插入迭代器)是C++17新特性，而vs2019默认支持C++11，所以在项目属性中修改以下语言的特性即可。</strong></p><p><strong>std::condition_variable小贴士：</strong></p><ul><li><strong>std::condition_variable仅仅支持std::unique_lock的锁作为wait()方法的参数，如果需要其他类型的锁，可用std::condition_variable_any。</strong></li><li><strong>它还有wait_for()和wait_until()等方法分别接受chrono时间段和时间点作为参数。</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、std-condition-variable&quot;&gt;&lt;a href=&quot;#1、std-condition-variable&quot; class=&quot;headerlink&quot; title=&quot;1、std::condition_variable&quot;&gt;&lt;/a&gt;1、std::condit</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++11多线程" scheme="https://jjking20010901.github.io/tags/C-11%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>互斥量</title>
    <link href="https://jjking20010901.github.io/posts/f5aad139.html"/>
    <id>https://jjking20010901.github.io/posts/f5aad139.html</id>
    <published>2022-11-23T02:27:43.000Z</published>
    <updated>2022-11-23T02:29:29.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、数据竞争"><a href="#1、数据竞争" class="headerlink" title="1、数据竞争"></a>1、数据竞争</h2><p>两个线程试图向同一个数组中放数据，程序直接崩溃，这是为什么呢？</p><p>假设vector容器长度为4，但是现在线程1想要额外追加数据，那么我们就要扩充vector容器的长度，然后就把长度为4的vector给delete掉了，然后线程2也看到了长度为4的vector，它的想法和线程1一样，也想扩充vector，然后也把长度为4的vector给delete掉了。</p><p>那么此时出现了double delete现象，导致内存泄漏，程序崩溃，所以vector不是多线程安全容器。</p><p>多线程下同时访问同一个vector会出现数据竞争的现象。</p><h2 id="2、std-mutex"><a href="#2、std-mutex" class="headerlink" title="2、std::mutex"></a>2、std::mutex</h2><p>数据竞争这个问题的解决方法是通过std::mutex。我们通过上锁防止多个线程同时进入某一个代码段。</p><p>当我们调用std::mutex的lock()方法时，会检查mutex是否上锁，如果没有上锁，那么mutex会进行上锁。</p><p>若已经上锁，则会陷入等待状态，直到mutex被另一个线程解锁，才可以再次上锁。而调用unlock()方法可以进行解锁。</p><p><strong>这样，可以确保lock()方法与unlock()方法之间的代码，在同一时间只有一个线程在执行，从而避免数据竞争。</strong></p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并发 指单个cpu同时处理多个线程任务，cpu在反复切换任务线程，实际还是串行化的；</span></span><br><span class="line"><span class="comment">并行 指多个cpu同时处理多个线程任务，cpu可以同时处理不同的任务，异步处理；</span></span><br><span class="line"><span class="comment">互斥量：多个线程访问同一个数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多线程打架：</span></span><br><span class="line"><span class="comment">两个线程试图往一个线程中传递数据。程序直接崩溃。</span></span><br><span class="line"><span class="comment">vector不是多线程安全容器。</span></span><br><span class="line"><span class="comment">因为多个线程同时访问一个vector会出现数据竞争的现象。</span></span><br><span class="line"><span class="comment">解决方法：</span></span><br><span class="line"><span class="comment">我们可以通过mutex上锁，防止多个线程同时进入同一个vector</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">/*</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">lock与unlock是上锁和解锁，它们的作用是确保在同一时间只有一个线程在执行，</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">从而避免数据竞争。</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">mtx.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">v.push_back(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">mtx.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">mtx.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">v.push_back(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">mtx.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、std-lock-guard"><a href="#3、std-lock-guard" class="headerlink" title="3、std::lock_guard"></a>3、std::lock_guard</h2><p>若我们忘记解锁，那么程序会出bug，为了确保我们忘记解锁，程序依旧不会出错，我们可以通过使用std::lock_guard，它会自动帮助我们解锁，符合RALL原则。</p><p>我们可以将锁视为一种资源，上锁即为获取，解锁即为释放。</p><p><strong>std::lock_guard就是这样的一个工具类，它的构造函数会调用lock()方法，析构函数会调用unlock()方法，从而退出函数作用域时会自动解锁。</strong></p><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并发 指单个cpu同时处理多个线程任务，cpu在反复切换任务线程，实际还是串行化的；</span></span><br><span class="line"><span class="comment">并行 指多个cpu同时处理多个线程任务，cpu可以同时处理不同的任务，异步处理；</span></span><br><span class="line"><span class="comment">互斥量：多个线程访问同一个数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们可以将锁视为一种资源，上锁即获取，解锁即为释放。</span></span><br><span class="line"><span class="comment">std::lock_guard它的构造函数会调用上锁，而它的析构函数会调用解锁，</span></span><br><span class="line"><span class="comment">也就是说在退出函数作用域时就会自动帮助我们解锁，从而避免我们忘记解锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::lock_guard&lt;std::mutex&gt;grd(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">v.push_back(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::lock_guard&lt;std::mutex&gt;grd(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">v.push_back(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、std-unique-lock"><a href="#4、std-unique-lock" class="headerlink" title="4、std::unique_lock"></a>4、std::unique_lock</h2><p>上面的std::lock_guard有一个问题，就是无法提前解锁，它只会在析构时调用unlock()，但是我们有时想要提前解锁，<strong>这时候我们可以使用自由度更高的unique_lock</strong>。</p><p>unique_lock他额外存储了一个flag表示是否已经释放，它会在析构时检测这个flag，如果没有释放，则调用unlock()，否则不调用。</p><p><strong>然后我们还可以直接调用unlock()提前解锁，若忘记解锁也没关系，它会自动判断是否解锁，当退出函数作用域时，自动解锁。</strong></p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并发 指单个cpu同时处理多个线程任务，cpu在反复切换任务线程，实际还是串行化的；</span></span><br><span class="line"><span class="comment">并行 指多个cpu同时处理多个线程任务，cpu可以同时处理不同的任务，异步处理；</span></span><br><span class="line"><span class="comment">互斥量：多个线程访问同一个数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">std::unique_lock它的自由度更高，它可以在中途解锁。</span></span><br><span class="line"><span class="comment">当std::lock_guard在调用析构函数的unlock时，这时我们希望提前unlock，</span></span><br><span class="line"><span class="comment">然后我们就可以使用unique_lock，它额外存储了一个flag表示是否已经被释放，</span></span><br><span class="line"><span class="comment">它会在析构时，检测这个flag，如果没有释放则会调用unlock，否则不调用。</span></span><br><span class="line"><span class="comment">我们可以直接调用unique中的unlock进行提前解锁，即便忘记解锁，退出作用域时，</span></span><br><span class="line"><span class="comment">它会自动检测是否要不要解锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt;u(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">v.push_back(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt;u(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">v.push_back(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">u.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//u.lock();//如果需要可以上锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、死锁"><a href="#5、死锁" class="headerlink" title="5、死锁"></a>5、死锁</h2><p>由于同时执行的两个线程，它们中发生的指令不一定是同步的，因此有可能出现这种情况：</p><p>线程1中的mutex1执行上锁，线程2的mutex2执行上锁，</p><p>线程1中的mutex2执行上锁，失败，陷入等待，线程2执行mutex1上锁，失败，陷入等待。</p><p>双方都在等待对方释放锁，但是因为等待而无法释放锁，从而要无限制等待下去，这种现象称为死锁。</p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并发 指单个cpu同时处理多个线程任务，cpu在反复切换任务线程，实际还是串行化的；</span></span><br><span class="line"><span class="comment">并行 指多个cpu同时处理多个线程任务，cpu可以同时处理不同的任务，异步处理；</span></span><br><span class="line"><span class="comment">互斥量：多个线程访问同一个数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mtx1;</span><br><span class="line">    std::mutex mtx2;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁的解决方法1：保证双方上锁的顺序一致。</p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并发 指单个cpu同时处理多个线程任务，cpu在反复切换任务线程，实际还是串行化的；</span></span><br><span class="line"><span class="comment">并行 指多个cpu同时处理多个线程任务，cpu可以同时处理不同的任务，异步处理；</span></span><br><span class="line"><span class="comment">互斥量：多个线程访问同一个数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mtx1;</span><br><span class="line">    std::mutex mtx2;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>死锁的解决方法2：使用std::lock同时上多个锁。</p><p>如果没办法保证上锁的顺序一致，可以使用std::lock，一次性对多个mutex上锁。</p><p>它接受任意多个mutex作为参数，并且保证在无论任意线程中调用的顺序是否相同，都不会产生死锁问题。</p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并发 指单个cpu同时处理多个线程任务，cpu在反复切换任务线程，实际还是串行化的；</span></span><br><span class="line"><span class="comment">并行 指多个cpu同时处理多个线程任务，cpu可以同时处理不同的任务，异步处理；</span></span><br><span class="line"><span class="comment">互斥量：多个线程访问同一个数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mtx1;</span><br><span class="line">    std::mutex mtx2;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::lock(mtx1,mtx2);</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::lock(mtx2,mtx1);</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx2.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁的解决办法3：std::scoped_lock。</p><p>在上述代码中，如果我们忘记解锁那么就无法释放资源，就会导致内存泄漏。</p><p>所以为了不用手动释放，我们可以使用std::scoped_lock，它可以自动帮助我们上锁和解锁。</p><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并发 指单个cpu同时处理多个线程任务，cpu在反复切换任务线程，实际还是串行化的；</span></span><br><span class="line"><span class="comment">并行 指多个cpu同时处理多个线程任务，cpu可以同时处理不同的任务，异步处理；</span></span><br><span class="line"><span class="comment">互斥量：多个线程访问同一个数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mtx1;</span><br><span class="line">    std::mutex mtx2;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::scoped_lock grd(mtx1,mtx2);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//do something</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::scoped_lock grd(mtx2,mtx1);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//do something</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：std::scoped_lock(区域锁)是C++17中的具有隐式类模板参数推导机制，传入构造函数的对象自动匹配。</strong></p><p><strong>在vs2019中默认C++标准是C++11，所以我们要更改测试代码的C++标准，将其改为C++17才可以使用它。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、数据竞争&quot;&gt;&lt;a href=&quot;#1、数据竞争&quot; class=&quot;headerlink&quot; title=&quot;1、数据竞争&quot;&gt;&lt;/a&gt;1、数据竞争&lt;/h2&gt;&lt;p&gt;两个线程试图向同一个数组中放数据，程序直接崩溃，这是为什么呢？&lt;/p&gt;
&lt;p&gt;假设vector容器长度为4，</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++11多线程" scheme="https://jjking20010901.github.io/tags/C-11%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Qt实现TCP网络通信</title>
    <link href="https://jjking20010901.github.io/posts/78159c9e.html"/>
    <id>https://jjking20010901.github.io/posts/78159c9e.html</id>
    <published>2022-11-20T02:45:06.000Z</published>
    <updated>2022-11-20T02:47:01.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在标准C++中没有提供专门用于套接字通信的类，所以只能使用操作系统提供的基于C语言的API函数，基于这些C的API函数我们也可以封装自己的C++类。或者我们可以使用Qt框架，它提供了用于套接字通信的类(TCP、UDP)这样我们就可以直接调用相关API即可。</p><p>使用Qt提供的类进行基于TCP的套接字通信需要使用两个类：</p><ul><li><strong>QTcpServer：服务器类，用于监听客户端连接以及和客户端建立连接。</strong></li><li><strong>QTcpSocket：通信套接字类，客户端与服务器都需要使用这个类。</strong></li></ul><p><strong>最后要使用这两个类，我们需要在Qt的.pro文件中添加network(网络模块)。</strong></p><h2 id="2、QTcpServer"><a href="#2、QTcpServer" class="headerlink" title="2、QTcpServer"></a>2、QTcpServer</h2><p>QTcpServer类用于监听客户端的连接以及和客户端建立连接，下面介绍一下这个类中常用的API：</p><h3 id="2-1、成员函数"><a href="#2-1、成员函数" class="headerlink" title="2.1、成员函数"></a>2.1、成员函数</h3><p>构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTcpServer::<span class="built_in">QTcpServer</span>(QObject *parent = Q_NULLPTR);</span><br></pre></td></tr></table></figure><p>监听是否有客户端连接的API：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听客户端的Ip地址以及端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTcpServer::listen</span><span class="params">(<span class="type">const</span> QHostAddress &amp;address = QHostAddress::Any, quint16 port = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 判断当前对象是否在监听, 是返回true，没有监听返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTcpServer::isListening</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果当前对象正在监听返回监听的服务器地址信息, 否则返回 QHostAddress::Null</span></span><br><span class="line"><span class="function">QHostAddress <span class="title">QTcpServer::serverAddress</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果服务器正在侦听连接，则返回服务器的端口; 否则返回0</span></span><br><span class="line"><span class="function">quint16 <span class="title">QTcpServer::serverPort</span><span class="params">()</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>address：通过类QHostAddress可以封装IPv4、IPv6的IP地址，QHostAddress::Any表示任意IP地址。</strong></li><li><strong>port：指定的端口号。</strong></li></ul><p>每当有客户端成功连接服务器时，我们会通过下面这个API获取用于和客户端通信的套接字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTcpSocket *<span class="title">QTcpServer::nextPendingConnection</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-2、信号"><a href="#2-2、信号" class="headerlink" title="2.2、信号"></a>2.2、信号</h3><p>当接受新连接导致错误时，将会发出如下信号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTcpServer::acceptError</span><span class="params">(QAbstractSocket::SocketError socketError)</span></span>;</span><br></pre></td></tr></table></figure><p>每当有客户端连接时会发出如下信号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTcpServer::newConnection</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3、QTcpSocket"><a href="#3、QTcpSocket" class="headerlink" title="3、QTcpSocket"></a>3、QTcpSocket</h2><p>QTcpSocket是一个套接字通信类，不管是客户端还是服务器都需要使用。在Qt中发送和接收数据也属于IO操作。</p><h3 id="3-1、成员函数"><a href="#3-1、成员函数" class="headerlink" title="3.1、成员函数"></a>3.1、成员函数</h3><p>QTcpSocket的构造函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTcpSocket::<span class="built_in">QTcpSocket</span>(QObject *parent = Q_NULLPTR);</span><br></pre></td></tr></table></figure><p>连接服务器，需要指定服务器绑定的IP以及端口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connectToHost</span><span class="params">(<span class="type">const</span> QString &amp;hostName, quint16 port, OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol)</span></span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connectToHost</span><span class="params">(<span class="type">const</span> QHostAddress &amp;address, quint16 port, OpenMode openMode = ReadWrite)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>在Qt中不管调用读取操作函数接收数据，还是调用写函数发送数据，操作对象都是本地的由Qt框架维护的一块内存。因此，调用发送函数发送的数据不一定马上被发送到网络中，调用的接收函数也不是直接从网络中接收的数据。</strong></p><p>接收数据的API：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定可接收的最大字节数 maxSize 的数据到指针 data 指向的内存中</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::read</span><span class="params">(<span class="type">char</span> *data, qint64 maxSize)</span></span>;</span><br><span class="line"><span class="comment">// 指定可接收的最大字节数 maxSize，返回接收的字符串</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QIODevice::read</span><span class="params">(qint64 maxSize)</span></span>;</span><br><span class="line"><span class="comment">// 将当前可用操作数据全部读出，通过返回值返回读出的字符串</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QIODevice::readAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>发送数据的API：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送指针 data 指向的内存中的 maxSize 个字节的数据</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, qint64 maxSize)</span></span>;</span><br><span class="line"><span class="comment">// 发送指针 data 指向的内存中的数据，字符串以 \0 作为结束标记</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data)</span></span>;</span><br><span class="line"><span class="comment">// 发送参数指定的字符串</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> QByteArray &amp;byteArray)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2、信号"><a href="#3-2、信号" class="headerlink" title="3.2、信号"></a>3.2、信号</h3><p>在使用QTcpSocket进行套接字通信的过程中，如果该类对象发射出了readyRead()信号，说明对端发送的数据达到了，之后可以调用read函数接收数据了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QIODevice::readyRead</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>调用connectToHost()函数并成功建立连接之后发出connected()信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connected</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>套接字与服务器断开连接发出disconnected信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::disconnected</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="4、TCP通信流程"><a href="#4、TCP通信流程" class="headerlink" title="4、TCP通信流程"></a>4、TCP通信流程</h2><h3 id="4-1、服务器端"><a href="#4-1、服务器端" class="headerlink" title="4.1、服务器端"></a>4.1、服务器端</h3><ul><li><strong>创建服务器对象QTcpServer。</strong></li><li><strong>通过QTcpServer对象设置监听，即使用listen()。</strong></li><li><strong>使用newConnection()信号判断是否有新的客户端建立连接。</strong></li><li><strong>若有新的客户端连接，则调用nextPendingConnection()得到通信的套接字对象。</strong></li><li><strong>使用QTcpSocket套接字对象与客户端进行通信。</strong></li></ul><p>如下是实现一个简单的服务器代码，头文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QTcpServer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_start_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_send_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QTcpServer *m_server;</span><br><span class="line">    QTcpSocket *m_tcp;</span><br><span class="line">    QLabel *m_status;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;服务器&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;port-&gt;<span class="built_in">setText</span>(<span class="string">&quot;8080&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建服务器</span></span><br><span class="line">    m_server=<span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//当有客户端连接时</span></span><br><span class="line">    <span class="built_in">connect</span>(m_server,&amp;QTcpServer::newConnection,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        <span class="comment">//获取与客户端通信的套接字</span></span><br><span class="line">       m_tcp=m_server-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">       <span class="comment">//更新连接状态</span></span><br><span class="line">       m_status-&gt;<span class="built_in">setText</span>(<span class="string">&quot;连接状态: 连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//当有数据到达时发射readyRead</span></span><br><span class="line">       <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::readyRead,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">          QByteArray data=m_tcp-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">          <span class="keyword">this</span>-&gt;ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;客户端 say: &quot;</span>+data);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//客户端断开连接</span></span><br><span class="line">       <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::disconnected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">          m_tcp-&gt;<span class="built_in">close</span>();</span><br><span class="line">          m_tcp-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">          m_status-&gt;<span class="built_in">setText</span>(<span class="string">&quot;连接状态: 断开&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    m_status=<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;连接状态: 断开&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_start_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port=<span class="keyword">this</span>-&gt;ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>();</span><br><span class="line">    <span class="comment">//服务器监听ip地址以及设定的端口</span></span><br><span class="line">    m_server-&gt;<span class="built_in">listen</span>(QHostAddress::Any,port);</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;start-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_send_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;send-&gt;<span class="built_in">setShortcut</span>(Qt::Key_Enter | Qt::Key_Return);</span><br><span class="line">    QString msg=<span class="keyword">this</span>-&gt;ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(msg.<span class="built_in">toUtf8</span>());</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务器 say: &quot;</span>+msg);</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;msg-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、客户端"><a href="#4-2、客户端" class="headerlink" title="4.2、客户端"></a>4.2、客户端</h3><ul><li><strong>创建通信的套接字类QTcpSocket对象。</strong></li><li><strong>使用connectToHost()绑定服务器的IP和端口。</strong></li><li><strong>使用QTcpSocket对象和服务器通信。</strong></li></ul><p>如下是实现一个简单客户端的代码，头文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_start_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_off_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_send_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QTcpSocket *m_tcp;</span><br><span class="line">    QLabel *m_statue;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>源文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;客户端&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;port-&gt;<span class="built_in">setText</span>(<span class="string">&quot;8080&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;ip-&gt;<span class="built_in">setText</span>(<span class="string">&quot;192.168.8.217&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;off-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    m_tcp=<span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_statue=<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;连接状态: 断开&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_statue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::readyRead,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        QByteArray data=m_tcp-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务器 say: &quot;</span>+data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::connected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        m_statue-&gt;<span class="built_in">setText</span>(<span class="string">&quot;连接状态: 连接&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;成功连接服务器!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;ui-&gt;start-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;ui-&gt;off-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,&amp;QTcpSocket::disconnected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        m_statue-&gt;<span class="built_in">setText</span>(<span class="string">&quot;连接状态: 断开&quot;</span>);</span><br><span class="line">        m_tcp-&gt;<span class="built_in">close</span>();</span><br><span class="line">        m_tcp-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务器连接已断开&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;ui-&gt;start-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;ui-&gt;off-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_start_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString ip=<span class="keyword">this</span>-&gt;ui-&gt;ip-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port=<span class="keyword">this</span>-&gt;ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;start-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">    m_tcp-&gt;<span class="built_in">connectToHost</span>(ip,port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_off_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_tcp-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;start-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;off-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_send_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;send-&gt;<span class="built_in">setShortcut</span>(Qt::Key_Enter | Qt::Key_Return);</span><br><span class="line">    QString msg=<span class="keyword">this</span>-&gt;ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(msg.<span class="built_in">toUtf8</span>());</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;客户端 say: &quot;</span>+msg);</span><br><span class="line">    <span class="keyword">this</span>-&gt;ui-&gt;msg-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;在标准C++中没有提供专门用于套接字通信的类，所以只能使用操作系统提供的基于C语言的API函数，基于这些C的API函数我们也</summary>
      
    
    
    
    <category term="QtWidget" scheme="https://jjking20010901.github.io/categories/QtWidget/"/>
    
    
    <category term="网络通信" scheme="https://jjking20010901.github.io/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>QML调用C++类</title>
    <link href="https://jjking20010901.github.io/posts/e9129c40.html"/>
    <id>https://jjking20010901.github.io/posts/e9129c40.html</id>
    <published>2022-11-16T05:50:53.000Z</published>
    <updated>2022-11-16T05:53:48.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Qml调用C-类"><a href="#1、Qml调用C-类" class="headerlink" title="1、Qml调用C++类"></a>1、Qml调用C++类</h2><ul><li><strong>Qt QML模块提供了一组API，用来将C++类扩展到QML中。</strong></li><li><strong>我们可以编写扩展来添加自己的QML模型，扩展现有的Qt类型，或调用无法从普通QML代码访问的C/C++函数</strong></li><li><strong>如下将会介绍C++类编写QML扩展，其中包括属性、QML function和属性绑定等。</strong></li></ul><h2 id="2、创建QML"><a href="#2、创建QML" class="headerlink" title="2、创建QML"></a>2、创建QML</h2><p>将C++类扩展到QML上，一般用来实现QML目前无法实现的功能，比如访问系统信息，文件信息等。</p><p>如下将会是显示一个简单的饼图的代码，创建一个C++类提供给QML使用。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.12</span></span><br><span class="line"><span class="keyword">import</span> Charts <span class="number">1.0</span></span><br><span class="line"> </span><br><span class="line"><span class="title">Window</span> &#123;</span><br><span class="line">    <span class="attribute">visible</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">640</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">480</span></span><br><span class="line">    <span class="title">PieChart</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100</span>; <span class="attribute">height</span>: <span class="number">100</span></span><br><span class="line">        <span class="attribute">name</span>: <span class="string">&quot;A simple pie chart&quot;</span></span><br><span class="line">        <span class="attribute">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面导入了一个”import Charts 1.0”模块，然后创建了一个名为”PieChart”的QML元素，该元素具有两个属性：name和color。要做到这一点，我们需要一个C++类，它封装了PieChart类型及其name和color两个属性。</p><h2 id="3、创建C-类"><a href="#3、创建C-类" class="headerlink" title="3、创建C++类"></a>3、创建C++类</h2><p>由于QML大量使用了Qt的元对象系统，因此该类必须是：</p><ul><li>继承于QObject的派生类。</li><li>并且具有Q_OBJECT宏。</li></ul><p>以下是我们的饼图PieChart类，piechart.h的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtQuick/QQuickPaintedItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColor&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PieChart</span> : <span class="keyword">public</span> QQuickPaintedItem</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QString name READ name WRITE setName)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QColor color READ color WRITE setColor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">    PieChart(QQuickItem *parent =</span> <span class="literal">nullptr</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function">QString <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> QString &amp;name)</span> </span>&#123; m_name = name; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_color; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">const</span> QColor &amp;color)</span> </span>&#123; m_color = color; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter)</span> <span class="keyword">override</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">    QColor m_color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：color在QML中一般是字符串类型，比如”#FFFFFF”，但它会自动转化为QColor对象。</p><ul><li><strong>该类继承自QQuickPaintedItem，因为我们希望可以使用QPainter API执行绘图操作，这里我们重写了QQuickPaintedItem中的虚函数paint()。</strong></li><li><strong>如果类只是表示某些数据类型，而不是实际需要显示的内容，它可以简单地从QObject继承。</strong></li></ul><p>Ps:</p><ul><li><strong>QQuickItem：Qt Quick中所有可视化项都继承自QQuickItem。虽然QQuickItem没有视觉外观，但它定义了视觉项目中常见的所有属性，如x和y的位置、宽度和高度、锚点和Key处理支持。</strong></li><li><strong>QQuickPaintedItem：继承自QQuickItem，并且扩展了Qt Widget中的QPainter API函数，使得QPainter将能够直接绘制到QML场景纹理上。调用update()时可以重新绘制，在paint()中使用了setRenderHint()可以设置抗锯齿。</strong></li></ul><p>PieChart类使用了Q_PROPERTY宏定义两个属性name和color,并且重写了QQuickPaintedItem::paint()。</p><h2 id="4、Q-PROPERTY介绍"><a href="#4、Q-PROPERTY介绍" class="headerlink" title="4、Q_PROPERTY介绍"></a>4、Q_PROPERTY介绍</h2><p>Q_PROPERTY宏定义属性的一些主要关键字意义如下：</p><ul><li><strong>READ：指定一个读取属性值的函数，没有MEMBER关键字时必须设置READ。</strong></li><li><strong>WRITE：指定一个设定属性值的函数，只读属性没有WRITE设置。</strong></li><li><strong>MEMBER：指定一个成员变量与属性关联，成为可读可写的属性，无需再设置READ和WRITE。</strong></li><li><strong>RESET：是可选的，用于指定一个设置属性缺省值的函数。</strong></li><li><strong>NOTIFY：可选的，用于设置一个信号，当属性值变化时发射此信号。</strong></li><li><strong>DESIGNABLE：表示属性是否在Qt Designer里可见，缺省为true。</strong></li><li><strong>CONSTANT：表示属性值是一个常数，对于一个对象实例，READ指定函数返回值是常数，但是每个实例返回值可以不一样，具有CONSTANT关键字属性不能有WRITE和NOTIFY关键字。</strong></li><li><strong>FINAL：表示所定义属性不能被子类重载。</strong></li></ul><p>在C++中的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObj</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QString name READ name WRITE setName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">    MyObj(QQuickItem *parent =</span> <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">QString <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> QString &amp;name)</span> </span>&#123; <span class="built_in">qDebug</span>()&lt;&lt;name; m_name = name; &#125;  <span class="comment">// 添加了一个打印</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name; <span class="comment">// 用来保存name属性的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们调用setProperty时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyObj ct;</span><br><span class="line">ct.<span class="built_in">setProperty</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;1234&quot;</span>); <span class="comment">// 将会调用setName()接口函数,并且打印&quot;1234&quot;</span></span><br></pre></td></tr></table></figure><p>piechart.cpp代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;piechart.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">PieChart::<span class="built_in">PieChart</span>(QQuickItem *parent)</span><br><span class="line">: <span class="built_in">QQuickPaintedItem</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PieChart::paint</span><span class="params">(QPainter *painter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPen <span class="title">pen</span><span class="params">(m_color, <span class="number">2</span>)</span></span>;</span><br><span class="line">    painter-&gt;<span class="built_in">setPen</span>(pen);</span><br><span class="line">    painter-&gt;<span class="built_in">setRenderHints</span>(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line">    painter-&gt;<span class="built_in">drawPie</span>(<span class="built_in">boundingRect</span>().<span class="built_in">adjusted</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="number">90</span> * <span class="number">16</span>, <span class="number">290</span> * <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、qmlRegisterXXX注册C-类到QML中"><a href="#5、qmlRegisterXXX注册C-类到QML中" class="headerlink" title="5、qmlRegisterXXX注册C++类到QML中"></a>5、qmlRegisterXXX注册C++类到QML中</h2><p>我们已经创建好C++类，剩下就是注册到QML中即可。注册函数是qmlRegisterType()，如下是qmlRegisterType函数模板声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmlRegisterType</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *uri, <span class="type">int</span> versionMajor, <span class="type">int</span> versionMinor, <span class="type">const</span> <span class="type">char</span> *qmlName)</span></span>;</span><br><span class="line"><span class="comment">// uri:  类似于java包名,比如&quot;import QtQuick 2.12&quot;,&quot;QtQuick&quot;就是包名,而2.12是versionMajor和versionMinor拼接的版本号</span></span><br><span class="line"><span class="comment">// qmlName: 包名中的类型名称,比如Rectangle就是QtQuick包名中的其中一个类型名称</span></span><br></pre></td></tr></table></figure><p>main.cpp如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQmlApplicationEngine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;piechart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QCoreApplication::<span class="built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling);</span><br><span class="line"></span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QQmlApplicationEngine engine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册C++类</span></span><br><span class="line">    <span class="built_in">qmlRegisterType</span>&lt;PieChart&gt;(<span class="string">&quot;Charts&quot;</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;PieChart&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> QUrl <span class="title">url</span><span class="params">(QStringLiteral(<span class="string">&quot;qrc:/main.qml&quot;</span>))</span></span>;</span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;engine, &amp;QQmlApplicationEngine::objectCreated,</span><br><span class="line">                     &amp;app, [url](QObject *obj, <span class="type">const</span> QUrl &amp;objUrl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj &amp;&amp; url == objUrl)</span><br><span class="line">            QCoreApplication::<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;, Qt::QueuedConnection);</span><br><span class="line">    engine.<span class="built_in">load</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6、属性绑定"><a href="#6、属性绑定" class="headerlink" title="6、属性绑定"></a>6、属性绑定</h2><p>属性绑定是QML的一个强大功能，它允许自动同步不同类型的值，当属性值更改时，它使用信号通知和更新其他类型的值。</p><p>我们创建两个PieChart图，名称分别为chartA和chartB，然后我们在chartB中进行color属性的绑定：”color:chartA.color”，修改一下main.qml代码：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.14</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.12</span></span><br><span class="line"><span class="keyword">import</span> Charts <span class="number">1.0</span></span><br><span class="line"> </span><br><span class="line"><span class="title">Window</span> &#123;</span><br><span class="line">    <span class="attribute">visible</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">640</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">480</span></span><br><span class="line">    </span><br><span class="line">    <span class="title">Row</span> &#123;</span><br><span class="line">        <span class="title">PieChart</span> &#123;</span><br><span class="line">            <span class="attribute">id:</span><span class="string"> chartA</span></span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100</span>; <span class="attribute">height</span>: <span class="number">100</span></span><br><span class="line">            <span class="attribute">name</span>: <span class="string">&quot;A simple pie chart&quot;</span></span><br><span class="line">            <span class="attribute">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title">PieChart</span> &#123;</span><br><span class="line">            <span class="attribute">id:</span><span class="string"> chartB</span></span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100</span>; <span class="attribute">height</span>: <span class="number">100</span></span><br><span class="line">            <span class="attribute">name</span>: <span class="string">&quot;A simple pie chart&quot;</span></span><br><span class="line">            <span class="attribute">color</span>: chartA.color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title">MouseArea</span> &#123;</span><br><span class="line">        <span class="attribute">anchors.fill</span>: <span class="built_in">parent</span></span><br><span class="line">        <span class="attribute">onClicked</span>: &#123; chartA.color = <span class="string">&quot;blue&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改piechart.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtQuick/QQuickPaintedItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColor&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PieChart</span> : <span class="keyword">public</span> QQuickPaintedItem</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QString name READ name WRITE setName NOTIFY nameChanged)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QColor color READ color WRITE setColor NOTIFY colorChanged)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">    PieChart(QQuickItem *parent =</span> <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function">QString <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name != m_name) &#123;</span><br><span class="line">            m_name = name;</span><br><span class="line">            <span class="function">emit <span class="title">nameChanged</span><span class="params">(name)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_color; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">const</span> QColor &amp;color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color != m_color) &#123;</span><br><span class="line">            m_color = color;</span><br><span class="line">            <span class="function">emit <span class="title">colorChanged</span><span class="params">(color)</span></span>;</span><br><span class="line">            <span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">    QColor m_color;</span><br><span class="line"> </span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nameChanged</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">colorChanged</span><span class="params">(<span class="type">const</span> QColor &amp;color)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们在Q_PROPERTY中添加一个NOTIFY功能：</p><ul><li><strong>属性绑定主要是靠属性中的NOTIFY功能，每当color值更改时，就会发出colorChanged信号。从而使得绑定的目标属性自动更新值。</strong></li><li><strong>调用WRITE功能的函数时(比如setColor())，我们必须判断要设置的值是否和当前属性值相等，这样确保信号不会必要地发出，从而导致可能死循环事件发生。</strong></li></ul><h2 id="7、使用Q-INVOKABLE修饰函数提供给QML使用"><a href="#7、使用Q-INVOKABLE修饰函数提供给QML使用" class="headerlink" title="7、使用Q_INVOKABLE修饰函数提供给QML使用"></a>7、使用Q_INVOKABLE修饰函数提供给QML使用</h2><p>比如在QML中，我们想使用C++类的clearChart()函数来清除绘图，那么我们需要在C++类的clearChart()函数前面使用Q_INVOKABLE修饰来注册到元对象中，这样QML就可以像使用function那样调用该函数了。</p><p>修改piechart.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PIECHART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIECHART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtQuick/QQuickPaintedItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PieChart</span> : <span class="keyword">public</span> QQuickPaintedItem</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QString name READ name WRITE setName NOTIFY nameChanged)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QColor color READ color WRITE setColor NOTIFY colorChanged)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">    //explicit PieChart(QObject *parent =</span> <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PieChart</span><span class="params">(QQuickItem *parent=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name!=m_name)</span><br><span class="line">        &#123;</span><br><span class="line">            m_name=name;</span><br><span class="line">            <span class="function">emit <span class="title">nameChanged</span><span class="params">(name)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">const</span> QColor &amp;color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(color!=m_color)</span><br><span class="line">        &#123;</span><br><span class="line">            m_color=color;</span><br><span class="line">            <span class="function">emit <span class="title">colorChanged</span><span class="params">(color)</span></span>;</span><br><span class="line">            <span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Q_INVOKABLE <span class="type">void</span> <span class="title">clearChart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nameChanged</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">colorChanged</span><span class="params">(<span class="type">const</span> QColor &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">    QColor m_color;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// PIECHART_H</span></span></span><br></pre></td></tr></table></figure><p>piechart.cpp中实现clearChart函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PieChart::clearChart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setColor</span>(<span class="built_in">QColor</span>(Qt::transparent));</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改main.qml：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Window &#123;</span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    width: <span class="number">640</span></span><br><span class="line">    height: <span class="number">480</span></span><br><span class="line">    </span><br><span class="line">    Row &#123;</span><br><span class="line">        PieChart &#123;</span><br><span class="line">            id: chartA</span><br><span class="line">            width: <span class="number">100</span>; height: <span class="number">100</span></span><br><span class="line">            name: <span class="string">&quot;A simple pie chart&quot;</span></span><br><span class="line">            color: <span class="string">&quot;red&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        PieChart &#123;</span><br><span class="line">            id: chartB</span><br><span class="line">            width: <span class="number">100</span>; height: <span class="number">100</span></span><br><span class="line">            name: <span class="string">&quot;A simple pie chart&quot;</span></span><br><span class="line">            color: <span class="string">&quot;blue&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123; chartA.<span class="built_in">clearChart</span>();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、信号、槽函数提供给QML使用"><a href="#8、信号、槽函数提供给QML使用" class="headerlink" title="8、信号、槽函数提供给QML使用"></a>8、信号、槽函数提供给QML使用</h2><p><strong>上面使用了Q_INVOKABLE修饰函数注册到元对象中其实本质就是signal和slots。因为不管用Q_INVOKABLE还是signal和slots修饰，最终都会变为QT_ANNOTATE_FUNCTION(…)。</strong></p><p>在piechart.h中添加clearChart2()槽函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PIECHART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIECHART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtQuick/QQuickPaintedItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PieChart</span> : <span class="keyword">public</span> QQuickPaintedItem</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QString name READ name WRITE setName NOTIFY nameChanged)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QColor color READ color WRITE setColor NOTIFY colorChanged)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">    //explicit PieChart(QObject *parent =</span> <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PieChart</span><span class="params">(QQuickItem *parent=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name!=m_name)</span><br><span class="line">        &#123;</span><br><span class="line">            m_name=name;</span><br><span class="line">            <span class="function">emit <span class="title">nameChanged</span><span class="params">(name)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">const</span> QColor &amp;color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(color!=m_color)</span><br><span class="line">        &#123;</span><br><span class="line">            m_color=color;</span><br><span class="line">            <span class="function">emit <span class="title">colorChanged</span><span class="params">(color)</span></span>;</span><br><span class="line">            <span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Q_INVOKABLE <span class="type">void</span> <span class="title">clearChart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearChart2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nameChanged</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">colorChanged</span><span class="params">(<span class="type">const</span> QColor &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">    QColor m_color;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// PIECHART_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在piechart.cpp中实现该槽函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PieChart::clearChart2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setColor</span>(Qt::transparent);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改main.qml:</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Window</span> &#123;</span><br><span class="line">    <span class="attribute">visible</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">640</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">480</span></span><br><span class="line">    </span><br><span class="line">    <span class="title">Row</span> &#123;</span><br><span class="line">        <span class="title">PieChart</span> &#123;</span><br><span class="line">            <span class="attribute">id:</span><span class="string"> chartA</span></span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100</span>; <span class="attribute">height</span>: <span class="number">100</span></span><br><span class="line">            <span class="attribute">name</span>: <span class="string">&quot;A simple pie chart&quot;</span></span><br><span class="line">            <span class="attribute">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title">PieChart</span> &#123;</span><br><span class="line">            <span class="attribute">id:</span><span class="string"> chartB</span></span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100</span>; <span class="attribute">height</span>: <span class="number">100</span></span><br><span class="line">            <span class="attribute">name</span>: <span class="string">&quot;A simple pie chart&quot;</span></span><br><span class="line">            <span class="attribute">color</span>: <span class="string">&quot;blue&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title">MouseArea</span> &#123;</span><br><span class="line">        <span class="attribute">anchors.fill</span>: <span class="built_in">parent</span></span><br><span class="line">        <span class="attribute">onClicked</span>: &#123; chartA.clearChart2();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、使用Q-ENUM将枚举提供给QML使用"><a href="#9、使用Q-ENUM将枚举提供给QML使用" class="headerlink" title="9、使用Q_ENUM将枚举提供给QML使用"></a>9、使用Q_ENUM将枚举提供给QML使用</h2><p>在C++类中，我们可以通过Q_ENUM()将C++类的枚举类型注册到元对象中，piechart.h修改后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PIECHART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIECHART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtQuick/QQuickPaintedItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PieChart</span> : <span class="keyword">public</span> QQuickPaintedItem</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QString name READ name WRITE setName NOTIFY nameChanged)</span></span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QColor color READ color WRITE setColor NOTIFY colorChanged)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">    //explicit PieChart(QObject *parent =</span> <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PieChart</span><span class="params">(QQuickItem *parent=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Priority</span>&#123;</span><br><span class="line">        High,</span><br><span class="line">        Low,</span><br><span class="line">        VeryHigh,</span><br><span class="line">        VeryLow</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Q_ENUM</span>(Priority)</span><br><span class="line"></span><br><span class="line">    <span class="function">Q_INVOKABLE <span class="type">void</span> <span class="title">setPriority</span><span class="params">(Priority value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">QString <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name!=m_name)</span><br><span class="line">        &#123;</span><br><span class="line">            m_name=name;</span><br><span class="line">            <span class="function">emit <span class="title">nameChanged</span><span class="params">(name)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">const</span> QColor &amp;color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(color!=m_color)</span><br><span class="line">        &#123;</span><br><span class="line">            m_color=color;</span><br><span class="line">            <span class="function">emit <span class="title">colorChanged</span><span class="params">(color)</span></span>;</span><br><span class="line">            <span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Q_INVOKABLE <span class="type">void</span> <span class="title">clearRect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearChart2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nameChanged</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">colorChanged</span><span class="params">(<span class="type">const</span> QColor &amp;color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">    QColor m_color;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// PIECHART_H</span></span></span><br></pre></td></tr></table></figure><p>在main.qml中修改：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Window</span> &#123;</span><br><span class="line">    <span class="attribute">visible</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">640</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">480</span></span><br><span class="line">    </span><br><span class="line">    <span class="title">Row</span> &#123;</span><br><span class="line">        <span class="title">PieChart</span> &#123;</span><br><span class="line">            <span class="attribute">id:</span><span class="string"> chartA</span></span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100</span>; <span class="attribute">height</span>: <span class="number">100</span></span><br><span class="line">            <span class="attribute">name</span>: <span class="string">&quot;A simple pie chart&quot;</span></span><br><span class="line">            <span class="attribute">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title">PieChart</span> &#123;</span><br><span class="line">            <span class="attribute">id:</span><span class="string"> chartB</span></span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100</span>; <span class="attribute">height</span>: <span class="number">100</span></span><br><span class="line">            <span class="attribute">name</span>: <span class="string">&quot;A simple pie chart&quot;</span></span><br><span class="line">            <span class="attribute">color</span>: <span class="string">&quot;blue&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title">MouseArea</span> &#123;</span><br><span class="line">        <span class="attribute">anchors.fill</span>: <span class="built_in">parent</span></span><br><span class="line">        <span class="attribute">onClicked</span>: &#123; chartA.clearChart2();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">Component.onCompleted</span>: &#123;</span><br><span class="line">        chartA.setPriority(PieChart.Low)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、Qml调用C-类&quot;&gt;&lt;a href=&quot;#1、Qml调用C-类&quot; class=&quot;headerlink&quot; title=&quot;1、Qml调用C++类&quot;&gt;&lt;/a&gt;1、Qml调用C++类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Qt QML模块提供了一组API，用来将C+</summary>
      
    
    
    
    <category term="QtQuick" scheme="https://jjking20010901.github.io/categories/QtQuick/"/>
    
    
    <category term="QtQuick" scheme="https://jjking20010901.github.io/tags/QtQuick/"/>
    
  </entry>
  
  <entry>
    <title>thread的使用</title>
    <link href="https://jjking20010901.github.io/posts/1a28f1f4.html"/>
    <id>https://jjking20010901.github.io/posts/1a28f1f4.html</id>
    <published>2022-11-15T06:37:18.000Z</published>
    <updated>2022-11-20T01:44:16.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><ul><li>进程是一个应用程序被操作系统拉起来加载到内存之后从开始执行到执行结束的这样一个过程。简单来说，进程是程序(可执行文件exe)的一次执行。比如双击打开一个桌面应用软件就是开启一个进程。</li><li>线程是进程中的一个实体，是被操作系统独立分配和调度的基本单位。线程是CPU可执行调度的最小单位，也就是说进程本身不能获取CPU时间，只有线程才可以。</li><li>从属关系：进程 &gt; 线程。一个进程可以拥有多个线程。</li><li>每个线程共享同样的内存空间，开销比较小。</li><li>每个进程拥有独立的内存空间，因此开销大。</li><li>对于高性能并行计算，或者说高性能服务器等，更好的是多线程。</li></ul><h2 id="2、std-thread的构造函数"><a href="#2、std-thread的构造函数" class="headerlink" title="2、std::thread的构造函数"></a>2、std::thread的构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="built_in">thread</span>( thread&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// ③</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Function, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">( Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="comment">// ④</span></span><br><span class="line"><span class="built_in">thread</span>( <span class="type">const</span> thread&amp; ) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>构造函数①：默认构造函数，构造一个线程对象，在这个线程中不执行任何处理动作。</strong></li><li><strong>构造函数②：移动构造函数，将other的线程所有权转移给新的thread对象。之后other不再表示执行线程。</strong></li><li><strong>构造函数③：创建线程对象，并在该线程中执行函数f中的业务逻辑，args是要传递给函数f的参数。任务函数f的可选类型很多，包括普通函数、类成员函数、匿名函数、仿函数等等。</strong></li><li><strong>构造函数④：使用=delete显示删除拷贝赋值构造函数，不允许线程对象之间拷贝。</strong></li></ul><h2 id="3、std-thread的成员函数"><a href="#3、std-thread的成员函数" class="headerlink" title="3、std::thread的成员函数"></a>3、std::thread的成员函数</h2><h3 id="3-1、get-id"><a href="#3-1、get-id" class="headerlink" title="3.1、get_id()"></a>3.1、get_id()</h3><p>应用程序启动之后默认只有一个线程，<strong>这个线程一般称为主线程或者父线程</strong>，通过线程类创建出的线程一般称为子线程。每个被创建出的线程实例都对应一个线程ID，这个ID是唯一的，可以通过这个ID来区分和识别各个已经存在的线程实例，<strong>这个获取线程ID的函数叫做get_id()</strong>，函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>测试程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span></span><br><span class="line">            &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例程序中有一个 bug，在主线程中依次创建出两个子线程，打印两个子线程的线程 ID，最后主线程执行完毕就退出了（主线程就是执行 main () 函数的那个线程）。默认情况下，主线程销毁时会将与其关联的两个子线程也一并销毁，但是这时有可能子线程中的任务还没有执行完毕，最后也就得不到我们想要的结果了。</p><p>当启动一个线程(创建一个thread对象)之后，在这个线程结束的时候，我们如何回收线程所使用的资源呢？thread库给了我们两种选择：</p><ul><li><strong>加入式(join())：也叫阻塞式。</strong></li><li><strong>分离式(detach())</strong></li></ul><p>我们必须在线程销毁前在二者之间作出选择，否则会出现异常。</p><h3 id="3-2、join"><a href="#3-2、join" class="headerlink" title="3.2、join()"></a>3.2、join()</h3><p>join()字面意思是连接一个线程，意味着主动等待线程的终止(线程阻塞)。在某个线程中通过子线程对象调动join()函数，调用这个函数的线程被阻塞。但是子线程对象中的任务函数会继续执行，当任务执行完毕之后join()会清理当前子线程的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。</p><p>join函数的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>为了更好理解join()的使用，再举个例子，假设程序中共有三个线程，其中两个是子线程，它们负责下载同一个文件，下载完毕之后，由主线程对这个文件进行下一步处理，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时500ms，阻塞线程500ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程1: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, 找到历史正文....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时300ms，阻塞线程300ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程2: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, 找到历史正文....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;集齐历史正文, 呼叫罗宾....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;历史正文解析中....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;起航，前往拉夫德尔....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到OnePiece, 成为海贼王, 哈哈哈!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;若干年后，草帽全员卒....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大海贼时代再次被开启....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(download1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(download2)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述测试程序中主线程执行doSomething这个函数，子线程执行download1和download2，在35、36行中两个子线程调用join()方法，让主线程陷入等待状态，当两个子线程的下载任务执行结束，主线程就去处理文件，最后程序执行结束，子线程被销毁，符合RALL原则。</p><h3 id="3-3、detach"><a href="#3-3、detach" class="headerlink" title="3.3、detach()"></a>3.3、detach()</h3><p>detach() 函数的作用是进行线程分离，分离主线程和创建出的子线程。<strong>在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。</strong>（其实就是孩子翅膀硬了，和家里断绝关系，自己外出闯荡了，如果家里被诛九族还是会受牵连）。该函数函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>线程分离函数没有参数也没有返回值，只需在线程成功创建之后，通过线程对象调用该函数即可，在之前测试代码做出修改之后的测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span></span><br><span class="line">            &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：线程分离函数 detach () 不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制了，比如：通过 join () 阻塞主线程等待子线程中的任务执行完毕，或者调用 get_id () 获取子线程的线程 ID。有利就有弊，鱼和熊掌不可兼得，建议使用 join ()。</strong></p><h3 id="3-4、joinable"><a href="#3-4、joinable" class="headerlink" title="3.4、joinable()"></a>3.4、joinable()</h3><p>joinable() 函数用于判断主线程和子线程是否处理关联（连接）状态，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：</p><ul><li><strong>返回值为true：主线程和子线程之间有关联(连接)关系。</strong></li><li><strong>返回值为false：主线程和子线程之间没有关联(连接)关系</strong></li></ul><p>joinable()函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread t;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before starting, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t = <span class="built_in">thread</span>(foo);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after starting, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after joining, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after starting, joinable: &quot;</span> &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after detaching, joinable: &quot;</span> &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：在创建子线程对象时，如果还没有指定任务函数，那么子线程不会启动，主线程和子线程也不会进行连接。</strong></p><p><strong>在创建子线程对象时，如果指定任务函数，子线程启动并执行任务，主线程和这个子线程自动连接成功。</strong></p><p><strong>子线程调用detach()函数之后，子线程与主线程分离，同时二者连接断开，调用joinable()返回false。</strong></p><p><strong>子线程调用join()函数，子线程中的任务函数继续执行，直到任务处理完毕，这时join()会自动清理当前子线程相关资源，所以这个子线程和主线程的连接也就断开，因此，调用join()之后再调用joinable()会返回false。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、进程与线程&quot;&gt;&lt;a href=&quot;#1、进程与线程&quot; class=&quot;headerlink&quot; title=&quot;1、进程与线程&quot;&gt;&lt;/a&gt;1、进程与线程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进程是一个应用程序被操作系统拉起来加载到内存之后从开始执行到执行结束的这样一个过程。简单</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++11多线程" scheme="https://jjking20010901.github.io/tags/C-11%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>可调用对象的包装器</title>
    <link href="https://jjking20010901.github.io/posts/79511485.html"/>
    <id>https://jjking20010901.github.io/posts/79511485.html</id>
    <published>2022-11-12T03:01:48.000Z</published>
    <updated>2022-11-12T06:53:20.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、可调用对象"><a href="#1、可调用对象" class="headerlink" title="1、可调用对象"></a>1、可调用对象</h2><p>在C++中存在”可调用对象”这个概念。准确来说，可调用对象有如下几种定义：</p><ul><li>是一个函数指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*func)(<span class="type">int</span>, <span class="type">double</span>) = &amp;print;</span><br></pre></td></tr></table></figure><ul><li>是一个具有operator()成员函数的类对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ()操作符重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">t</span>(<span class="string">&quot;I will be luffy&quot;</span>);<span class="comment">// 仿函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>是一个可被转化为函数指针的类对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类对象转换为函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">func_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> print;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 对象转换为函数指针, 并调用</span></span><br><span class="line">    <span class="built_in">t</span>(<span class="number">19</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>是一个类成员函数指针或者类成员指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义类成员函数指针指向类成员函数</span></span><br><span class="line">    <span class="built_in">void</span> (Test::*func_ptr)(<span class="type">int</span>, string) = &amp;Test::print;</span><br><span class="line">    <span class="comment">// 类成员指针指向类成员变量</span></span><br><span class="line">    <span class="type">int</span> Test::*obj_ptr = &amp;Test::m_num;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 通过类成员函数指针调用类成员函数</span></span><br><span class="line">    (t.*func_ptr)(<span class="number">19</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过类成员指针初始化类成员变量</span></span><br><span class="line">    t.*obj_ptr = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number is: &quot;</span> &lt;&lt; t.m_num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面例子中满足条件的这些可调用对象对应的类型被统称为<strong>可调用类型</strong>。C++中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用同一方式保存，或者传递一个可调用对象时会十分繁琐，现在<strong>C++11通过提供std::function和std::bind统一了可调用对象的各种操作。</strong></p><h2 id="2、可调用对象的包装器"><a href="#2、可调用对象的包装器" class="headerlink" title="2、可调用对象的包装器"></a>2、可调用对象的包装器</h2><p><strong>std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</strong></p><h3 id="2-1、基本语法："><a href="#2-1、基本语法：" class="headerlink" title="2.1、基本语法："></a>2.1、基本语法：</h3><p>std::function必须包含一个叫做functional的头文件，可调用对象包装器使用语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">std::function&lt;返回值类型(参数类型列表)&gt; diy_name = 可调用对象;</span><br></pre></td></tr></table></figure><p>如下代码演示可调用对象的包装器的基本使用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定一个普通函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;</span><br><span class="line">    <span class="comment">// 绑定以静态类成员函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = T1::sub;</span><br><span class="line">    <span class="comment">// 绑定一个仿函数</span></span><br><span class="line">    T2 t;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过测试代码可以得到结论：std::function可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装函数的调用。</strong></p><h3 id="2-2、作为回调函数的使用："><a href="#2-2、作为回调函数的使用：" class="headerlink" title="2.2、作为回调函数的使用："></a>2.2、作为回调函数的使用：</h3><p>因为回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数参数是一个包装器对象</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> function&lt;<span class="built_in">void</span>()&gt;&amp; f) : <span class="built_in">callback</span>(f)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">callback</span>(); <span class="comment">// 调用通过构造函数得到的函数指针</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="type">void</span>()&gt; callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I will be luffy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">// 仿函数通过包装器对象进行包装</span></span><br><span class="line">    a.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子可以看出，使用对象包装器std::function可以非常方便的将仿函数转化为一个函数指针，通过进行函数指针传递，在其他函数的合适位置就可以调用这个包装好的仿函数。</p><p>另外，使用std::function作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。</p><h2 id="3、绑定器"><a href="#3、绑定器" class="headerlink" title="3、绑定器"></a>3、绑定器</h2><p>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。通俗来讲，它主要有两大作用：</p><ul><li>将可调用对象与其参数一起绑定成一个仿函数。</li><li>将多元(参数个数为n,n&gt;1)可调用对象转化为一元或者(n-1)元可调用对象，即只绑定部分参数。</li></ul><p>绑定器函数的使用语法格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定非类成员函数/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(可调用对象地址, 绑定的参数/占位符);</span><br><span class="line"><span class="comment">// 绑定类成员函/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);</span><br></pre></td></tr></table></figure><p>如下是一个关于绑定器的实际使用例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callFunc</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x + <span class="number">10</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(output, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(output_add, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，使用了std::bind绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。</p><p>std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto自动类型推导即可。</p><p><strong>placeholders::_1是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。同样还有其他的占位符： placeholders::_2、placeholders::_3、placeholders::_4、placeholders::_5 等……</strong></p><p>有了占位符的概念之后，使得std::bind的使用更灵活：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, <span class="number">2</span>)(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_1)(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error, 调用时没有第二个参数</span></span><br><span class="line">    <span class="comment">// bind(output, 2, placeholders::_2)(10);</span></span><br><span class="line">    <span class="comment">// 调用时第一个参数10被吞掉了，没有被使用</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过测试可知，std::bind可以直接调用绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用std::placeholders来决定空位参数将会属于 调用发生时的第几个参数。</p><p>可调用对象包装器std::function是不能实现对类成员函数指针或者类成员指针的包装的，但是可以通过绑定器std::bind配合之后，就可以完美解决这个问题，以下是测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 绑定类成员函数</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 =</span><br><span class="line">        <span class="built_in">bind</span>(&amp;Test::output, &amp;t, placeholders::_1, placeholders::_2);</span><br><span class="line">    <span class="comment">// 绑定类成员变量(公共)</span></span><br><span class="line">    function&lt;<span class="type">int</span>&amp; (<span class="type">void</span>)&gt; f2 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">520</span>, <span class="number">1314</span>);</span><br><span class="line">    <span class="built_in">f2</span>() = <span class="number">2333</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_number: &quot;</span> &lt;&lt; t.m_number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。<strong>f1的类型是function<void(int, int)>，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。</strong></p><p><strong>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function<int&(void)>的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</strong></p><p>示例程序中是使用 function 包装器保存了 bind 返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用 auto 进行类型的自动推导，这样使用起来会更容易一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、可调用对象&quot;&gt;&lt;a href=&quot;#1、可调用对象&quot; class=&quot;headerlink&quot; title=&quot;1、可调用对象&quot;&gt;&lt;/a&gt;1、可调用对象&lt;/h2&gt;&lt;p&gt;在C++中存在”可调用对象”这个概念。准确来说，可调用对象有如下几种定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="可调用对象的包装器" scheme="https://jjking20010901.github.io/tags/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%85%E8%A3%85%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CPP面试题目02</title>
    <link href="https://jjking20010901.github.io/posts/2b7ca3bb.html"/>
    <id>https://jjking20010901.github.io/posts/2b7ca3bb.html</id>
    <published>2022-11-11T06:45:08.000Z</published>
    <updated>2022-11-11T06:46:39.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、C-的虚函数实现机制"><a href="#1、C-的虚函数实现机制" class="headerlink" title="1、C++的虚函数实现机制"></a>1、C++的虚函数实现机制</h2><p>虚函数是实现多态/接口函数的基础。利用虚表实现。C++对象的内存布局，对象的前8位（64位系统）为虚表指针（vtpr），指向对象所对应的虚表。虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。</p><h2 id="2、C-的智能指针相关实现"><a href="#2、C-的智能指针相关实现" class="headerlink" title="2、C++的智能指针相关实现"></a>2、C++的智能指针相关实现</h2><p>C++11为C++标准库带来了三个智能指针，分别是shared_ptr，unique_ptr，weak_ptr。</p><p>C++智能指针的实现原理为引用计数。引用计数无法处理循环引用的情况。</p><p>shared_ptr实现原理是同一个内存空间每多一个指针指向就计数加1，如果计数变为0就释放内存空间。当用普通指针初始化的时候，只能使用一次普通指针。它还可以自定义释放函数。</p><p>unique_ptr是计数只能为1，没有拷贝构造函数。</p><p>weak_ptr只能指向该内存空间而没有所有权。主要用于辅助第一个指针，防止出现互锁。借助weak_ptr类型指针， 我们可以获取weak_ptr指针的一些状态信息，比如有多少指向相同的shared_ptr指针、shared_ptr指针指向的堆内存是否已经被释放等等。在构建weak_ptr指针对象时，可经常利用已有的shared_ptr指针为其初始化。</p><h2 id="3、互斥锁、可重入锁、读写锁与自旋锁"><a href="#3、互斥锁、可重入锁、读写锁与自旋锁" class="headerlink" title="3、互斥锁、可重入锁、读写锁与自旋锁"></a>3、互斥锁、可重入锁、读写锁与自旋锁</h2><p>mutex(互斥量)是睡眠等待类型的锁，当线程抢互斥锁失败的时候，线程会陷入休眠。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。</p><p>依据同一线程是否能多次加锁，把互斥量又分为如下两类：</p><ul><li>是：递归互斥量recursive mutex，也称<strong>可重入锁</strong>，reentrant lock。</li><li>否：非递归互斥量non-recursive mutex，也称<strong>不可重入锁</strong>，non-reentrant mutex。</li></ul><p>read-write lock读写锁，又称”共享-独占锁”，对于临界区区分读和写，读共享，写独占。</p><p>读写锁的特性：</p><ul><li>当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会<strong>阻塞</strong>。</li><li>当读写锁被加了读锁时，其他线程对该锁加写锁会<strong>阻塞</strong>，加读锁会成功。</li></ul><p>spinlock(自旋锁)<strong>自旋，更通俗的一个词时“忙等待”（busy waiting）。最通俗的一个理解，其实就是死循环。</strong></p><p>自旋锁不会引起线程休眠。当共享资源的状态不满足时，自旋锁会不停地<strong>循环检测状态</strong>(循环检测状态利用了CPU提供的原语Compare&amp;Exchange来保证原子性)。因为不会陷入休眠，而是忙等待的方式也就不需要条件变量。不休眠就不会引起上下文切换，但是会比较浪费CPU。</p><h2 id="4、定义和声明的区别"><a href="#4、定义和声明的区别" class="headerlink" title="4、定义和声明的区别"></a>4、定义和声明的区别</h2><p>声明是告诉编译器变量的类型和名字，不会为变量分配空间。定义需要分配空间，同一个变量可以被声明多次，但是只能被定义一次。</p><h2 id="5、C-文件编译与执行的四个阶段"><a href="#5、C-文件编译与执行的四个阶段" class="headerlink" title="5、C++文件编译与执行的四个阶段"></a>5、C++文件编译与执行的四个阶段</h2><p>1）预处理：根据文件中的预处理指令来修改源文件的内容</p><p>2）编译：编译成汇编代码</p><p>3）汇编：把汇编代码翻译成目标机器指令</p><p>4）链接：链接目标代码生成可执行程序</p><h2 id="6、STL中的vector的实现，是怎么扩容的？"><a href="#6、STL中的vector的实现，是怎么扩容的？" class="headerlink" title="6、STL中的vector的实现，是怎么扩容的？"></a>6、STL中的vector的实现，是怎么扩容的？</h2><p>vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。vector就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。当删除的时候空间并不会被释放，只是清空了里面的数据。对比array是静态空间一旦配置了就不能改变大小。vector的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在VS下是1.5倍扩容，在GCC下是2倍扩容。</p><h2 id="7、STL中的unordered-map和map的区别"><a href="#7、STL中的unordered-map和map的区别" class="headerlink" title="7、STL中的unordered_map和map的区别"></a>7、STL中的unordered_map和map的区别</h2><p>map是STL中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在map内部所有的数据都是有序的，且map的查询、插入、删除操作的时间复杂度都是O(logN)。</p><p>unordered_map和map类似，都是存储key-value对，可以通过key快速索引到value，不同的是unordered_map不会根据key进行排序。unordered_map底层是一个防冗余的哈希表，存储时根据key的hash值判断元素是否相同，即unoredered_map内部是无序的。</p><h2 id="8、引用能否实现动态绑定，为什么引用可以实现"><a href="#8、引用能否实现动态绑定，为什么引用可以实现" class="headerlink" title="8、引用能否实现动态绑定，为什么引用可以实现"></a>8、引用能否实现动态绑定，为什么引用可以实现</h2><p>可以。因为引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。</p><h2 id="9、深拷贝和浅拷贝的区别"><a href="#9、深拷贝和浅拷贝的区别" class="headerlink" title="9、深拷贝和浅拷贝的区别"></a>9、深拷贝和浅拷贝的区别</h2><p>深拷贝和浅拷贝可以简单的理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。</p><h2 id="10、extern“C”作用"><a href="#10、extern“C”作用" class="headerlink" title="10、extern“C”作用"></a>10、extern“C”作用</h2><p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。</p><h2 id="11、纯虚函数"><a href="#11、纯虚函数" class="headerlink" title="11、纯虚函数"></a>11、纯虚函数</h2><p>纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承，包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象。</p><h2 id="12、什么是野指针"><a href="#12、什么是野指针" class="headerlink" title="12、什么是野指针"></a>12、什么是野指针</h2><p>野指针不是NULL指针，是未初始化或者未清零的指针，它指向的内存地址不是程序员所期望的，可能指向了受限的内存。</p><p>成因：</p><p>1）指针变量没有被初始化</p><p>2）指针指向的内存被释放了，但是指针没有置NULL</p><p>3）指针超过了变量了的作用范围，比如b[10]，指针b+11</p><h2 id="13、线程安全和线程不安全"><a href="#13、线程安全和线程不安全" class="headerlink" title="13、线程安全和线程不安全"></a>13、线程安全和线程不安全</h2><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可以使用，不会出现数据不一致或者数据污染。</p><p>线程不安全就是不提供数据访问保护，有可能多个线程先后更改数据所得到的数据就是脏数据。</p><h2 id="14、const-charp和char-const-p的区别"><a href="#14、const-charp和char-const-p的区别" class="headerlink" title="14、const charp和char  const p的区别"></a>14、const char<em>p和char </em> const p的区别</h2><p>如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br>如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。</p><h2 id="15、如何定义和实现一个类的成员函数为回调函数"><a href="#15、如何定义和实现一个类的成员函数为回调函数" class="headerlink" title="15、如何定义和实现一个类的成员函数为回调函数"></a>15、如何定义和实现一个类的成员函数为回调函数</h2><p>所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在，以后，当某个事件发生时，再调用这个函数对事件进行响应。<br>定义一个类的成员函数时在该函数前加CALLBACK即将其定义为回调函数，函数的实现和普通成员函数没有区别。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://jjking20010901.github.io/posts/b275f201.html">CPP面试题目01</a></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、C-的虚函数实现机制&quot;&gt;&lt;a href=&quot;#1、C-的虚函数实现机制&quot; class=&quot;headerlink&quot; title=&quot;1、C++的虚函数实现机制&quot;&gt;&lt;/a&gt;1、C++的虚函数实现机制&lt;/h2&gt;&lt;p&gt;虚函数是实现多态/接口函数的基础。利用虚表实现。C++对</summary>
      
    
    
    
    <category term="CPP面试题目" scheme="https://jjking20010901.github.io/categories/CPP%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
    <category term="面试题目" scheme="https://jjking20010901.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>模型与视图</title>
    <link href="https://jjking20010901.github.io/posts/546960bf.html"/>
    <id>https://jjking20010901.github.io/posts/546960bf.html</id>
    <published>2022-11-09T10:59:53.000Z</published>
    <updated>2022-11-20T01:45:14.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、模型视图设计模式核心思想"><a href="#1、模型视图设计模式核心思想" class="headerlink" title="1、模型视图设计模式核心思想"></a>1、模型视图设计模式核心思想</h2><ul><li>使模型(数据)与视图(显示)相分离。</li><li>模型只需要对外提供标准接口存取数据，无需数据如何显示。</li><li>视图只需要自定义数据显示方式，无需数据如何组织存储。</li><li>当数据发生改变时，会通过信号通知视图。</li><li>当用户与视图进行交互时，会通过信号向模型发送交互信息。</li></ul><p>在QT中提供了以下几种定义模型：</p><p><strong>QStringListModel：存储一个字符串列表。</strong></p><p><strong>QStandardItemModel：存储任意分层次的数据。</strong></p><p><strong>QDirModel：封装本地文件系统。</strong></p><p><strong>QSqlQueryModel：封装一个SQL结果集。</strong></p><p><strong>QSqlTableModel：封装一个SQL表。</strong></p><p><strong>QSqlRelationTableModel：利用外键封装一个SQL表。</strong></p><p><strong>QSortFilterProxyModel：排序和/或筛选另一个模型。</strong></p><p>其中QAbstractItemModel的常见子集有：</p><ul><li><strong>QAbstractListModel：用来创建一维列表模型。</strong></li><li><strong>QStandardItemModel：用来存储定制数据的通用模型。</strong></li><li><strong>QAbstractTableModel：用来创建二维列表模型。</strong></li></ul><p>不同的model对应着不同的view，比如我们想要显示该QAbstractTableModel模型数据，则需要使用QTableView视图。</p><h2 id="2、QAbstractIemView-视图基类"><a href="#2、QAbstractIemView-视图基类" class="headerlink" title="2、QAbstractIemView-视图基类"></a>2、QAbstractIemView-视图基类</h2><p>QAbstractIemView它的子类有：QColumnView，QHeaderView，QListView，QTableView，QTreeView。</p><p>接下来以QTreeView视图为例，设置模型视图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line"></span><br><span class="line"><span class="function">QFileSystemModel  <span class="title">model</span><span class="params">(&amp;w)</span></span>;              <span class="comment">//定义文件系统模型</span></span><br><span class="line"></span><br><span class="line"><span class="function">QTreeView   <span class="title">treeView</span><span class="params">(&amp;w)</span></span>;                 <span class="comment">//定义树形显示视图</span></span><br><span class="line"></span><br><span class="line">treeView.<span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">setRootPath</span>(QDir::<span class="built_in">currentPath</span>()); <span class="comment">//设置根目录</span></span><br><span class="line"></span><br><span class="line">treeView.<span class="built_in">setModel</span>(&amp;model);          <span class="comment">//连接模型与视图</span></span><br><span class="line"></span><br><span class="line">treeView.<span class="built_in">setRootIndex</span>(model.<span class="built_in">index</span>(QDir::<span class="built_in">currentPath</span>()));</span><br><span class="line"><span class="comment">// setRootInedex():设置树形显示视图的数据索引,以当前目录为根部显示</span></span><br><span class="line"><span class="comment">// QModelIndex index(QDir::currentPath()):以当前目录为模型项索引</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><p>其中index()是个重载函数，用来获取QModelIndex索引值，完整的index()函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QModelIndex <span class="title">QAbstractItemModel::index</span> <span class="params">( <span class="type">int</span> row, <span class="type">int</span> column, <span class="type">const</span> QModelIndex &amp; parent = QModelIndex() )</span></span>;</span><br><span class="line">       <span class="comment">//返回指定的row(行)、column(列)、parent(父索引)引所在的索引值</span></span><br></pre></td></tr></table></figure><p>也可通过index索引值来查找数据，以QFileSystemModel模型为例，与index相关的成员函数有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QIcon     <span class="title">fileIcon</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span></span>;    <span class="comment">//通过索引值获取文件图标</span></span><br><span class="line"><span class="function">QFileInfo <span class="title">fileInfo</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span></span>;    <span class="comment">//通过索引值获取文件信息</span></span><br><span class="line"><span class="function">QString   <span class="title">fileName</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span> </span>;   <span class="comment">//通过索引值获取文件名</span></span><br><span class="line"><span class="function">QString   <span class="title">filePath</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span> </span>;  <span class="comment">//通过索引值获取文件路径</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDir</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span> </span>;          <span class="comment">//通过索引值,判断是否是目录</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">columnCount</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; parent = QModelIndex() )</span> </span>; </span><br><span class="line"><span class="comment">//通过索引值获取当前列数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">rowCount</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; parent = QModelIndex() )</span> </span>; <span class="comment">//通过索引值获取行数</span></span><br><span class="line"> </span><br><span class="line"><span class="function">QModelIndex <span class="title">parent</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index )</span> </span>; <span class="comment">//通过索引值获取其父节点的索引值</span></span><br><span class="line"> </span><br><span class="line"><span class="function">QVariant  <span class="title">data</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; index, <span class="type">int</span> role = Qt::DisplayRole )</span> </span>;</span><br><span class="line">                                                 <span class="comment">//通过索引值获取模型数据</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">setData</span> <span class="params">( <span class="type">const</span> QModelIndex &amp; idx, <span class="type">const</span> QVariant &amp; value, <span class="type">int</span> role = Qt::EditRole )</span></span>;</span><br><span class="line">                                           <span class="comment">//通过索引值设置模型数据</span></span><br></pre></td></tr></table></figure><p>其中data()和setData()函数的参数role是模型数据角色。</p><h2 id="3、role数据角色"><a href="#3、role数据角色" class="headerlink" title="3、role数据角色"></a>3、role数据角色</h2><p>当role值不同时，则显示在视图上的方式也会不同。</p><p>对于role角色，常用的值有：</p><ul><li>Qt::DisplayRole             0          以文本方式显示数据(QString)</li><li>Qt::DecorationRole       1         将数据作为图标来装饰(QIcon,QPixmap)</li><li>Qt::EditRole                   2          可编辑的数据信息显示(QString)</li><li>Qt::ToolTipRole             3          作为工具提示显示(QString)</li><li>Qt::StatusTipRole          4         作为状态栏中显示的数据(QString)</li><li>Qt::WhatsThisRole        5         作为帮助信息栏中显示的数据(QString)</li><li>Qt::FontRole                   6        设置字体(QFont)</li><li>Qt::TextAlignmentRole   7       设置模型数据的文本对齐(Qt::AlignmentFlag)</li><li>Qt::BackgroundRole      8        设置模型数据的背景色(QBrush)</li><li>Qt::ForegroundRole      9         设置模型数据的前景色,比如字体(QBrush)</li></ul><p>以QTableView为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line"><span class="function">QTableView <span class="title">view</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line"><span class="function">QStandardItemModel  <span class="title">model</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">view.<span class="built_in">setModel</span>(&amp;model);          <span class="comment">//设置视图的模型</span></span><br><span class="line"></span><br><span class="line">QStandardItem itemA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置text*/</span></span><br><span class="line">itemA.<span class="built_in">setData</span>(<span class="string">&quot;A&quot;</span>,Qt::DisplayRole);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置图标*/</span></span><br><span class="line"><span class="function">QPixmap <span class="title">pix</span><span class="params">(<span class="string">&quot;:user.png&quot;</span>)</span></span>;</span><br><span class="line">pix = pix.<span class="built_in">scaled</span>(<span class="number">24</span>,<span class="number">24</span>,Qt::KeepAspectRatio);</span><br><span class="line">itemA.<span class="built_in">setData</span>(pix,Qt::DecorationRole);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置渐变背景色*/</span></span><br><span class="line"><span class="function">QLinearGradient  <span class="title">back</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">back.<span class="built_in">setColorAt</span>(<span class="number">0</span>,Qt::white);</span><br><span class="line">back.<span class="built_in">setColorAt</span>(<span class="number">0.5</span>,Qt::green);</span><br><span class="line">back.<span class="built_in">setColorAt</span>(<span class="number">1</span>,Qt::blue);</span><br><span class="line">itemA.<span class="built_in">setData</span>(<span class="built_in">QBrush</span>(back),Qt::BackgroundRole);</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">0</span>,&amp;itemA);</span><br><span class="line">model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QIcon</span>(pix),<span class="string">&quot;B&quot;</span>));</span><br><span class="line">model.<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QIcon</span>(pix),<span class="string">&quot;C&quot;</span>));</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、模型视图设计模式核心思想&quot;&gt;&lt;a href=&quot;#1、模型视图设计模式核心思想&quot; class=&quot;headerlink&quot; title=&quot;1、模型视图设计模式核心思想&quot;&gt;&lt;/a&gt;1、模型视图设计模式核心思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使模型(数据)与视图(显示)相分</summary>
      
    
    
    
    <category term="QtWidget" scheme="https://jjking20010901.github.io/categories/QtWidget/"/>
    
    
    <category term="模型和视图" scheme="https://jjking20010901.github.io/tags/%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>QTabelView函数的使用</title>
    <link href="https://jjking20010901.github.io/posts/615115d7.html"/>
    <id>https://jjking20010901.github.io/posts/615115d7.html</id>
    <published>2022-11-09T02:48:26.000Z</published>
    <updated>2022-11-20T01:45:03.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、view和model常用函数"><a href="#1、view和model常用函数" class="headerlink" title="1、view和model常用函数"></a>1、view和model常用函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTableView <span class="title">view</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置表头水平标题*/</span></span><br><span class="line">model.<span class="built_in">setHorizontalHeaderItem</span>(<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line">model.<span class="built_in">setHorizontalHeaderItem</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Sex&quot;</span>));</span><br><span class="line">model.<span class="built_in">setHorizontalHeaderItem</span>(<span class="number">2</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Age&quot;</span>));</span><br><span class="line">model.<span class="built_in">horizontalHeaderItem</span>(<span class="number">0</span>)-&gt;<span class="built_in">setFont</span>(<span class="built_in">QFont</span>(<span class="string">&quot;Helvetica&quot;</span>,<span class="number">20</span>,<span class="number">50</span>));   <span class="comment">//设置标题字体</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置表头垂直标题*/</span></span><br><span class="line">model.<span class="built_in">setVerticalHeaderItem</span>(<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;No.1&quot;</span>));</span><br><span class="line">model.<span class="built_in">setVerticalHeaderItem</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;No.2&quot;</span>));</span><br><span class="line">model.<span class="built_in">setVerticalHeaderItem</span>(<span class="number">2</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;No.3&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置列表条目数据*/</span></span><br><span class="line"><span class="function">QPixmap  <span class="title">pix</span><span class="params">(<span class="string">&quot;:user.png&quot;</span>)</span></span>;</span><br><span class="line">pix = pix.<span class="built_in">scaled</span>(<span class="number">24</span>,<span class="number">24</span>,Qt::KeepAspectRatio);</span><br><span class="line">QStandardItem *itemA=<span class="keyword">new</span> <span class="built_in">QStandardItem</span>();</span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(pix,Qt::DecorationRole);                        <span class="comment">//设置条目图标</span></span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(<span class="string">&quot;A&quot;</span>,Qt::DisplayRole);</span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(<span class="string">&quot;A:tooltip&quot;</span>,Qt::ToolTipRole);</span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(<span class="built_in">QFont</span>(<span class="string">&quot;宋体&quot;</span>,<span class="number">12</span>,QFont::Bold,<span class="literal">true</span>),Qt::FontRole); <span class="comment">//设置条目字体</span></span><br><span class="line">itemA-&gt;<span class="built_in">setData</span>(Qt::AlignCenter,Qt::TextAlignmentRole);         <span class="comment">//设置条目中心对齐</span></span><br><span class="line"><span class="comment">//可以实现按数值排序,否则的话&quot;2&quot;&gt;&quot;123&quot;itemA-&gt;setData(Qt::DisplayRole, 2); </span></span><br><span class="line"> <span class="function">QLinearGradient <span class="title">linearGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"> linearGradient.<span class="built_in">setColorAt</span>(<span class="number">0.2</span>, Qt::white);</span><br><span class="line"> linearGradient.<span class="built_in">setColorAt</span>(<span class="number">0.6</span>, Qt::green);</span><br><span class="line"> linearGradient.<span class="built_in">setColorAt</span>(<span class="number">1.0</span>, Qt::black);</span><br><span class="line"> itemA-&gt;<span class="built_in">setData</span>(<span class="built_in">QBrush</span>(linearGradient),Qt::BackgroundRole);    <span class="comment">//设置条目背景色(为渐变色)</span></span><br><span class="line"> </span><br><span class="line">   model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">0</span>,itemA);</span><br><span class="line">   model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">   model.<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;C&quot;</span>));  </span><br><span class="line">   model.<span class="built_in">item</span>(<span class="number">0</span>,<span class="number">1</span>)-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignCenter);  <span class="comment">//设置条目居中对齐</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*将数据模型的第一列进行下降排序(从大到小,不会进行整行排序)*/</span></span><br><span class="line">model.<span class="built_in">sort</span>(<span class="number">0</span>,Qt::DescendingOrder);</span><br><span class="line"><span class="comment">/*根据视图里的第一列数据,进行整行大小排序*/</span> </span><br><span class="line"> view.<span class="built_in">sortByColumn</span>(<span class="number">0</span>); </span><br><span class="line"><span class="comment">/*设置视图能够自动使能排序*/</span></span><br><span class="line">view.<span class="built_in">setSortingEnabled</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="comment">/*设置视图是否支持自动滑动*/</span> </span><br><span class="line">view.<span class="built_in">setAutoScroll</span>(<span class="type">bool</span> enable);　　  </span><br><span class="line"><span class="comment">/*设置选中一行后,标题的字体不会加粗*/</span></span><br><span class="line">view-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setHighlightSections</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="comment">/*设置列宽不可变动,在5.X后改为了setSectionResizeMode()*/</span></span><br><span class="line">view.<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setResizeMode</span>(QHeaderView::Fixed);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置行宽不可变动*/</span></span><br><span class="line">view.<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setResizeMode</span>(QHeaderView::Fixed); </span><br><span class="line"><span class="comment">/*设置用户选择模式, NoSelection表示不能选择表格*/</span> view.<span class="built_in">setSelectionMode</span>(QAbstractItemView::NoSelection);  </span><br><span class="line"><span class="comment">/*隐藏垂直标题*/</span> </span><br><span class="line">view.<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">hide</span>();  </span><br><span class="line"> </span><br><span class="line">view.<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection);                <span class="comment">//设置选择模式,表示只能选中单个  </span></span><br><span class="line">view.<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);                      <span class="comment">//设置选择行为,表示只能选择一行(也可以设置为列,或者单个Item项目) </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置表格不可编辑*/</span></span><br><span class="line">view.<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);</span><br><span class="line"><span class="comment">/*设置表头的显示与隐藏*/</span></span><br><span class="line">view.<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">view.<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*禁止显示网格线*/</span></span><br><span class="line">view.<span class="built_in">setShowGrid</span>(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*禁止显示滚动条*/</span></span><br><span class="line">view.<span class="built_in">setHorizontalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置行列的高宽*/</span></span><br><span class="line">view.<span class="built_in">setColumnWidth</span>(<span class="number">0</span>,<span class="number">50</span>);       <span class="comment">//设置column0(第1列)的宽度为50,必须要设置好model后,再来设置宽度　　</span></span><br><span class="line">view.<span class="built_in">setRowHeight</span>(<span class="number">0</span>,<span class="number">30</span>);          <span class="comment">//设置row0(第1行)的高度为30,必须setModel()后,再来设置高度</span></span><br><span class="line">view.<span class="built_in">resizeRowsToContents</span>();    <span class="comment">//更据当前内容自动调整行距</span></span><br><span class="line">view.<span class="built_in">resizeColumnsToContents</span>(); <span class="comment">//更据当前内容自动调整列距 /*禁止焦点(取消QTableView选中后的虚线框)*/  view.setFocusPolicy(Qt::NoFocus); /*获取鼠标当前位于视图的哪个index位置*/qDebug()&lt;&lt;view.currentIndex().row();  //获取行号,如果为-1,表示无效qDebug()&lt;&lt;view.currentIndex().column();//获取列号,如果为-1,表示无效  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTableView::setSpan</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, <span class="type">int</span> rowSpanCount, <span class="type">int</span> columnSpanCount)</span></span>;</span><br><span class="line"><span class="comment">//合并单元格</span></span><br><span class="line"><span class="comment">//第一个参数：要改变的单元格行数</span></span><br><span class="line"><span class="comment">//第二个参数：要改变的单元格列数</span></span><br><span class="line"><span class="comment">//第三个参数：需要合并的行数</span></span><br><span class="line"><span class="comment">//第四个参数：需要合并的列数</span></span><br><span class="line"><span class="comment">//比如: setSpan(0,0,2,3);   表示从table(0,0)开始到2,3结束,合并共2行和3列  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setVerticalScrollMode</span><span class="params">(QAbstractItemView::ScrollMode mode)</span></span>;<span class="comment">//设置滑动模式.可以设置按行滑动,还是按像素点来滑动</span></span><br></pre></td></tr></table></figure><h2 id="2、合并单元格的提醒"><a href="#2、合并单元格的提醒" class="headerlink" title="2、合并单元格的提醒"></a>2、合并单元格的提醒</h2><p>数据更新后，还要继续使用setSpan再次合并(主要是要对全表格进行重新的单元格合并，已经合并过的地方行列又要重新进行新的合并，因为数据已经更新)，这时不能直接使用setSpan，而是要先把QTableView的row还原为原来没有合并行列的情形，再次使用setSpan。</p><p><strong>对于QStandardItem的setData()的成员函数的第二个参数role是模型数据角色。</strong></p><p><strong>当role值不同时，则显示在视图上的方式也会不同。对于role角色，常用值有</strong>：</p><ul><li>Qt::DisplayRole   0      以文本方式显示数据(QString)</li><li>Qt::DecorationRole    1   将数据作为图标来装饰(QIcon,QPixmap)</li><li>Qt::EditRole    2         可编辑的数据信息显示(QString)</li><li>Qt::ToolTipRole   3     作为工具提示显示(QString)</li><li>Qt::StatusTipRole  4     作为状态栏中显示的数据(QString)</li><li>Qt::WhatsThisRole 5       作为帮助信息栏中显示的数据(QString)</li><li>Qt::FontRole     6        设置字体(QFont)</li><li>Qt::TextAlignmentRole  7   设置模型数据的文本对齐(Qt::AlignmentFlag)</li><li>Qt::BackgroundRole   8   设置模型数据的背景色(QBrush)</li><li>Qt::ForegroundRole   9   设置模型数据的前景色,比如字体(QBrush)</li></ul><h2 id="3、实现右击菜单"><a href="#3、实现右击菜单" class="headerlink" title="3、实现右击菜单"></a>3、实现右击菜单</h2><p>当用户在QTableView视图里右击鼠标时，便会触发一个QEvent::ContextMenu类型的事件。所以通过事件过滤器来实现右击菜单的效果。</p><p>步骤：</p><ul><li><strong>定义菜单对象。</strong></li><li><strong>通过QMenu的addAction()函数来添加子项，并连接槽函数。</strong></li><li><strong>定义事件过滤器，判断是否是QTableView的QEvent::ContextMenu事件。</strong></li><li><strong>判断成功，则调用menu.exec(this-&gt;cursor.pos())，在当前鼠标光标位置打开菜单。</strong></li></ul><p>Widget.h的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QMenu&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">Widget</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_delete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    QTableView view;</span><br><span class="line">    QStandardItemModel model;</span><br><span class="line">    QMenu menu;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Widget.cpp代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent),</span><br><span class="line">      <span class="built_in">view</span>(<span class="keyword">this</span>),</span><br><span class="line">      <span class="built_in">model</span>(<span class="keyword">this</span>),</span><br><span class="line">      <span class="built_in">menu</span>(<span class="keyword">this</span>)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模型设置</span></span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;C++&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Python&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">2</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;C#&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Js&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">3</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;CSS&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">3</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;html&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*视图只能选中一行，取消焦点，禁止编辑*/</span></span><br><span class="line">    view.<span class="built_in">setFocusPolicy</span>(Qt::NoFocus);</span><br><span class="line">    view.<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);</span><br><span class="line">    view.<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection);</span><br><span class="line">    view.<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);</span><br><span class="line">    view.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安装过滤器</span></span><br><span class="line">    view.<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置菜单并绑定槽函数</span></span><br><span class="line">    menu.<span class="built_in">addAction</span>(<span class="string">&quot;删除&quot;</span>,<span class="keyword">this</span>,Widget::on_delete);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Widget::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(watched==&amp;view &amp;&amp; event-&gt;<span class="built_in">type</span>()==QEvent::ContextMenu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(view.<span class="built_in">currentIndex</span>().<span class="built_in">isValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在当前鼠标位置运行菜单</span></span><br><span class="line">            menu.<span class="built_in">exec</span>(<span class="keyword">this</span>-&gt;<span class="built_in">cursor</span>().<span class="built_in">pos</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(watched,event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据视图中索引行的的位置删除一行</span></span><br><span class="line">    model.<span class="built_in">removeRow</span>(view.<span class="built_in">currentIndex</span>().<span class="built_in">row</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、view和model常用函数&quot;&gt;&lt;a href=&quot;#1、view和model常用函数&quot; class=&quot;headerlink&quot; title=&quot;1、view和model常用函数&quot;&gt;&lt;/a&gt;1、view和model常用函数&lt;/h2&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="QtWidget" scheme="https://jjking20010901.github.io/categories/QtWidget/"/>
    
    
    <category term="模型和视图" scheme="https://jjking20010901.github.io/tags/%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>chrono时间库</title>
    <link href="https://jjking20010901.github.io/posts/ae80a404.html"/>
    <id>https://jjking20010901.github.io/posts/ae80a404.html</id>
    <published>2022-11-08T11:35:37.000Z</published>
    <updated>2022-11-20T01:43:57.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、std-chrono标准时间库"><a href="#1、std-chrono标准时间库" class="headerlink" title="1、std::chrono标准时间库"></a>1、std::chrono标准时间库</h2><p>利用CPP强类型的特点，明确区分<strong>时间点和时间段</strong>，明确区分不同的<strong>时间单位</strong>。</p><ul><li>时间点例子：2022年11月8日12点:55分:10秒。</li><li>时间段例子：1分30秒。</li><li>时间点类型：chrono::steady_clock::time_point等。</li><li>时间段类型：chrono::millseconds，chrono::seconds，chrono::minutes等。</li><li>方便的运算符重载：时间点+时间段=时间点，时间点-时间点=时间段。</li></ul><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t0=chrono::steady_clock::<span class="built_in">now</span>();     <span class="comment">//获取当前时间点</span></span><br><span class="line"><span class="keyword">auto</span> t1=t0+chrono::<span class="built_in">seconds</span>(<span class="number">30</span>); <span class="comment">//当前时间点的30秒后</span></span><br><span class="line"><span class="keyword">auto</span> dt=t1-t0;  <span class="comment">//获取两个时间点的差(时间段)</span></span><br><span class="line"><span class="keyword">auto</span> sec=chrono::<span class="built_in">duration_cast</span>&lt;chrono::seconds&gt;(dt).<span class="built_in">count</span>(); <span class="comment">//时间差的秒数</span></span><br></pre></td></tr></table></figure><h2 id="2、案例：计算花费时间"><a href="#2、案例：计算花费时间" class="headerlink" title="2、案例：计算花费时间"></a>2、案例：计算花费时间</h2><p>在所执行的程序未执行时，先通过chrono::steady_clock::now()获取当前时间点，然后执行程序，再通过chrono::steady_clock::now()获取执行程序后的时间点，最后两个时间点相减得到程序所耗费时间段，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++);</span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">int</span> dt = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(endTime - startTime).<span class="built_in">count</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;run time: &quot;</span> &lt;&lt; dt &lt;&lt; <span class="string">&quot;ms&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202211081320809.png" alt="image-20221108132005750"></p><p>上面是执行时间段为整形，如下是输出double类型的时间段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++);</span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">using</span> double_ms = std::chrono::duration&lt;<span class="type">double</span>, std::milli&gt;;</span><br><span class="line"><span class="keyword">auto</span> dt = std::chrono::<span class="built_in">duration_cast</span>&lt;double_ms&gt;(endTime - startTime).<span class="built_in">count</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;run time: &quot;</span> &lt;&lt; dt &lt;&lt; <span class="string">&quot;ms&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：duration_cast可以在任意的duration类型之间转换，duration<T,R>表示用T类型表示，且时间单位用R。</strong></p><p><strong>R省略不写就代表秒，std::milli就是毫秒，std::micro就是微秒。seconds是duration<int64_t>的类型别名。</strong></p><p><strong>millseconds是duration&lt; int64_t,std::mill &gt;的类型别名。</strong></p><p><strong>这里我们创建了double_ms作为duration&lt; double,std::mill&gt;的别名。</strong></p><h2 id="3、跨平台sleep：this-thread-sleep-for"><a href="#3、跨平台sleep：this-thread-sleep-for" class="headerlink" title="3、跨平台sleep：this_thread::sleep_for"></a>3、跨平台sleep：this_thread::sleep_for</h2><p>可以使用std::this_thread::sleep_for代替Unix操作系统专有的usleep。它可以让当前线程休眠一段时间，然后继续运行，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的休眠单位可以自己指定，比如这里是millseconds表示毫秒，也可以换成microseconds表示微秒，seconds表示秒，chrono的强类型让单位选择更自由，而且chrono时间库的精度更准确。</strong></p><h2 id="4、睡到时间点：std-this-thread-sleep-until"><a href="#4、睡到时间点：std-this-thread-sleep-until" class="headerlink" title="4、睡到时间点：std::this_thread::sleep_until"></a>4、睡到时间点：std::this_thread::sleep_until</h2><p>除了接受一个时间段sleep_for，还有接受一个时间点的sleep_until，表示让当前线程休眠到某个时间点。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> t=std::chrono::steady_clock::<span class="built_in">now</span>()+std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_until</span>(t);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、std-chrono标准时间库&quot;&gt;&lt;a href=&quot;#1、std-chrono标准时间库&quot; class=&quot;headerlink&quot; title=&quot;1、std::chrono标准时间库&quot;&gt;&lt;/a&gt;1、std::chrono标准时间库&lt;/h2&gt;&lt;p&gt;利用CPP强类型</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++11多线程" scheme="https://jjking20010901.github.io/tags/C-11%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CPP面试题目01</title>
    <link href="https://jjking20010901.github.io/posts/b275f201.html"/>
    <id>https://jjking20010901.github.io/posts/b275f201.html</id>
    <published>2022-11-06T10:50:53.000Z</published>
    <updated>2022-11-06T12:14:30.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、C和CPP的区别"><a href="#1、C和CPP的区别" class="headerlink" title="1、C和CPP的区别"></a>1、C和CPP的区别</h2><p>1、C是面向过程的语言，是一个结构化的语言，而CPP是面向对象的语言，主要特征是封装、继承、多态。</p><p>2、C和C++动态管理内存的方法不一样，C是使用malloc/free，而CPP是new/delete、。</p><p>3、CPP中有引用，C不存在引用的概念。</p><h2 id="2、CPP中指针和引用的区别"><a href="#2、CPP中指针和引用的区别" class="headerlink" title="2、CPP中指针和引用的区别"></a>2、CPP中指针和引用的区别</h2><p>1、指针是一个新的变量，存储另一个变量的地址，我们可以通过访问这个地址来修改这个变量。引用只是一个别名，还是变量本身，对引用的任何操作就是对变量本身的操作，以达到修改变量的目的。</p><p>2、引用只有一级，而指针有多级。</p><p>3、指针传参时，还是值传递，指针本身的值不可修改，需要通过解引用才能对指向对象进行操作。引用传参时，传进来的就是变量本身，因此变量可以被修改。</p><h2 id="3、结构体struct和union-联合-的区别"><a href="#3、结构体struct和union-联合-的区别" class="headerlink" title="3、结构体struct和union(联合)的区别"></a>3、结构体struct和union(联合)的区别</h2><p>1、结构体：将不同类型的数据组合成一个整体，是自定义类型。共同体：不同类型的几个变量共同占用一段内存</p><p>2、结构体中的每个成员都有自己独立的地址，它们是同时存在的。共同体中的所有成员占用同一段内存，它们不能同时存在。</p><h2 id="4、-define和const的区别"><a href="#4、-define和const的区别" class="headerlink" title="4、#define和const的区别"></a>4、#define和const的区别</h2><p>1、#define定义的常量没有类型，所以给出的是一个立即数；const定义的常量有类型名字，存放在静态区域。</p><p>2、处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。</p><p>3、#define定义的常量是不可以用指针去指向的，const定义的常量可以用指针去指向该常量的地址。</p><p>4、#define可以定义简单的函数，const不可以定义函数。</p><h2 id="5、new、delete、malloc、free之间的关系"><a href="#5、new、delete、malloc、free之间的关系" class="headerlink" title="5、new、delete、malloc、free之间的关系"></a>5、new、delete、malloc、free之间的关系</h2><p>1、malloc对开辟的空间大小严格指定，而new只需要对象名。</p><p>2、new为对象分配空间时，调用类对象的构造函数，delete调用类对象的析构函数。</p><p>3、malloc/free是库函数，new/delete是CPP的运算符。</p><p>对于非内部数据类型而言，光用malloc/free无法满足动态类对象的要求。new/delete是运算符，编译器保证调用构造和析构函数对类对象进行初始化/析构。但是库函数malloc/free，不会执行构造/析构。</p><h2 id="6、delete和delete-的区别"><a href="#6、delete和delete-的区别" class="headerlink" title="6、delete和delete[]的区别"></a>6、delete和delete[]的区别</h2><p>1、delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数。</p><p>2、用new分配的内存用delete释放，用new[]分配的内存用delete[]释放。</p><h2 id="7、const的作用"><a href="#7、const的作用" class="headerlink" title="7、const的作用"></a>7、const的作用</h2><p>1、const修饰类的成员变量，表示常量不可能被修改。</p><p>2、const修饰类的成员函数，表示函数不会修改类中的数据成员，不会调用其他非const的成员函数。</p><p>3、const函数只能调用const函数，非const函数可以调用const函数。</p><h2 id="8、堆和栈的区别"><a href="#8、堆和栈的区别" class="headerlink" title="8、堆和栈的区别"></a>8、堆和栈的区别</h2><p>1、栈 stack 存放函数的参数值、局部变量，由编译器自动分配释放。堆heap，是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收。</p><p>2、因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片。</p><h2 id="9、关键字static的作用"><a href="#9、关键字static的作用" class="headerlink" title="9、关键字static的作用"></a>9、关键字static的作用</h2><p>1、函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值。</p><p>2、模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内。</p><p>3、类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝。</p><p>4、类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量。</p><p><strong>注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象。</strong></p><h2 id="10、什么是内存泄漏？面对内存泄漏和指针越界的方法？"><a href="#10、什么是内存泄漏？面对内存泄漏和指针越界的方法？" class="headerlink" title="10、什么是内存泄漏？面对内存泄漏和指针越界的方法？"></a>10、什么是内存泄漏？面对内存泄漏和指针越界的方法？</h2><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p><p>方法：malloc/free要配套，对指针赋值的时候应该注意被赋值的指针是否需要释放；使用的时候记得指针的长度，防止越界。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://jjking20010901.github.io/posts/2b7ca3bb.html">CPP面试题目02</a></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、C和CPP的区别&quot;&gt;&lt;a href=&quot;#1、C和CPP的区别&quot; class=&quot;headerlink&quot; title=&quot;1、C和CPP的区别&quot;&gt;&lt;/a&gt;1、C和CPP的区别&lt;/h2&gt;&lt;p&gt;1、C是面向过程的语言，是一个结构化的语言，而CPP是面向对象的语言，主要特</summary>
      
    
    
    
    <category term="CPP面试题目" scheme="https://jjking20010901.github.io/categories/CPP%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
    <category term="面试题目" scheme="https://jjking20010901.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>CPP实现Vector容器</title>
    <link href="https://jjking20010901.github.io/posts/f6e04cde.html"/>
    <id>https://jjking20010901.github.io/posts/f6e04cde.html</id>
    <published>2022-11-05T12:42:52.000Z</published>
    <updated>2022-11-06T02:30:33.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、实现一个高性能且跨平台的Vector"><a href="#1、实现一个高性能且跨平台的Vector" class="headerlink" title="1、实现一个高性能且跨平台的Vector"></a>1、实现一个高性能且跨平台的Vector</h2><p>知识点：</p><ul><li>CPP泛型编程(模板)</li><li>面向对象</li><li>运算符重载</li><li>CPP11的时间库</li><li>std标准库中实现内存移动的api</li></ul><p>Github：<a href="https://github.com/jjking20010901/Vector/tree/master">cpp实现vector</a></p><h2 id="2、API的封装"><a href="#2、API的封装" class="headerlink" title="2、API的封装"></a>2、API的封装</h2><p><strong>push_back(const T &amp;value)</strong>的解读：在向量的末尾，在其当前最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新元素。这有效地将容器大小增加了一个，这会导致自动重新分配分配的存储空间，前提是（并且仅当）新的向量大小超过当前向量容量。</p><p>push_back的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:尾插法插入数据</span></span><br><span class="line"><span class="comment"> * @param:泛型的数据</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&lt;m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[m_size]=value;</span><br><span class="line">        m_size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_capacity == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_capacity=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//容量不为0，则二倍扩容</span></span><br><span class="line">        m_capacity *=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开辟新的容量的容器</span></span><br><span class="line">    T *data= <span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="comment">//将原来容器中的数据移动到新的容器中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将原来容器的位置的内存释放</span></span><br><span class="line">    <span class="keyword">if</span>(m_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">    m_data[m_size]=value;</span><br><span class="line">    m_size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop_back()的解读：删除最后一个元素，移除向量中的最后一个元素，有效地将容器大小减少一个。</p><p>pop_back()的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:尾部弹出数据</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size()和capacity()方法的解读：获取容器中的元素数目；获取容器的容量。</p><p>size()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器当前大小</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器当前大小</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>capacity()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器容量</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器容量</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">capacity</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reserve(int n)方法解读：如果n大于当前向量容量，则该函数会导致容器重新分配其存储，将其容量增加到n（或更大）。在所有其他情况下，函数调用不会导致重新分配，向量容量也不会受到影响。</p><p>reserve(int n)方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:重新分配容器容量</span></span><br><span class="line"><span class="comment"> * @param:输入的容量</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">reserve</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_capacity&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩容，条件是当容量小于传入的容量大小</span></span><br><span class="line">    <span class="keyword">while</span>(m_capacity&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_capacity ==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态内存申请容量</span></span><br><span class="line">    T *data=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_data!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resize(int size)方法的解读：调整容器大小，使其包含size个元素，如果size小于当前容器大小，则内容将减少到其前size个元素，并删除（并销毁）超出的元素，如果size大于当前容器大小，则通过在末尾插入尽可能多的元素来扩展内容，以达到size的大小。如果指定了val，则将新元素初始化为val的副本，否则将对其进行值初始化。</p><p>resize(int size)方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:重新分配容器大小</span></span><br><span class="line"><span class="comment"> * @param:输入的大小</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">resize</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//容器内部大小大于或等于输入的大小</span></span><br><span class="line">    <span class="keyword">if</span>(m_size&gt;=size)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size=size;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容器内部大小小于输入大小并且输入大小小于容器容量</span></span><br><span class="line">    <span class="keyword">if</span>(m_size &lt; size &amp;&amp; size&lt; m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m_size;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[i]=<span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_size=size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入大小大于容器容量</span></span><br><span class="line">    <span class="keyword">while</span>(m_capacity&lt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_capacity==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态申请扩容</span></span><br><span class="line">    T *data=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m_size;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_data!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">    m_size=size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>at(int index)方法的解读：返回容器中index索引位置的值。</p><p>at(int index)方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器索引下标的值</span></span><br><span class="line"><span class="comment"> * @param:容器索引下标</span></span><br><span class="line"><span class="comment"> * @return:返回容器索引下标的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不符合要求的数组下标，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;= m_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vec[] out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[]运算符的重载的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:重载中括号并获取索引下标值</span></span><br><span class="line"><span class="comment"> * @param:索引下标</span></span><br><span class="line"><span class="comment"> * @return:容器索引下标的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="keyword">operator</span> [] (<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>empty()方法和clear()方法的解读：判断容器是否为空；清空容器的元素。</p><p>empty()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:判断容器是否为空</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:若容器有数据返回true,否则返回false</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Vector&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:清空容器的数据</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_size=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>front()方法和back()方法的解读：获取容器第一个元素的值；获取最后一个元素的值。</p><p>front()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器的第一个元素的值</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器第一个元素的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vec is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>back()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:获取容器最后一个元素的值</span></span><br><span class="line"><span class="comment"> * @param:无</span></span><br><span class="line"><span class="comment"> * @return:返回容器最后一个元素的值</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_size&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vec is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_data[m_size<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap()方法的解读：交换两个容器的元素、大小以及容量。</p><p>swap()方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:交换两个容器的数据、大小以及容量</span></span><br><span class="line"><span class="comment"> * @param:另一个容器对象</span></span><br><span class="line"><span class="comment"> * @return:无</span></span><br><span class="line"><span class="comment"> * @author:SY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">swap</span>(Vector&lt;T&gt; &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存储另外一个数组的临时数据</span></span><br><span class="line">    T *data=other.m_data;</span><br><span class="line">    <span class="type">int</span> size=other.m_size;</span><br><span class="line">    <span class="type">int</span> capacity=other.m_capacity;</span><br><span class="line"></span><br><span class="line">    other.m_data=m_data;</span><br><span class="line">    other.m_size=m_size;</span><br><span class="line">    other.m_capacity=m_capacity;</span><br><span class="line"></span><br><span class="line">    m_data=data;</span><br><span class="line">    m_size=size;</span><br><span class="line">    m_capacity=capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些api这里就不再做过多的解释，直接去gtihub看我的代码就行。</p><h2 id="3、Iterator的封装"><a href="#3、Iterator的封装" class="headerlink" title="3、Iterator的封装"></a>3、Iterator的封装</h2><p>在Vector中封装一个Iterator的类，用来代表迭代器。这里主要是通过运算符重载来实现迭代器的api。</p><p>两个迭代器相等的判断以及不等的判断的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Iterator &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pointer==other.m_pointer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> Iterator &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pointer !=other.m_pointer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器的拷贝赋值重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator &amp; <span class="keyword">operator</span> = (<span class="type">const</span> Iterator &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer=other.m_pointer;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器前置加1以及后置加1的封装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置加1</span></span><br><span class="line">Iterator <span class="keyword">operator</span> ++ ()</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置加1</span></span><br><span class="line">Iterator <span class="keyword">operator</span> ++ (<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Iterator it=*<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器加法和减法运算重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器加法运算重载</span></span><br><span class="line">Iterator <span class="keyword">operator</span> + (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    Iterator it=*<span class="keyword">this</span>;</span><br><span class="line">    it.m_pointer+=value;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器减法运算重载</span></span><br><span class="line">Iterator &amp; <span class="keyword">operator</span> - (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    Iterator it=*<span class="keyword">this</span>;</span><br><span class="line">    it.m_pointer-=value;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器+=和-=的重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器+=运算重载</span></span><br><span class="line">Iterator &amp; <span class="keyword">operator</span> += (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer+=value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器-=运算符重载</span></span><br><span class="line">Iterator &amp; <span class="keyword">operator</span> -= (<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    m_pointer-=value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器解引用和指针操作重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器解引用运算符重载</span></span><br><span class="line">T &amp; <span class="keyword">operator</span> * ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *m_pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器指针操作的运算符重载</span></span><br><span class="line">T * <span class="keyword">operator</span> -&gt; ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起始迭代器和结束迭代器的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//起始迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">begin</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(m_data)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">end</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;T&gt;::<span class="function">Iterator <span class="title">it</span><span class="params">(m_data+m_size)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代器查找某个元素的位置(<strong>该方法STL-vector中未实现</strong>)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">find</span>(<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(Vector&lt;T&gt;::Iterator it=<span class="built_in">begin</span>();it!=<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert()方法的解读：通过在指定位置的元素之前插入新元素来扩展向量，从而有效地增加插入的元素数量的容器大小。</p><p>insert()方法的实现(函数重载)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator it,<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insert</span>(it,<span class="number">1</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator it,<span class="type">int</span> n,<span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取插入位置的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> pos=it-<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//插入元素足够存放(无需扩容的情况)  </span></span><br><span class="line">    <span class="keyword">if</span>(m_size+n&lt;=m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当内部内存发生重叠使用memmove，拷贝内存，否则使用memcpy</span></span><br><span class="line">            std::<span class="built_in">memmove</span>(m_data+pos+n,m_data+pos,(m_size-pos)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m_size;i&gt;pos;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                m_data[i+n<span class="number">-1</span>]=m_data[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[pos+i]=value;</span><br><span class="line">        &#125;</span><br><span class="line">        m_size+=n;</span><br><span class="line">        <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">Iterator</span>(m_data+pos);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素过多,大于数组容量(扩容)</span></span><br><span class="line">    <span class="keyword">while</span>(m_size+n&gt;m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_capacity==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T *data=<span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memcpy</span>(data,m_data,m_size*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pos;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i]=m_data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memcpy</span>(data+pos+n,m_data+pos,(m_size-pos)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;m_size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i]=m_data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[pos+i]=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_data!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data=data;</span><br><span class="line">    m_size+=n;</span><br><span class="line">    <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">Iterator</span>(m_data+pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>erase()方法的解读：从向量中移除单个元素（位置）或一系列元素（[第一个，最后一个））。</p><p>erase()方法的实现(函数重载)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断删除的元素是否为最后一个</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">end</span>() - it ==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除其他位置的元素</span></span><br><span class="line">    <span class="type">int</span> pos = it - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memmove</span>(m_data+pos,m_data+pos+<span class="number">1</span>,(m_size-pos<span class="number">-1</span>)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;m_size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[i]=m_data[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_size-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::Iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Vector&lt;T&gt;::Iterator first,</span><br><span class="line">                                              <span class="type">const</span> Vector&lt;T&gt;::Iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取消除元素的第一个区间</span></span><br><span class="line">    <span class="type">int</span> f=first - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//获取消除元素的第二个区间</span></span><br><span class="line">    <span class="type">int</span> l=last - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//数组长度变化</span></span><br><span class="line">    <span class="type">int</span> pos = last - first;</span><br><span class="line">    <span class="comment">//判断是否为基本类型，提高删除性能</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_basic_type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">memmove</span>(m_data+f,m_data+l,(m_size-l)*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//元素向前移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_size-l;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[f]=m_data[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_size-=pos;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、STL-vector与Sakura-Vector性能对比"><a href="#4、STL-vector与Sakura-Vector性能对比" class="headerlink" title="4、STL-vector与Sakura-Vector性能对比"></a>4、STL-vector与Sakura-Vector性能对比</h2><p>insert()方法性能比较，代码如下：</p><p>STL-vector插入bool类型数据的时间(以插入10000个数据为例)：</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105202833288.png" alt="image-20221105202833288"></p><p>我们可以发现STL-vector所用时间为870.335ms。</p><p>Sakura-Vector插入bool类型数据的时间(以插入10000个数据为例)：</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105202959214.png" alt="image-20221105202959214"></p><p>我们可以发现Sakura-Vector所用时间为4.0109ms，其他类型的插入大体和STL-vector相近。</p><p>STL-vector删除bool类型数据的时间:</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105203859908.png" alt="image-20221105203859908"></p><p>我们可以发现STL-vector所用时间为984.158ms。</p><p>Sakura-Vector删除bool类型数据所用时间：</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105204011490.png" alt="image-20221105204011490"></p><p>我们可以发现Sakura-Vector所用时间为1.0451ms。</p><p>insert()的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*测试insert性能*/</span></span><br><span class="line">    <span class="keyword">auto</span> startTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max=<span class="number">10000</span>;</span><br><span class="line">    <span class="comment">//std::vector&lt;bool&gt;v;</span></span><br><span class="line">    Vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(),<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> endTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//毫秒级</span></span><br><span class="line">    <span class="type">double</span> duration_millsecond=std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>,std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;run time: &quot;</span>&lt;&lt; duration_millsecond&lt;&lt;<span class="string">&quot; ms&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>erase()的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*测试erase性能*/</span></span><br><span class="line"><span class="comment">// std::vector&lt;bool&gt;v1;</span></span><br><span class="line"> Vector&lt;<span class="type">bool</span>&gt;v1;</span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> max=<span class="number">10000</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     v1.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">auto</span> startTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">auto</span> endTime=std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"> <span class="type">double</span> duration_millsecond=std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>,std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"> std::cout&lt;&lt;<span class="string">&quot;run time: &quot;</span>&lt;&lt; duration_millsecond&lt;&lt;<span class="string">&quot; ms&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、实现一个高性能且跨平台的Vector&quot;&gt;&lt;a href=&quot;#1、实现一个高性能且跨平台的Vector&quot; class=&quot;headerlink&quot; title=&quot;1、实现一个高性能且跨平台的Vector&quot;&gt;&lt;/a&gt;1、实现一个高性能且跨平台的Vector&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="CPP项目实战" scheme="https://jjking20010901.github.io/categories/CPP%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="CPP造轮子" scheme="https://jjking20010901.github.io/tags/CPP%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>共享智能指针</title>
    <link href="https://jjking20010901.github.io/posts/4c183086.html"/>
    <id>https://jjking20010901.github.io/posts/4c183086.html</id>
    <published>2022-11-05T07:39:40.000Z</published>
    <updated>2022-11-20T01:43:20.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="智能指针的简介"><a href="#智能指针的简介" class="headerlink" title="智能指针的简介"></a>智能指针的简介</h2><p>在C++中没有垃圾回收机制，必须自己释放分配内存，否则就会造成内存泄漏。解决这个问题最有效的方法是使用智能指针(smart pointer)。<strong>智能指针是存储指向动态内存分配(堆)对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动的销毁动态分配的对象，防止内存泄漏。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</strong></p><p>C++11中提供了三种智能指针，使用这些智能指针时所需要引用的头文件为<strong><memory></strong>：</p><ul><li>std::shared_ptr：共享智能指针。</li><li>std::unique_ptr：独占智能指针。</li><li>std::weak_ptr：弱引用智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li></ul><h2 id="1、shared-ptr的初始化"><a href="#1、shared-ptr的初始化" class="headerlink" title="1、shared_ptr的初始化"></a>1、shared_ptr的初始化</h2><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，<strong>共享智能指针shared_ptr是一个模板类</strong>，<strong>如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。</strong>共享智能指针对象初始化完毕后就指向了要管理的那块堆内存，如果想要查看当前有多少智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数<strong>use_count，</strong>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><h2 id="1-1、通过构造函数初始化"><a href="#1-1、通过构造函数初始化" class="headerlink" title="1.1、通过构造函数初始化"></a>1.1、通过构造函数初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数, 语法格式如下:</span></span><br><span class="line">std::shared_ptr&lt;T&gt; 智能指针名字(创建堆内存);</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1.use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2.use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3.use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4.use_count: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191005888.png" alt="image-20220819100556838"></p><p><strong>注意：</strong></p><p><strong>如果智能指针被初始化一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为nullptr空指针，引用计数不会+1，另外，不要使用一个原始指针初始化多个shared_ptr。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">// error, 编译不会报错, 运行会出错，指针p已经初始化了p1了</span></span><br></pre></td></tr></table></figure><h2 id="1-2、通过拷贝和移动构造函数初始化"><a href="#1-2、通过拷贝和移动构造函数初始化" class="headerlink" title="1.2、通过拷贝和移动构造函数初始化"></a>1.2、通过拷贝和移动构造函数初始化</h2><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就可以被自动调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(std::move(ptr1))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">move</span>(ptr2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序结果的输出如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191016085.png" alt="image-20220819101609028"></p><p><strong>注意：</strong></p><p><strong>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始化智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存引用计数不会变化。</strong></p><h2 id="1-3、通过std-make-shared初始化"><a href="#1-3、通过std-make-shared初始化" class="headerlink" title="1.3、通过std::make_shared初始化"></a>1.3、通过std::make_shared初始化</h2><p>通过C++提供的std::make_shared()就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>T：模板参数的数据类型。</strong></p></li><li><p><strong>Arg&amp;&amp;…arg：要初始化的数据，如果是通过make_shared创建对象，需要按照构造函数的参数列表指定。</strong></p></li></ul><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(string str) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr2 = <span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr3 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr4 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码的输出结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191031378.png" alt="image-20220819103120318"></p><p><strong>注意：</strong></p><p><strong>使用st::make_shared()模板函数可以完成内存地址的创建，并将最终的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的()可完成地址的初始化，如果要创建一个类对象，函数的()内部需要指定构造函数对象需要的参数，也就是类构造函数的参数。</strong></p><h2 id="1-4、通过reset方法初始化"><a href="#1-4、通过reset方法初始化" class="headerlink" title="1.4、通过reset方法初始化"></a>1.4、通过reset方法初始化</h2><p>共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter, <span class="keyword">class</span> Alloc &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d, Alloc alloc )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>ptr：指向要取得所有权的对象的指针。</strong></li><li><strong>d：指向要取得所有权的对象的指针。</strong></li><li><strong>aloc：内部存储所用的分配器。</strong></li></ul><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1.use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2.use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3.use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4.use_count: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    ptr4.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1.use_count: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2.use_count: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3.use_count: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4.use_count: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5.use_count: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码输出结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191041241.png" alt="image-20220819104137179"></p><p><strong>注意：</strong></p><p><strong>对于一个未初始化的共享内存指针，可以通过reset方法初始化，当智能指针中有值时，调用reset方法会使引用计数减1。</strong></p><h2 id="1-5、获取原始指针"><a href="#1-5、获取原始指针" class="headerlink" title="1.5、获取原始指针"></a>1.5、获取原始指针</h2><p>对应用基础数据类型来说，通过操作智能指针和操作智能指针管理内存效果是一样的，可以直接完成数据的读写。</p><p>但是如果共享智能指针管理的是一个对象，那么就需要去除原始内存地址再操作，可以调用共享智能指针类提供的get方法得到原始地址，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">128</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[len])</span></span>;</span><br><span class="line">    <span class="comment">// 得到指针的原始地址</span></span><br><span class="line">    <span class="type">char</span>* add = ptr.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//初始化字符串</span></span><br><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0</span>, len);</span><br><span class="line">    <span class="built_in">strcpy</span>(add, <span class="string">&quot;I will be luffy !!!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; add &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; *p.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序的输出如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208191056577.png" alt="image-20220819105634516"></p><h2 id="2、指定删除器"><a href="#2、指定删除器" class="headerlink" title="2、指定删除器"></a>2、指定删除器</h2><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针给析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数的本质就是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义删除器函数，释放int型内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int 型内存被释放了...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), deleteIntPtr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除器函数也可以lambda表达式，因此代码也可以写成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<strong>lambda表达式的参数就是智能指针管理内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</strong></p><p>在C++11中使用shared_ptr管理动态数组，需要指定删除器，因为std::make_shared_ptr的默认删除器不支持数组对象，具体处理代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在删除数组内存时，除了自己编写删除器，也可以使用<strong>C++提供的std::default_delete<T>()</strong>函数作为删除器。</p><p>这个函数内部删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型指定为什么类型即可，具体处理代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们也可以自己封装一个make_shared_array方法让shared_ptr支持数组，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_share_array</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回匿名对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T[size], <span class="built_in">default_delete</span>&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_share_array</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">char</span>&gt; ptr2 = <span class="built_in">make_share_array</span>&lt;<span class="type">char</span>&gt;(<span class="number">128</span>);</span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;智能指针的简介&quot;&gt;&lt;a href=&quot;#智能指针的简介&quot; class=&quot;headerlink&quot; title=&quot;智能指针的简介&quot;&gt;&lt;/a&gt;智能指针的简介&lt;/h2&gt;&lt;p&gt;在C++中没有垃圾回收机制，必须自己释放分配内存，否则就会造成内存泄漏。解决这个问题最有效的方法是使</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="智能指针" scheme="https://jjking20010901.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>RALL原则和unique_ptr</title>
    <link href="https://jjking20010901.github.io/posts/d2973973.html"/>
    <id>https://jjking20010901.github.io/posts/d2973973.html</id>
    <published>2022-11-05T07:31:56.000Z</published>
    <updated>2022-11-20T01:43:36.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、RALL简介"><a href="#1、RALL简介" class="headerlink" title="1、RALL简介"></a>1、RALL简介</h2><p><strong>RALL是resource acquisition is initialization的缩写，意思是”资源获取即初始化”。</strong>它是C++之父Bjarne Stroustrup提出的设计理念，其核心是把资源和对象的声明周期绑定，对象创建获取资源，对象销毁释放资源。在RALL的指导下，C++把底层的资源管理问题提升到了对象声明周期管理的更高层次。</p><h2 id="2、RALL机制"><a href="#2、RALL机制" class="headerlink" title="2、RALL机制"></a>2、RALL机制</h2><ul><li>使用C++时，最让人头疼的便是内存管理，但却又正是对内存高度可操作性给了C++程序员极大自由和装逼资本。</li><li>当我们在堆区new出一块内存空间，在使用完之后，如果不使用delete来释放这块资源则将导致内存泄漏，这在中大型项目中极具有破坏性。但人无完人，我们并不能保证每次都记得释放无法再次获取到且不再使用的内存，下面给出一个例子，让大家看看忘记释放资源造成内存泄漏多么恐怖！！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *ptr=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">        ptr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        ptr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        ptr[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//delete ptr    //忘记释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果(未释放内存)：</p><p>运行程序并打开资源管理器，可以发现这么简单的程序竟然占用了11点几的MB内存，所以大家千万要记得释放内存。</p><p><img src="C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20221105150404335.png" alt="image-20221105150404335"></p><h2 id="3、智能指针的介绍"><a href="#3、智能指针的介绍" class="headerlink" title="3、智能指针的介绍"></a>3、智能指针的介绍</h2><p>在 C++ 中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<strong>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</strong></p><p>C++11中提供了三种智能指针，使用这些智能指针需要引入头文件<memory>：</p><ul><li><strong>std::shared_ptr</strong>:共享的智能指针。</li><li><strong>std::unique_ptr</strong>:独占的智能指针。</li><li><strong>std::weak_ptr</strong>:弱引用智能指针，它不共享指针，不能操作资源，是用来监视std::shared_ptr的。</li></ul><h2 id="4、unique-ptr的初始化"><a href="#4、unique-ptr的初始化" class="headerlink" title="4、unique_ptr的初始化"></a>4、unique_ptr的初始化</h2><p>std::unique_ptr 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 unique_ptr 赋值给另一个 unique_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过构造函数初始化对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="comment">// error, 不允许将一个unique_ptr赋值给另一个unique_ptr</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br></pre></td></tr></table></figure><p>std::unique_ptr不允许复制，但是可以通过函数返回给其他std::unique_ptr，还可以通过std::move来转移给其他的std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">520</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 通过转移所有权的方式初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr3 = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique_ptr的指针类有一个reset方法，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( pointer ptr = pointer() )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>使用reset方法可以让unique_ptr解除对原始内存管理，也可以用来初始化一个独占智能指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr1.<span class="built_in">reset</span>();</span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ptr1.reset()</strong>; 解除对原始内存的管理</li><li><strong>ptr2.reset(new int(250))</strong>; 重新指定智能指针管理的原始内存</li></ul><p>如果想要获取独占智能指针管理原始地址，可以调用get()方法，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; *ptr2.<span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">// 得到内存地址中存储的实际数值 250</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、删除器"><a href="#5、删除器" class="headerlink" title="5、删除器"></a>5、删除器</h2><p>unique_ptr 指定删除器和 shared_ptr 指定删除器是有区别的，unique_ptr 指定删除器的时候需要确定删除器的类型，所以不能像 shared_ptr 那样直接指定删除器，举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;<span class="comment">// ok</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;<span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中第 7 行，<strong>func_ptr 的类型</strong>和 <strong>lambda表达式的类型</strong>是一致的。在 lambda 表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错。</p><p>上面的代码中错误原因是这样的，在 lambda 表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、RALL简介&quot;&gt;&lt;a href=&quot;#1、RALL简介&quot; class=&quot;headerlink&quot; title=&quot;1、RALL简介&quot;&gt;&lt;/a&gt;1、RALL简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;RALL是resource acquisition is initializ</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="智能指针" scheme="https://jjking20010901.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>汽车仪表盘绘制</title>
    <link href="https://jjking20010901.github.io/posts/cb2eafdb.html"/>
    <id>https://jjking20010901.github.io/posts/cb2eafdb.html</id>
    <published>2022-11-05T04:53:44.000Z</published>
    <updated>2022-11-06T02:30:34.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、汽车仪表盘效果图"><a href="#1、汽车仪表盘效果图" class="headerlink" title="1、汽车仪表盘效果图"></a>1、汽车仪表盘效果图</h2><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301516841.png" alt="image-20220830151624760"></p><p>上面是通过QPainter绘制出来的汽车仪表盘，可能与真实的汽车仪表盘有些差距，但总体来说还可以吧，下面将会详细讲解如何绘制汽车仪表盘。</p><h2 id="2、绘制前的准备"><a href="#2、绘制前的准备" class="headerlink" title="2、绘制前的准备"></a>2、绘制前的准备</h2><p>首先我们将窗体背景设置为偏黑色，这样方便我们后续观察效果，以及将窗口固定位1280*800，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1280</span>,<span class="number">800</span>);</span><br><span class="line">QPalette pale=<span class="keyword">this</span>-&gt;<span class="built_in">palette</span>();</span><br><span class="line">pale.<span class="built_in">setBrush</span>(QPalette::Window,<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>)));</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setPalette</span>(pale);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301439671.png" alt="image-20220830143915607"></p><h2 id="3、绘制刻度线"><a href="#3、绘制刻度线" class="headerlink" title="3、绘制刻度线"></a>3、绘制刻度线</h2><p>首先我们要获取仪表盘的中心点radius以及仪表盘的宽高，然后将画笔移动到窗口的中下方，移动画笔也就是移动坐标系。</p><p>然后使用QPainter中的抗锯齿的方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="type">int</span> width=<span class="keyword">this</span>-&gt;<span class="built_in">width</span>();</span><br><span class="line">   <span class="comment">//仪表盘高度</span></span><br><span class="line">   <span class="type">int</span> height=<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()<span class="number">-100</span>;</span><br><span class="line">   <span class="comment">//仪表盘中心位置</span></span><br><span class="line">   <span class="type">int</span> radius=((width&gt;height)? height:width)/<span class="number">2</span>;</span><br><span class="line">   <span class="comment">//移动画笔到中下方</span></span><br><span class="line">   painter.<span class="built_in">translate</span>(width/<span class="number">2</span>,height*<span class="number">0.6</span>);</span><br><span class="line">   <span class="comment">//启用反锯齿</span></span><br><span class="line">   painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>接下来就是画刻度线，首先我们要组装刻度点的路径，使用QPainterPath。然后是绘制长的刻度线，大于或者等于160的刻度值为红色，其他的刻度线为白色，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//画刻度线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawSmallScale</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//组装点的路径图</span></span><br><span class="line">    QPainterPath pointPath_small;</span><br><span class="line">    pointPath_small.<span class="built_in">moveTo</span>(<span class="number">-2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">    pointPath_small.<span class="built_in">lineTo</span>(<span class="number">-2</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QPainterPath pointPath_big;</span><br><span class="line">    pointPath_big.<span class="built_in">moveTo</span>(<span class="number">-2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">-2</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line">    pointPath_big.<span class="built_in">lineTo</span>(<span class="number">-2</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制121个小点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">121</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="function">QPointF <span class="title">point</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        point.<span class="built_in">setX</span>(radius*<span class="built_in">qCos</span>(((<span class="number">210</span>-i*<span class="number">2</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        point.<span class="built_in">setY</span>(radius*<span class="built_in">qSin</span>(((<span class="number">210</span>-i*<span class="number">2</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        painter.<span class="built_in">translate</span>(point.<span class="built_in">x</span>(),-point.<span class="built_in">y</span>());</span><br><span class="line">        painter.<span class="built_in">rotate</span>(<span class="number">-120</span>+i*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">235</span>,<span class="number">70</span>,<span class="number">70</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPath</span>(pointPath_big);<span class="comment">//绘画大刻度</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPath</span>(pointPath_small);<span class="comment">//绘画小刻度</span></span><br><span class="line">        &#125;</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301452519.png" alt="image-20220830145212461"></p><h2 id="4、刻度数字"><a href="#4、刻度数字" class="headerlink" title="4、刻度数字"></a>4、刻度数字</h2><p>在每一个更长的刻度线上绘制对应的数字，我们要找到对应的坐标，还要设置数字的字体以及大小，而且我们还要旋转画笔，让每个对应的数字都是在正确的位置，通过角度旋转的角度来计算弧度，然后通过弧度来获取对应的坐标，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刻度数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawDigital</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置画笔，画笔默认NOPEN</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">15</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;++i)&#123;</span><br><span class="line">        <span class="function">QPointF <span class="title">point</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        point.<span class="built_in">setX</span>(radius*<span class="built_in">qCos</span>(((<span class="number">210</span>-i*<span class="number">20</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        point.<span class="built_in">setY</span>(radius*<span class="built_in">qSin</span>(((<span class="number">210</span>-i*<span class="number">20</span>)*M_PI)/<span class="number">180</span>));</span><br><span class="line">        painter.<span class="built_in">translate</span>(point.<span class="built_in">x</span>(),-point.<span class="built_in">y</span>());</span><br><span class="line">        painter.<span class="built_in">rotate</span>(<span class="number">-120</span>+i*<span class="number">20</span>);</span><br><span class="line">        painter.<span class="built_in">drawText</span>(<span class="number">-25</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">20</span>,Qt::AlignCenter,QString::<span class="built_in">number</span>(i*<span class="number">20</span>));</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还原画笔</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301459646.png" alt="image-20220830145901581"></p><h2 id="5、绘制发光的圆圈"><a href="#5、绘制发光的圆圈" class="headerlink" title="5、绘制发光的圆圈"></a>5、绘制发光的圆圈</h2><p>在刻度线的四周绘制一种渐变色的发光圆圈，首先我们要创建大小圆的弧圈，通过arcTo方法，然后在小圆中绘制椭圆，通过addEllipse，然后通过QRadialGradient设置渐变色，最后通过drawPath方法获取大圆减小圆之后的路径，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath outRing;</span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    outRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    outRing.<span class="built_in">arcTo</span>(-radius,-radius, <span class="number">2</span>*radius,<span class="number">2</span>*radius,<span class="number">-30</span>,<span class="number">240</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    outRing.<span class="built_in">closeSubpath</span>();</span><br><span class="line">    <span class="comment">//设置渐变色k</span></span><br><span class="line">    <span class="function">QRadialGradient <span class="title">radialGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,radius,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">1</span>,<span class="built_in">QColor</span>(<span class="number">0</span>,<span class="number">82</span>,<span class="number">230</span>));</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">0.9</span>,Qt::transparent);</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(radialGradient);</span><br><span class="line">    <span class="comment">//大圆减小圆</span></span><br><span class="line">    painter.<span class="built_in">drawPath</span>(outRing.<span class="built_in">subtracted</span>(inRing));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301504164.png" alt="image-20220830150437094"></p><h2 id="6、绘制指针"><a href="#6、绘制指针" class="headerlink" title="6、绘制指针"></a>6、绘制指针</h2><p>和之前一样我们要组装点的路径，然后是计算点的坐标，这些都可以自己慢慢的试试，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawPointer</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//组装点的路径图</span></span><br><span class="line">    QPainterPath pointPath;</span><br><span class="line">    pointPath.<span class="built_in">moveTo</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">1</span>,-radius);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">-1</span>,-radius);</span><br><span class="line">    pointPath.<span class="built_in">lineTo</span>(<span class="number">-10</span>,<span class="number">0</span>);</span><br><span class="line">    pointPath.<span class="built_in">arcTo</span>(<span class="number">-10</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">180</span>,<span class="number">180</span>);</span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(<span class="number">-5</span>,<span class="number">-5</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算并选择绘图对象坐标</span></span><br><span class="line">    painter.<span class="built_in">rotate</span>(degRotate - <span class="number">120</span>);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(pointPath.<span class="built_in">subtracted</span>(inRing));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301508886.png" alt="image-20220830150828813"></p><h2 id="7、绘制中间大圆、小圆以及发光内圈"><a href="#7、绘制中间大圆、小圆以及发光内圈" class="headerlink" title="7、绘制中间大圆、小圆以及发光内圈"></a>7、绘制中间大圆、小圆以及发光内圈</h2><p>绘制大圆的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_big</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(inRing);</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制小圆的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_small</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存绘图对象</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="comment">//计算大小圆路径</span></span><br><span class="line">    QPainterPath inRing;</span><br><span class="line">    inRing.<span class="built_in">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    inRing.<span class="built_in">addEllipse</span>(-radius+<span class="number">50</span>,-radius + <span class="number">50</span>,<span class="number">2</span>*(radius<span class="number">-50</span>),<span class="number">2</span>*(radius<span class="number">-50</span>));</span><br><span class="line">    <span class="comment">//设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    painter.<span class="built_in">drawPath</span>(inRing);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制发光内圈的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawCircle_bom_shine</span><span class="params">(QPainter &amp;painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    <span class="function">QRadialGradient <span class="title">radialGradient</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,radius,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//    radialGradient.setColorAt(0.5,QColor(8,77,197));</span></span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">0.5</span>,<span class="built_in">QColor</span>(<span class="number">10</span>,<span class="number">68</span>,<span class="number">185</span>,<span class="number">150</span>));</span><br><span class="line">    radialGradient.<span class="built_in">setColorAt</span>(<span class="number">1.0</span>,Qt::transparent);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QBrush</span>(radialGradient));</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(-radius,-radius,<span class="number">2</span>*(radius),<span class="number">2</span>*(radius));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301513631.png" alt="image-20220830151303554"></p><h2 id="8、绘制单位和时速"><a href="#8、绘制单位和时速" class="headerlink" title="8、绘制单位和时速"></a>8、绘制单位和时速</h2><p>绘制速度单位的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawUnit</span><span class="params">(QPainter &amp; painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">16</span>);</span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-50</span>, -radius, <span class="number">100</span>, <span class="number">20</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;km/h&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-60</span>, -radius + <span class="number">130</span>, <span class="number">120</span>, <span class="number">40</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;当前车速&quot;</span>));</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">50</span>));</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-120</span>, -radius + <span class="number">280</span>, <span class="number">250</span>, <span class="number">40</span>,Qt::AlignCenter,<span class="built_in">QString</span>(<span class="string">&quot;-请按space键加速-&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制时速的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DrawNum</span><span class="params">(QPainter &amp; painter, <span class="type">int</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;Arial&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">45</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">-75</span>, -radius - <span class="number">20</span>, <span class="number">150</span>, <span class="number">100</span>,Qt::AlignCenter,QString::<span class="built_in">number</span>(degRotate));</span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208301515543.png" alt="image-20220830151543465"></p><h2 id="9、键盘事件和鼠标事件控制车速"><a href="#9、键盘事件和鼠标事件控制车速" class="headerlink" title="9、键盘事件和鼠标事件控制车速"></a>9、键盘事件和鼠标事件控制车速</h2><p>首先我们需要定义一个定时器timer，然后先将以下键盘事件，我们定义一个direction和degRotate，direction为0时代表减速或者车速为0，为1代表加速，degRotate代表车速，一开始为0。</p><p>当我们按下空格键时，定时器开始，同样的direction变为1，当定时器超时的时候，执行槽函数speed_changed。</p><p>下面是键盘按下事件的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>()==Qt::Key_Space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">            direction=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是槽函数speed_changed的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::speed_changed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(direction == <span class="number">1</span>)<span class="comment">//加速</span></span><br><span class="line">    &#123;</span><br><span class="line">        degRotate++;</span><br><span class="line">        <span class="keyword">if</span>(degRotate &gt; <span class="number">240</span>)</span><br><span class="line">            degRotate = <span class="number">240</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(direction == <span class="number">0</span>)<span class="comment">//减速</span></span><br><span class="line">    &#123;</span><br><span class="line">        degRotate--;</span><br><span class="line">        <span class="keyword">if</span>(degRotate &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            degRotate = <span class="number">0</span>;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们松开空格键时，direction为0，开始减速。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyReleaseEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>()==Qt::Key_Space)</span><br><span class="line">    &#123;</span><br><span class="line">        direction=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是鼠标点击事件和鼠标松开事件，当我们点击鼠标时，车速增加，松开时车速减少。</p><p>鼠标点击事件代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            is_Pressed=<span class="literal">true</span>;</span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">            direction=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标松开事件代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line">    is_Pressed=<span class="literal">false</span>;</span><br><span class="line">    direction=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、代码获取"><a href="#10、代码获取" class="headerlink" title="10、代码获取"></a>10、代码获取</h2><p>我已经将代码推送到了gitee上面了，想要源码的可以通过下方链接获取：</p><p><a href="https://gitee.com/GoodNightZoe/car-board.git">汽车仪表盘</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、汽车仪表盘效果图&quot;&gt;&lt;a href=&quot;#1、汽车仪表盘效果图&quot; class=&quot;headerlink&quot; title=&quot;1、汽车仪表盘效果图&quot;&gt;&lt;/a&gt;1、汽车仪表盘效果图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubuserconten</summary>
      
    
    
    
    <category term="QtWidget" scheme="https://jjking20010901.github.io/categories/QtWidget/"/>
    
    
    <category term="QtWidget自绘" scheme="https://jjking20010901.github.io/tags/QtWidget%E8%87%AA%E7%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>右值引用和完美转发</title>
    <link href="https://jjking20010901.github.io/posts/eaeeda04.html"/>
    <id>https://jjking20010901.github.io/posts/eaeeda04.html</id>
    <published>2022-11-04T09:09:13.000Z</published>
    <updated>2022-11-06T02:30:30.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、右值引用的简介"><a href="#1、右值引用的简介" class="headerlink" title="1、右值引用的简介"></a>1、右值引用的简介</h2><p>C++11增加了一个新的类型，称为<strong>右值引用(R-value reference)</strong>，标记为 <strong>&amp;&amp;。</strong>在介绍右值引用类型之前要先了解什么是左值和右值：</p><ul><li>lvalue是<strong>locator value</strong>的缩写，rvalue是 <strong>read value</strong>的缩写。</li><li>左值是指<strong>存储在内存中、有明确存储地址(可取地址)的数据。</strong></li><li>右值是指<strong>可以提供数据值的数据(不可取地址)。</strong></li></ul><p>通过描述可以看出，区分左值与右值的便捷方法是：<strong>可以对表达式取地址(&amp;)就是左值，否则为右值。</strong></p><p>所有有名字的变量或者对象都是左值，而右值是匿名的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1314</span>;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><p>一般情况下，位于 = 前面的表达式为左值，位于 = 后边的表达式为右值。也就是说例子中的a,b为左值，520,1314为右值。a=b是一种特殊情况，在这个表达式中a，b都是左值，因为变量b是可以被取地址的，不能视为右值。</p><p>C++11中右值可以分为两种：一个是将亡值，另一个则是纯右值：</p><ul><li><strong>纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambada表达式等。</strong></li><li><strong>将亡值：与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值、std::move的返回值等。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">520</span>;</span><br></pre></td></tr></table></figure><p>上面语句中的value为左值，520为字面量也就是右值。其中value可以被引用，但是520就不行了，因为字面量都是右值。</p><h2 id="2、右值引用的使用"><a href="#2、右值引用的使用" class="headerlink" title="2、右值引用的使用"></a>2、右值引用的使用</h2><p>右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用它的方式找到它。<strong>无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又”重获新生”。</strong></p><p>其生命周期与右值引用类型变量的声明周期一样，只要该变量还活着，该右值临时量将会一直存活下去。</p><p>关于右值引用的使用，参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; value = <span class="number">520</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1;</span><br><span class="line">    <span class="type">int</span> &amp;&amp;a2 = a1;        <span class="comment">// error</span></span><br><span class="line">    Test&amp; t = <span class="built_in">getObj</span>();   <span class="comment">// error</span></span><br><span class="line">    Test &amp;&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="type">const</span> Test&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上面的例子中<strong>int &amp;&amp;value=520;</strong>里面的520为纯右值，<strong>value</strong>是字面量<strong>520</strong>这个右值的引用。</li><li>在<strong>int &amp;&amp;a2=a1</strong>中；<strong>a1</strong>虽然写在<strong>=</strong>的右边，但是它仍然是一个左值，使<strong>用左值初始化一个右值引用是不合法的。</strong></li><li><strong>Test &amp; t=getObj()</strong>这段代码语法是错误的，<strong>右值不能给普通的左值引用赋值。</strong></li><li><strong>Test &amp;&amp; t=getObj()</strong>中getObj()返回的<strong>临时对象称为将亡值，t是这个将亡值的右值引用。</strong></li><li><strong>const Test &amp; t=getObj()</strong>这段代码语法是正确的，<strong>常量左值引用是一个万能的引用类型，它可以接受左值、右值、常量左值和常量右值。</strong></li></ul><h2 id="3、性能优化"><a href="#3、性能优化" class="headerlink" title="3、性能优化"></a>3、性能优化</h2><p>在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能优化。</p><p>修改以下上面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_num: &quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208161702687.png" alt="image-20220816170224552"></p><p>通过输出结果我们可以看到调用Test t=getObj()的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到对象t，在getObj()函数中创建的对象虽然进行了内存申请操作，但是没有使用就释放掉了。如果能够使用临时对象已经申请的资源，既能节省资源，还能节省申请和释放的时间，如果要执行这样的操作就需要使用右值引用了。</p><p><strong>右值引用具有移动语义，移动语义可将资源(堆、系统对象等)通过浅拷贝从一个对象转义到另一个对象这样就能减少不必要的临时对象的创建、拷贝及销毁，可以大幅度提高C++应用程序的性能。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加移动构造函数</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">m_num</span>(a.m_num)</span><br><span class="line">    &#123;</span><br><span class="line">        a.m_num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct: my name is sunny&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test class ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t.m_num: &quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码执行结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208161712211.png" alt="image-20220816171225155"></p><p>通过修改，在上面的代码给Test类添加了<strong>移动构造函数(参数为右值引用类型)，</strong>这样在进行Test t=getObj()操作时候并没有调用拷贝构造函数进行深拷贝，而是调用移动构造函数，这个函数中只是进行了浅拷贝，没有对临时对象进行深拷贝，提高性能。</p><p>如果不使用移动构造，在执行Test t=getObj()时候也是进行浅拷贝，但是临时对象被析构的时候，类成员指针int *m_num指向的内存也就被析构了，对象t也就无法访问这块内存地址了。</p><p>在测试程序中getObj()的返回值就是一个将亡值，也就是一个右值，在进行赋值操作的时候如果右边是一个右值，那么移动构造就会被调用。<strong>移动构造中使用了右值引用，会将临时对象的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。</strong></p><p><strong>注意：</strong></p><p><strong>对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数。</strong></p><h2 id="4、-amp-amp-的特性"><a href="#4、-amp-amp-的特性" class="headerlink" title="4、&amp;&amp;的特性"></a>4、&amp;&amp;的特性</h2><p>在 C++ 中，并不是所有情况下 <strong>&amp;&amp; 都代表是一个右值引用，</strong>具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为 T&amp;&amp;，如果是自动类型推导需要指定为 auto &amp;&amp;，在这两种场景下 &amp;&amp; 被称作未定的引用类型。另外还有一点需要额外注意 const T&amp;&amp; 表示一个右值引用，不是未定引用类型。</p><p>先看第一个例子，在函数模板中使用&amp;&amp;：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); </span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x); </span><br><span class="line"><span class="built_in">f1</span>(x);</span><br></pre></td></tr></table></figure><p>在上面的例子中函数模板进行了自动类型推导，需要通过传入的实参来确定参数param的实际类型。</p><ul><li>第4行中，对于f(10)来说传入的实参10是右值，因此T&amp;&amp;表示右值引用。</li><li>第6行中，对于f(x)来说传入的实参x是左值，因此T&amp;&amp;表示左值引用。</li><li>第7行中，f1(x)的参数是const T&amp;&amp;不是未定引用类型，不需要推导，本身就表示一个右值引用。</li></ul><p>再来看第二个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>, y = <span class="number">1314</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v1 = x;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v2 = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(x)&amp;&amp; v3 = y;   <span class="comment">// error</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;, v2: &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第4行中<strong>auto&amp;&amp;</strong>表示一个整形的左值引用。</li><li>第5行中<strong>auto&amp;&amp;</strong>表示一个整形的右值引用。</li><li>第6行中<strong>decltype(x)&amp;&amp;</strong>等价于<strong>int&amp;&amp;</strong>是一个右值引用不是未定义引用类型，y是一个左值，<strong>不能使用左值初始化一个右值引用类型。</strong></li></ul><p>由于上述代码存在T&amp;&amp;或者auto&amp;&amp;这种未定义引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，在进行类型推导时右值引用类型(&amp;&amp;)会发生变化，这种变化被称为引用折叠。在C++11中引用折叠规则如下：</p><ul><li><p><strong>通过右值推导T&amp;&amp;或者auto&amp;&amp;得到的是一个右值引用类型。</strong></p></li><li><p><strong>通过非右值(右值引用、左值、左值引用、常量右值引用、常量左值引用)推导T&amp;&amp;或者auto&amp;&amp;得到的是一个左值引用类型。</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; a1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb = a1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb1 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;a3 = a2;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc = a3;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc1 = a2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; s1 = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; s2 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; dd = s1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; ee = s2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li>第2行：a1为右值引用，推导出bb为左值引用类型。</li><li>第3行：5为右值，推导出的bb1为右值引用类型。</li><li>第7行：a3为左值引用，推导出的cc为左值引用。</li><li>第8行：a2为左值引用，推导出的cc1为左值引用。</li><li>第12行：s1为常量左值引用，推导出的dd为常量左值引用。</li><li>第13行：s2为常量右值引用，推导出的ee为常量右值引用。</li><li>第15行：x为右值引用，不需要推导，只能通过右值初始化。</li></ul><p>最后再看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;&amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">520</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(i);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">1314</span>);</span><br><span class="line">    forward(<span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208171011704.png" alt="image-20220817101112650"></p><p>根据测试代码可以得知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重置函数（printValue），函数 forward () 接收的是一个右值，但是在这个函数中调用函数 printValue () 时，参数 k 变成了一个命名对象，编译器会将其当做左值来处理。</p><p>最后总结以下关于&amp;&amp;的使用：</p><ul><li><strong>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</strong></li><li><strong>编译器会将已命名的右值视为左值，将未命名的右值视为右值。</strong></li><li><strong>auto&amp;&amp;或者参数类型自动类型推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型。</strong></li><li><strong>通过右值推导T&amp;&amp;或者auto&amp;&amp;得到的是一个右值引用类型，其余都是左值引用类型。</strong></li></ul><h2 id="5、std-move"><a href="#5、std-move" class="headerlink" title="5、std::move"></a>5、std::move</h2><p>在C++11中添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，<strong>使用std::move方法可以将左值转化为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样具有移动语义，将对象的状态或者所有权从一个对象移动到另一个对象上，只是转移，没有内存拷贝。</strong></p><p>从实现上讲，std::move基本等同于一个类型转换：<strong>static_cast<T&&>(lvalue)；</strong>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Ty&gt;</span></span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// forward _Arg as movable</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    Test &amp;&amp; v1 = t;          <span class="comment">// error</span></span><br><span class="line">    Test &amp;&amp; v2 = <span class="built_in">move</span>(t);    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第10行中，使用左值初始化右值引用，因此语法错误。</li><li>第11行中，使用move函数将左值转化为右值，这样就可以初始化右值引用了。</li></ul><p>假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; ls;</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">......</span><br><span class="line">list&lt;string&gt; ls1 = ls;        <span class="comment">// 需要拷贝, 效率低</span></span><br><span class="line">list&lt;string&gt; ls2 = <span class="built_in">move</span>(ls);</span><br></pre></td></tr></table></figure><p>如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权，如果一个对象内部有较大的堆内存或者动态数组时，使用move就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数<strong>(T::T(T&amp;&amp;another))</strong>和具有移动语义的赋值函数<strong>(T&amp;&amp;T::operator=(T&amp;&amp;rhs))</strong>，在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。</p><h2 id="6、std-forward"><a href="#6、std-forward" class="headerlink" title="6、std::forward"></a>6、std::forward</h2><p>右值引用类型是独立于值的，一个右值引用作为函数的形参时，在函数内部转发该参数给内部其他函数时，它就变成了一个左值，并不是原来的类型了。如果需要按照原来的类型转发到另一个函数，<strong>可以使用C++11提供的std::forward函数，该函数实现的功能称之为完美转发。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简之后的样子</span></span><br><span class="line">std::forward&lt;T&gt;(t);</span><br></pre></td></tr></table></figure><ul><li>当T为左值引用类型时，t将被转化为T类型的左值。</li><li>当T不是左值引用类型时，t将被转化为T类型的右值。</li></ul><p>下面通过一个例子演示一下关于forward的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">520</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1314</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(num);</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码的结果如下：</p><p><img src="https://raw.githubusercontent.com/jjking20010901/typora/master/img202208171101969.png" alt="image-20220817110147910"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、右值引用的简介&quot;&gt;&lt;a href=&quot;#1、右值引用的简介&quot; class=&quot;headerlink&quot; title=&quot;1、右值引用的简介&quot;&gt;&lt;/a&gt;1、右值引用的简介&lt;/h2&gt;&lt;p&gt;C++11增加了一个新的类型，称为&lt;strong&gt;右值引用(R-value refe</summary>
      
    
    
    
    <category term="CPP11的学习" scheme="https://jjking20010901.github.io/categories/CPP11%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="CPP11新特性" scheme="https://jjking20010901.github.io/tags/CPP11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
</feed>
